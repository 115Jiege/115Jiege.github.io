<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我一点也不生气</title>
      <link href="/2023/07/03/%E6%97%A5%E5%B8%B8/%E6%88%91%E4%B8%80%E7%82%B9%E4%B9%9F%E4%B8%8D%E7%94%9F%E6%B0%94/"/>
      <url>/2023/07/03/%E6%97%A5%E5%B8%B8/%E6%88%91%E4%B8%80%E7%82%B9%E4%B9%9F%E4%B8%8D%E7%94%9F%E6%B0%94/</url>
      
        <content type="html"><![CDATA[<p>最近好烦，背一背古文静心叭。</p><h3 id="滕王阁序"><a class="header-anchor" href="#滕王阁序">¶</a>滕王阁序</h3><p><strong>滕王阁序</strong></p><p>【唐】王勃</p><blockquote><p>豫章故郡，洪都新府。星分翼轸，地接衡庐。襟三江而带五湖，控蛮荆而引瓯越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰。台隍枕夷夏之交，宾主尽东南之美。都督阎公之雅望，棨戟遥临；宇文新州之懿范，襜帷暂驻。十旬休假，胜友如云；千里逢迎，高朋满座。腾蛟起凤，孟学士之词宗；紫电青霜，王将军之武库。家君作宰，路出名区；童子何知，躬逢胜饯。</p></blockquote><blockquote><p>时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿。临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。</p></blockquote><blockquote><p>披绣闼，俯雕甍，山原旷其盈视，川泽纡其骇瞩。闾阎扑地，钟鸣鼎食之家；舸舰弥津，青雀黄龙之舳。云销雨霁，彩彻区明。落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨，雁阵惊寒，声断衡阳之浦。</p></blockquote><blockquote><p>遥襟甫畅，逸兴遄飞。爽籁发而清风生，纤歌凝而白云遏。睢园绿竹，气凌彭泽之樽；邺水朱华，光照临川之笔。四美具，二难并。穷睇眄于中天，极娱游于暇日。天高地迥，觉宇宙之无穷；兴尽悲来，识盈虚之有数。望长安于日下，目吴会于云间。地势极而南溟深，天柱高而北辰远。关山难越，谁悲失路之人；萍水相逢，尽是他乡之客。怀帝阍而不见，奉宣室以何年？</p></blockquote><blockquote><p>嗟乎！时运不齐，命途多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！</p></blockquote><blockquote><p>勃，三尺微命，一介书生。无路请缨，等终军之弱冠；有怀投笔，慕宗悫之长风。舍簪笏于百龄，奉晨昏于万里。非谢家之宝树，接孟氏之芳邻。他日趋庭，叨陪鲤对；今兹捧袂，喜托龙门。杨意不逢，抚凌云而自惜；钟期既遇，奏流水以何惭？</p></blockquote><blockquote><p>呜呼！胜地不常，盛筵难再；兰亭已矣，梓泽丘墟。临别赠言，幸承恩于伟饯；登高作赋，是所望于群公。敢竭鄙怀，恭疏短引；一言均赋，四韵俱成。请洒潘江，各倾陆海云尔：</p></blockquote><blockquote><p>滕王高阁临江渚，佩玉鸣鸾罢歌舞。<br>　　画栋朝飞南浦云，珠帘暮卷西山雨。<br>　　闲云潭影日悠悠，物换星移几度秋。<br>　　阁中帝子今何在？槛外长江空自流。</p></blockquote><h3 id="岳阳楼记"><a class="header-anchor" href="#岳阳楼记">¶</a>岳阳楼记</h3><p><strong>岳阳楼记</strong></p><p>【宋】范仲淹</p><blockquote><p>庆历四年春，滕子京谪守巴陵郡。越明年，政通人和，百废具兴，乃重修岳阳楼，增其旧制，刻唐贤今人诗赋于其上，属予作文以记之。</p></blockquote><blockquote><p>予观夫巴陵胜状，在洞庭一湖。衔远山，吞长江，浩浩汤汤，横无际涯，朝晖夕阴，气象万千，此则岳阳楼之大观也，前人之述备矣。然则北通巫峡，南极潇湘，迁客骚人，多会于此，览物之情，得无异乎？</p></blockquote><blockquote><p>若夫淫雨霏霏，连月不开，阴风怒号，浊浪排空，日星隐曜，山岳潜形，商旅不行，樯倾楫摧，薄暮冥冥，虎啸猿啼。登斯楼也，则有去国怀乡，忧谗畏讥，满目萧然，感极而悲者矣。</p></blockquote><blockquote><p>至若春和景明，波澜不惊，上下天光，一碧万顷，沙鸥翔集，锦鳞游泳，岸芷汀兰，郁郁青青。而或长烟一空，皓月千里，浮光跃金，静影沉璧，渔歌互答，此乐何极！登斯楼也，则有心旷神怡，宠辱偕忘，把酒临风，其喜洋洋者矣。</p></blockquote><blockquote><p>嗟夫！予尝求古仁人之心，或异二者之为，何哉？不以物喜，不以己悲，居庙堂之高则忧其民，处江湖之远则忧其君。是进亦忧，退亦忧。然则何时而乐耶？其必曰“先天下之忧而忧，后天下之乐而乐”乎！噫！微斯人，吾谁与归？</p></blockquote><blockquote><p>时六年九月十五日。</p></blockquote><h3 id="逍遥游"><a class="header-anchor" href="#逍遥游">¶</a>逍遥游</h3><p>庄子</p><blockquote><p>北冥有鱼，其名为鲲。鲲之大，不知其几千里也；化而为鸟，其名为鹏。鹏之背，不知其几千里也；怒而飞，其翼若垂天之云。是鸟也，海运则将徙于南冥。南冥者，天池也。《齐谐》者，志怪者也。《谐》之言曰：“鹏之徙于南冥也，水击三千里，抟扶摇而上者九万里，去以六月息者也。”野马也，尘埃也，生物之以息相吹也。天之苍苍，其正色邪？其远而无所至极邪？其视下也，亦若是则已矣。且夫水之积也不厚，则其负大舟也无力。覆杯水于坳堂之上，则芥为之舟；置杯焉则胶，水浅而舟大也。风之积也不厚，则其负大翼也无力。故九万里，则风斯在下矣，而后乃今培风；背负青天，而莫之夭阏者，而后乃今将图南。蜩与学鸠笑之曰：“我决起而飞，抢榆枋而止，时则不至，而控于地而已矣，奚以之九万里而南为？”适莽苍者，三餐而反，腹犹果然；适百里者，宿舂粮；适千里者，三月聚粮。之二虫又何知！小知不及大知，小年不及大年。奚以知其然也？朝菌不知晦朔，蟪蛄不知春秋，此小年也。楚之南有冥灵者，以五百岁为春，五百岁为秋；上古有大椿者，以八千岁为春，八千岁为秋。此大年也。而彭祖乃今以久特闻，众人匹之，不亦悲乎？</p></blockquote><blockquote><p>汤之问棘也是已：“穷发之北，有冥海者，天池也。有鱼焉，其广数千里，未有知其修者，其名为鲲。有鸟焉，其名为鹏，背若泰山，翼若垂天之云；抟扶摇羊角而上者九万里，绝云气，负青天，然后图南，且适南冥也。斥鷃笑之曰：‘彼且奚适也？我腾跃而上，不过数仞而下，翱翔蓬蒿之间，此亦飞之至也。而彼且奚适也？’”此小大之辩也。</p></blockquote><blockquote><p>故夫知效一官、行比一乡、德合一君、而征一国者，其自视也，亦若此矣。而宋荣子犹然笑之。且举世誉之而不加劝，举世非之而不加沮，定乎内外之分，辩乎荣辱之境，斯已矣。彼其于世，未数数然也。虽然，犹有未树也。夫列子御风而行，泠然善也，旬有五日而后反。彼于致福者，未数数然也。此虽免乎行，犹有所待者也。若夫乘天地之正，而御六气之辩，以游无穷者，彼且恶乎待哉？故曰：至人无己，神人无功，圣人无名。</p></blockquote><blockquote><p>尧让天下于许由，曰：“日月出矣，而爝火不息；其于光也，不亦难乎？时雨降矣，而犹浸灌；其于泽也，不亦劳乎？夫子立而天下治，而我犹尸之；吾自视缺然，请致天下。”许由曰：“子治天下，天下既已治也；而我犹代子，吾将为名乎？名者，实之宾也；吾将为宾乎？鹪鹩巢于深林，不过一枝；偃鼠饮河，不过满腹。归休乎君，予无所用天下为！庖人虽不治庖，尸祝不越樽俎而代之矣！”</p></blockquote><blockquote><p>肩吾问于连叔曰：“吾闻言于接舆，大而无当，往而不反。吾惊怖其言。犹河汉而无极也；大有径庭，不近人情焉。”连叔曰：“其言谓何哉？”曰：“藐姑射之山，有神人居焉。肌肤若冰雪，淖约若处子，不食五谷，吸风饮露，乘云气，御飞龙，而游乎四海之外；其神凝，使物不疵疠而年谷熟。吾以是狂而不信也。”连叔曰：“然。瞽者无以与乎文章之观，聋者无以与乎钟鼓之声。岂唯形骸有聋盲哉？夫知亦有之！是其言也犹时女也。之人也，之德也，将旁礴万物以为一，世蕲乎乱，孰弊弊焉以天下为事！之人也，物莫之伤：大浸稽天而不溺，大旱金石流，土山焦而不热。是其尘垢秕糠将犹陶铸尧舜者也，孰肯以物为事？”宋人资章甫而适诸越，越人断发文身，无所用之。尧治天下之民，平海内之政，往见四子藐姑射之山，汾水之阳，窅然丧其天下焉。</p></blockquote><blockquote><p>惠子谓庄子曰：“魏王贻我大瓠之种，我树之成，而实五石。以盛水浆，其坚不能自举也。剖之以为瓢，则瓠落无所容。非不呺然大也，吾为其无用而掊之。”庄子曰：“夫子固拙于用大矣。宋人有善为不龟手之药者，世世以洴澼絖为事。客闻之，请买其方百金。聚族而谋曰：‘我世世为洴澼絖，不过数金，今一朝而鬻技百金，请与之。’客得之，以说吴王。越有难，吴王使之将，冬，与越人水战，大败越人。裂地而封之。能不龟手一也，或以封，或不免于洴澼絖，则所用之异也。今子有五石之瓠，何不虑以为大樽，而浮于江湖，而忧其瓠落无所容？则夫子犹有蓬之心也夫！”</p></blockquote><blockquote><p>惠子谓庄子曰：“吾有大树，人谓之樗。其大本拥肿而不中绳墨，其小枝卷曲而不中规矩，立之涂，匠者不顾。今子之言大而无用，众所同去也。”庄子曰：“子独不见狸狌乎？卑身而伏，以候敖者；东西跳梁，不辟高下；中于机辟，死于罔罟。今夫斄牛，其大若垂天之云。此能为大矣，而不能执鼠。今子有大树，患其无用，何不树之于无何有之乡，广莫之野，彷徨乎无为其侧，逍遥乎寝卧其下。不夭斤斧，物无害者，无所可用，安所困苦哉！”</p></blockquote><h3 id="生于忧患，死于安乐"><a class="header-anchor" href="#生于忧患，死于安乐">¶</a>生于忧患，死于安乐</h3><p>孟子</p><blockquote><p>舜发于畎亩之中，傅说举于版筑之间，胶鬲举于鱼盐之中，管夷吾举于士，孙叔敖举于海，百里奚举于市。故天将降大任于是人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。</p></blockquote><blockquote><p>人恒过，然后能改；困于心，衡于虑，而后作；征于色，发于声，而后喻。入则无法家拂士，出则无敌国外患者，国恒亡。然后知生于忧患而死于安乐也。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 发疯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github拉取上传失败的解决</title>
      <link href="/2023/06/30/tips%E6%95%B4%E7%90%86/github%E6%8B%89%E5%8F%96%E4%B8%8A%E4%BC%A0%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
      <url>/2023/06/30/tips%E6%95%B4%E7%90%86/github%E6%8B%89%E5%8F%96%E4%B8%8A%E4%BC%A0%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>今天久违的更新一下国密，结果push的时候提示<code>could not find UI helper 'GitHub.UI'</code>，并且卡死在这里。</p><p>bing了一下，两种原因；</p><h3 id="1-缺少凭据"><a class="header-anchor" href="#1-缺少凭据">¶</a>1.缺少凭据</h3><p>打开控制面板-&gt;用户账户-&gt;凭据管理器-&gt;管理Windows凭据；</p><p>添加普通凭据，</p><p>地址输入<a href="https://gitee.com/" title="https://gitee.com/">https://gitee.com/</a>，或者你的github地址，填写用户名密码。</p><h3 id="2-已配置其他凭据"><a class="header-anchor" href="#2-已配置其他凭据">¶</a>2.已配置其他凭据</h3><p>就像我。凭据是已经配置了的，但是！！我的git全局配置居然设了另一个凭据。</p><p>(git config --list可以查看当前git目录的配置)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git-credential-manager configure</span><br><span class="line"></span><br><span class="line">git-credential-manager get</span><br></pre></td></tr></table></figure><p>然后就有登录页面辣！重登就好~</p><h3 id="终极解决方法"><a class="header-anchor" href="#终极解决方法">¶</a>终极解决方法</h3><p>安装<a href="https://desktop.github.com/">GitHub Desktop | Simple collaboration from your desktop</a></p><p>方便好用的嘞。</p>]]></content>
      
      
      <categories>
          
          <category> tips整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows开发——管理系统服务 </title>
      <link href="/2023/06/08/%E5%B9%B3%E5%8F%B0-Windows/Windows%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"/>
      <url>/2023/06/08/%E5%B9%B3%E5%8F%B0-Windows/Windows%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="创建删除"><a class="header-anchor" href="#创建删除">¶</a>创建删除</h2><h3 id="CreateService"><a class="header-anchor" href="#CreateService">¶</a>CreateService</h3><p><a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winsvc/nf-winsvc-createservicea">CreateService</a></p><ol><li><p>用途<br>创建服务对象并将其添加到指定的服务控制管理器数据库。</p></li><li><p>语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SC_HANDLE <span class="title">CreateServiceA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            SC_HANDLE hSCManager,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            LPCSTR    lpServiceName,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpDisplayName,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            DWORD     dwDesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            DWORD     dwServiceType,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            DWORD     dwStartType,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            DWORD     dwErrorControl,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpBinaryPathName,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpLoadOrderGroup,</span></span></span><br><span class="line"><span class="params"><span class="function">[out, optional] LPDWORD   lpdwTagId,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpDependencies,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpServiceStartName,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpPassword</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>返回值<br>如果函数成功，则返回值是服务的句柄。<br>如果函数失败，则返回值为 NULL。 要获得更多的错误信息，请调用 GetLastError</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CreateMyService</span><span class="params">(SC_HANDLE* scm, SC_HANDLE* myservice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 创建一个自启动服务 */</span></span><br><span class="line">SC_HANDLE service = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">std::wstring ServiceName = <span class="string">L&quot;Jiege Service&quot;</span>;</span><br><span class="line">std::wstring ShowServiceName = <span class="string">L&quot;Jiege&quot;</span>;</span><br><span class="line"></span><br><span class="line">DWORD dwError = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">service = <span class="built_in">OpenService</span>(*scm, ServiceName.<span class="built_in">c_str</span>(), SERVICE_ALL_ACCESS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (service != <span class="literal">NULL</span>)   <span class="comment">/* 服务已存在 */</span></span><br><span class="line">&#123;</span><br><span class="line">dwError = <span class="built_in">GetLastError</span>();</span><br><span class="line"><span class="built_in">LOG_ERROR</span>(<span class="string">&quot;OpenService error: &#123;0&#125;.&quot;</span>, dwError);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">DeleteService</span>(service))</span><br><span class="line">&#123;</span><br><span class="line">dwError = <span class="built_in">GetLastError</span>();</span><br><span class="line"><span class="built_in">LOG_ERROR</span>(<span class="string">&quot;DeleteService error: &#123;0&#125;.&quot;</span>, dwError);</span><br><span class="line">::<span class="built_in">CloseServiceHandle</span>(service);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::<span class="built_in">CloseServiceHandle</span>(service);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">service = <span class="built_in">CreateService</span>(*scm,</span><br><span class="line">ServiceName.<span class="built_in">c_str</span>(),</span><br><span class="line">ShowServiceName.<span class="built_in">c_str</span>(),</span><br><span class="line">SERVICE_ALL_ACCESS,</span><br><span class="line">SERVICE_WIN32_OWN_PROCESS,</span><br><span class="line">SERVICE_AUTO_START,</span><br><span class="line">SERVICE_ERROR_NORMAL,</span><br><span class="line"><span class="string">L&quot;F:/myproject/JiegeService/JiegeService.EXE&quot;</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(service))</span><br><span class="line">&#123;</span><br><span class="line">dwError = <span class="built_in">GetLastError</span>();</span><br><span class="line"><span class="built_in">LOG_ERROR</span>(<span class="string">&quot;CreateService error: &#123;0&#125;.&quot;</span>, dwError);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*myservice = service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="DeleteService"><a class="header-anchor" href="#DeleteService">¶</a>DeleteService</h3><p><a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winsvc/nf-winsvc-deleteservice">DeleteService</a></p><ol><li><p>用途<br>标记要从服务控制管理器数据库中删除的指定服务。</p></li><li><p>语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DeleteService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[in] SC_HANDLE hService</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>返回值<br>如果该函数成功，则返回值为非零值。<br>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。<br>服务控制管理器可以设置以下错误代码。 其他函数可能由服务控制管理器调用的注册表函数设置。</p><table><thead><tr><th>返回代码</th><th>说明</th></tr></thead><tbody><tr><td><strong>ERROR_ACCESS_DENIED</strong></td><td>句柄没有 DELETE 访问权限。</td></tr><tr><td><strong>ERROR_INVALID_HANDLE</strong></td><td>指定的句柄无效。</td></tr><tr><td><strong>ERROR_SERVICE_MARKED_FOR_DELETE</strong></td><td>指定的服务已被标记为要删除。</td></tr></tbody></table></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">       <span class="keyword">if</span> (!<span class="built_in">DeleteService</span>(service))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">LOG_ERROR</span>(<span class="string">&quot;DeleteService error.&quot;</span>);</span><br><span class="line">::<span class="built_in">CloseServiceHandle</span>(scm);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;DeleteService success.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::<span class="built_in">CloseServiceHandle</span>(scm);</span><br></pre></td></tr></table></figure></li></ol><h2 id="枚举信息"><a class="header-anchor" href="#枚举信息">¶</a>枚举信息</h2><h3 id="EnumServicesStatus"><a class="header-anchor" href="#EnumServicesStatus">¶</a>EnumServicesStatus</h3><ol><li><p>用途<br>枚举指定服务控制管理器数据库中的服务。 提供了每个服务的名称和状态。<br>此函数已被 EnumServicesStatusEx)函数取代。 它返回相同的信息 <strong>EnumServicesStatus</strong> 返回，以及进程标识符和服务的其他信息。 此外， <strong>EnumServicesStatusEx</strong> 使你可以枚举属于指定组的服务。</p></li><li><p>语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EnumServicesStatusA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[in]                SC_HANDLE              hSCManager,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]                DWORD                  dwServiceType,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]                DWORD                  dwServiceState,</span></span></span><br><span class="line"><span class="params"><span class="function">[out, optional]     LPENUM_SERVICE_STATUSA lpServices,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]                DWORD                  cbBufSize,</span></span></span><br><span class="line"><span class="params"><span class="function">[out]               LPDWORD                pcbBytesNeeded,</span></span></span><br><span class="line"><span class="params"><span class="function">[out]               LPDWORD                lpServicesReturned,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, out, optional] LPDWORD                lpResumeHandle</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>ENUM_SERVICE_STATUSA结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span></span><br><span class="line">LPSTR          lpServiceName;</span><br><span class="line">LPSTR          lpDisplayName;</span><br><span class="line">SERVICE_STATUS ServiceStatus;</span><br><span class="line">&#125; ENUM_SERVICE_STATUSA, *LPENUM_SERVICE_STATUSA;</span><br></pre></td></tr></table></figure><p>结构中包含服务名称，显示名称，启动状态.</p></li><li><p>返回值<br>如果该函数成功，则返回值为非零值。<br>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。 可能会返回以下错误。</p><table><thead><tr><th>返回代码</th><th>说明</th></tr></thead><tbody><tr><td><strong>ERROR_ACCESS_DENIED</strong></td><td>句柄没有<strong>SC_MANAGER_ENUMERATE_SERVICE</strong> 访问权限。</td></tr><tr><td><strong>ERROR_MORE_DATA</strong></td><td>缓冲区太小。 并非所有活动数据库中的数据都可以返回。<em>tbBytesNeeded</em> 参数包含接收剩余条目所需的字节数。</td></tr><tr><td><strong>ERROR_INVALID_PARAMETER</strong></td><td>使用了非法参数值。</td></tr><tr><td><strong>ERROR_INVALID_HANDLE</strong></td><td>该句柄无效。</td></tr><tr><td><strong>ERROR_INVALID_LEVEL</strong></td><td><em>InfoLevel</em> 参数包含不受支持的值。</td></tr><tr><td><strong>ERROR_SHUTDOWN_IN_PROGRESS</strong></td><td>系统正在关闭;无法调用此函数。</td></tr></tbody></table></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">LPENUM\_SERVICE\_STATUS lpServices    = <span class="literal">NULL</span>;   </span><br><span class="line"> DWORD    nSize = <span class="number">0</span>;</span><br><span class="line"> DWORD    n;</span><br><span class="line"> DWORD    nResumeHandle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> lpServices = (LPENUM\_SERVICE\_STATUS) <span class="built_in">LocalAlloc</span>(LPTR, <span class="number">64</span> \* <span class="number">1024</span>);   </span><br><span class="line"> <span class="built_in">EnumServicesStatus</span>(scm,SERVICE\_WIN32,   </span><br><span class="line">                    SERVICE\_STATE\_ALL,   </span><br><span class="line">                    (LPENUM\_SERVICE\_STATUS)lpServices,   </span><br><span class="line">                     <span class="number">64</span>  * <span class="number">1024</span>,   </span><br><span class="line">                     &amp;nSize,   </span><br><span class="line">                     &amp;n,   </span><br><span class="line">                     &amp;nResumeHandle);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n; i++)   </span><br><span class="line"> &#123; </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;服务名称: %s&quot;</span>,lpServices[i].lpServiceName);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;显示名称: %s&quot;</span>,lpServices[i].lpDisplayName);</span><br><span class="line">     <span class="keyword">if</span> ( lpServices[i].ServiceStatus.dwCurrentState!=SERVICE\_STOPPED)</span><br><span class="line">     &#123;   </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;启动状态:    已启动/n&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="EnumServicesStatusEx"><a class="header-anchor" href="#EnumServicesStatusEx">¶</a>EnumServicesStatusEx</h3><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-enumservicesstatusexa">EnumServicesStatusEx</a></p><ol><li><p>用途<br>枚举指定服务控制管理器数据库中的服务。 提供每个服务的名称和状态，以及基于指定信息级别的其他数据。</p></li><li><p>语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EnumServicesStatusExA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[in]                SC_HANDLE    hSCManager,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]                SC_ENUM_TYPE InfoLevel,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]                DWORD        dwServiceType,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]                DWORD        dwServiceState,</span></span></span><br><span class="line"><span class="params"><span class="function">[out, optional]     LPBYTE       lpServices,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]                DWORD        cbBufSize,</span></span></span><br><span class="line"><span class="params"><span class="function">[out]               LPDWORD      pcbBytesNeeded,</span></span></span><br><span class="line"><span class="params"><span class="function">[out]               LPDWORD      lpServicesReturned,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, out, optional] LPDWORD      lpResumeHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]      LPCSTR       pszGroupName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>返回值<br>如果该函数成功，则返回值为非零值。<br>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。 可能会返回以下错误。</p><table><thead><tr><th>返回代码</th><th>说明</th></tr></thead><tbody><tr><td><strong>ERROR_ACCESS_DENIED</strong></td><td>句柄没有<strong>SC_MANAGER_ENUMERATE_SERVICE</strong> 访问权限。</td></tr><tr><td><strong>ERROR_MORE_DATA</strong></td><td>缓冲区太小。 并非所有活动数据库中的数据都可以返回。<em>tbBytesNeeded</em> 参数包含接收剩余条目所需的字节数。</td></tr><tr><td><strong>ERROR_INVALID_PARAMETER</strong></td><td>使用了非法参数值。</td></tr><tr><td><strong>ERROR_INVALID_HANDLE</strong></td><td>该句柄无效。</td></tr><tr><td><strong>ERROR_INVALID_LEVEL</strong></td><td><em>InfoLevel</em> 参数包含不受支持的值。</td></tr><tr><td><strong>ERROR_SHUTDOWN_IN_PROGRESS</strong></td><td>系统正在关闭;无法调用此函数。</td></tr></tbody></table></li></ol><h3 id="QueryServiceConfig"><a class="header-anchor" href="#QueryServiceConfig">¶</a>QueryServiceConfig</h3><p><a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winsvc/nf-winsvc-queryserviceconfiga">QueryServiceConfig</a></p><ol><li><p>用途<br>检索指定服务的配置参数。</p></li><li><p>语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">QueryServiceConfigA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            SC_HANDLE               hService,</span></span></span><br><span class="line"><span class="params"><span class="function">[out, optional] LPQUERY_SERVICE_CONFIGA lpServiceConfig,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            DWORD                   cbBufSize,</span></span></span><br><span class="line"><span class="params"><span class="function">[out]           LPDWORD                 pcbBytesNeeded</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>返回值<br>如果该函数成功，则返回值为非零值。<br>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。<br>服务控制管理器可以设置以下错误代码。 其他可由服务控制管理器调用的注册表函数设置。</p><table><thead><tr><th>返回代码</th><th>说明</th></tr></thead><tbody><tr><td><strong>ERROR_ACCESS_DENIED</strong></td><td>句柄没有SERVICE_QUERY_CONFIG访问权限。</td></tr><tr><td><strong>ERROR_INSUFFICIENT_BUFFER</strong></td><td>服务配置信息比<em>lpServiceConfig</em> 缓冲区更适合。 获取所有信息所需的字节数在 <em>tbBytesNeededed</em> 参数中返回。 不写入 <em>lpServiceConfig</em>。</td></tr><tr><td><strong>ERROR_INVALID_HANDLE</strong></td><td>指定的句柄无效。</td></tr></tbody></table></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LPQUERY\_SERVICE\_CONFIG ServicesInfo = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n; i++)   </span><br><span class="line"> &#123;</span><br><span class="line">     SC_HANDLE service = <span class="literal">NULL</span>;</span><br><span class="line">     DWORD     nResumeHandle = <span class="number">0</span>; </span><br><span class="line">     service=<span class="built_in">OpenService</span>(scm,lpServices[i].lpServiceName,SERVICE_ALL_ACCESS);</span><br><span class="line">     ServicesInfo = (LPQUERY_SERVICE_CONFIG) <span class="built_in">LocalAlloc</span>(LPTR, <span class="number">64</span> \* <span class="number">1024</span>);      <span class="comment">//注意分配足够的空间</span></span><br><span class="line">     <span class="built_in">QueryServiceConfig</span>(service,ServicesInfo,<span class="number">64</span> \* <span class="number">1024</span>,&amp;nResumeHandle);      <span class="comment">//枚举各个服务信息</span></span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;程序路径: %s&quot;</span>,ServicesInfo-&gt;lpBinaryPathName);   </span><br><span class="line">     <span class="keyword">if</span>(<span class="number">2</span>==ServicesInfo-&gt;dwStartType)        <span class="comment">//启动方式   </span></span><br><span class="line">     &#123; </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;自动/n&quot;</span>);   </span><br><span class="line">     &#125;   </span><br><span class="line">     <span class="keyword">if</span>(<span class="number">3</span>==ServicesInfo-&gt;dwStartType)        &#123;   </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;手动/n&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(<span class="number">4</span>==ServicesInfo-&gt;dwStartType)   </span><br><span class="line">     &#123;   </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;禁止/n&quot;</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="配置权限"><a class="header-anchor" href="#配置权限">¶</a>配置权限</h2><h3 id="openSCManager"><a class="header-anchor" href="#openSCManager">¶</a>openSCManager</h3><p><a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winsvc/nf-winsvc-openscmanagera">OpenSCManager</a></p><ol><li><p>用途<br>建立与指定计算机上的服务控制管理器的连接，并打开指定的服务控制管理器数据库。</p></li><li><p>语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SC_HANDLE <span class="title">OpenSCManagerA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR lpMachineName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR lpDatabaseName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DWORD  dwDesiredAccess</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>返回值<br>如果函数成功，则返回值是指定服务控制管理器数据库的句柄。<br>如果函数失败，则返回值为 NULL。 要获得更多的错误信息，请调用GetLastError。<br>SCM 可以设置以下错误代码。 其他错误代码可由 SCM 调用的注册表函数设置。</p><table><thead><tr><th>返回代码</th><th>描述</th></tr></thead><tbody><tr><td><strong>ERROR_ACCESS_DENIED</strong></td><td>请求的访问被拒绝。</td></tr><tr><td><strong>ERROR_DATABASE_DOES_NOT_EXIST</strong></td><td>指定的数据库不存在。</td></tr></tbody></table></li><li><p>示例<br>以完全权限打开：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SC_HANDLE scm;</span><br><span class="line"><span class="keyword">if</span>((scm = <span class="built_in">openSCManager</span>(<span class="literal">NULL</span>,<span class="literal">NULL</span>,SC_MANAGER_ALL_ACCESS)==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;OpenSCManager Error/n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="openService"><a class="header-anchor" href="#openService">¶</a>openService</h3><p>[openService](<a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winsvc/nf-winsvc-openservicea">openServiceA 函数 (winsvc.h) - Win32 apps | Microsoft Learn</a>)</p><ol><li><p>用途<br>打开现有服务。</p></li><li><p>语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SC_HANDLE <span class="title">OpenServiceA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[in] SC_HANDLE hSCManager,</span></span></span><br><span class="line"><span class="params"><span class="function">[in] LPCSTR    lpServiceName,</span></span></span><br><span class="line"><span class="params"><span class="function">[in] DWORD     dwDesiredAccess</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>返回值<br>如果函数成功，则返回值是服务的句柄。<br>如果函数失败，则返回值为 NULL。 要获得更多的错误信息，请调用 GetLastError。<br>服务控制管理器可以设置以下错误代码。 其他函数可由服务控制管理器调用的注册表函数设置。</p><table><thead><tr><th>返回代码</th><th>描述</th></tr></thead><tbody><tr><td><strong>ERROR_ACCESS_DENIED</strong></td><td>句柄无权访问服务。</td></tr><tr><td><strong>ERROR_INVALID_HANDLE</strong></td><td>指定的句柄无效。</td></tr><tr><td><strong>ERROR_INVALID_NAME</strong></td><td>指定的服务名称无效。</td></tr><tr><td><strong>ERROR_SERVICE_DOES_NOT_EXIST</strong></td><td>指定的服务不存在。</td></tr></tbody></table></li><li><p>示例<br>以完全权限打开</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SC_HANDLE service;</span><br><span class="line"><span class="keyword">if</span>(!(service=<span class="built_in">OpenService</span>(scm,ServerName,SERVICE\_ALL\_ACCESS)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OpenService error!/n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="启动停止"><a class="header-anchor" href="#启动停止">¶</a>启动停止</h2><h3 id="startService"><a class="header-anchor" href="#startService">¶</a>startService</h3><p><a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winsvc/nf-winsvc-startservicea">startService</a></p><ol><li><p>用途<br>启动服务</p></li><li><p>语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">StartServiceA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[in]           SC_HANDLE hService,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]           DWORD     dwNumServiceArgs,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional] LPCSTR    *lpServiceArgVectors</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>返回值<br>如果该函数成功，则返回值为非零值。<br>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p></li></ol><h3 id="ControlService"><a class="header-anchor" href="#ControlService">¶</a>ControlService</h3><ol><li><p>用途<br>将控制代码发送到服务。</p></li><li><p>语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ControlService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[in]  SC_HANDLE        hService,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]  DWORD            dwControl,</span></span></span><br><span class="line"><span class="params"><span class="function">[out] LPSERVICE_STATUS lpServiceStatus</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>返回值<br>如果该函数成功，则返回值为非零值。<br>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p></li></ol><h2 id="更改启动方式"><a class="header-anchor" href="#更改启动方式">¶</a>更改启动方式</h2><h3 id="ChangeServiceConfig"><a class="header-anchor" href="#ChangeServiceConfig">¶</a>ChangeServiceConfig</h3><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-changeserviceconfiga">ChangeServiceConfig</a></p><ol><li><p>用途<br>更改服务的配置参数</p></li><li><p>语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ChangeServiceConfigA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            SC_HANDLE hService,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            DWORD     dwServiceType,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            DWORD     dwStartType,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            DWORD     dwErrorControl,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpBinaryPathName,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpLoadOrderGroup,</span></span></span><br><span class="line"><span class="params"><span class="function">[out, optional] LPDWORD   lpdwTagId,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpDependencies,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpServiceStartName,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpPassword,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpDisplayName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>返回值<br>如果该函数成功，则返回值为非零值。<br>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 平台-Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qt获取屏幕分辨率</title>
      <link href="/2023/05/22/qt%E5%BC%80%E5%8F%91/qt%E5%BC%80%E5%8F%91--4/"/>
      <url>/2023/05/22/qt%E5%BC%80%E5%8F%91/qt%E5%BC%80%E5%8F%91--4/</url>
      
        <content type="html"><![CDATA[<h2 id="qt获取屏幕分辨率"><a class="header-anchor" href="#qt获取屏幕分辨率">¶</a>qt获取屏幕分辨率</h2><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取主屏分辨率 </span></span><br><span class="line"><span class="variable">QRect</span> <span class="variable">mRect</span>； </span><br><span class="line"><span class="variable">mRect</span> = <span class="variable">QGuiApplication</span>::<span class="function"><span class="title">primaryScreen</span>()-&gt;<span class="title">geometry</span>(); </span></span><br><span class="line"><span class="function"><span class="title">qDebug</span>()&lt;&lt;<span class="string">&quot;width:&quot;</span>&lt;&lt;<span class="variable">mRect.width</span>()&lt;&lt;<span class="string">&quot;  height:&quot;</span>&lt;&lt;<span class="variable">mRect.height</span>();</span></span><br></pre></td></tr></table></figure><p>.获取多个显示器屏幕大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取多显示器,通过list存储当前主机所有显示器 </span></span><br><span class="line">QList&lt;QScreen *&gt; list_screen = QGuiApplication::<span class="built_in">screens</span>(); </span><br><span class="line"><span class="comment">// 通过循环可以遍历每个显示器 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list_screen.<span class="built_in">size</span>(); i++) </span><br><span class="line">&#123; </span><br><span class="line">    QRect rect = list_screen.<span class="built_in">at</span>(i)-&gt;<span class="built_in">geometry</span>(); </span><br><span class="line">    <span class="type">int</span> desktop_width = rect.<span class="built_in">width</span>(); </span><br><span class="line">    <span class="type">int</span> desktop_height = rect.<span class="built_in">height</span>(); </span><br><span class="line">    <span class="comment">// 打印屏幕分辨率 </span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; desktop_width &lt;&lt;desktop_height; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>error：</p><p><a href="http://libQt5WebEngineCore.so">libQt5WebEngineCore.so</a>: .dynsym local <a href="https://so.csdn.net/so/search?q=symbol&amp;spm=1001.2101.3001.7020">symbol</a> at index 3</p><p>解决：sudo ln -sf /usr/bin/x86_64-linux-gnu-ld.gold /usr/bin/ld</p>]]></content>
      
      
      <categories>
          
          <category> qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>root权限启动QtWebEngine</title>
      <link href="/2023/05/22/%E5%B9%B3%E5%8F%B0-Linux/root%E6%9D%83%E9%99%90%E5%90%AF%E5%8A%A8QtWebEngine/"/>
      <url>/2023/05/22/%E5%B9%B3%E5%8F%B0-Linux/root%E6%9D%83%E9%99%90%E5%90%AF%E5%8A%A8QtWebEngine/</url>
      
        <content type="html"><![CDATA[<p>QtWebEngine这个部件用到了chrome的插件，众所周知，chrome不允许在root权限下启动，除非加上–no-sandbox；</p><p>所以这里的解决方案也是一样，选择无沙盒启动。</p><h3 id="Qt调试"><a class="header-anchor" href="#Qt调试">¶</a>Qt调试</h3><p>对于以root权限在Qtcreator中调试含QtWebEngine的工程的情况，可以项目-&gt;运行-&gt;环境中添加一个新的变量</p><p>QTWEBENGINE_DISABLE_SANDBOX，并置其为1。</p><h3 id="脚本启动"><a class="header-anchor" href="#脚本启动">¶</a>脚本启动</h3><p>对于脚本启动则需要在脚本中添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> XDG_RUNTIME_DIR=/tmp/runtime-root</span><br><span class="line"><span class="built_in">export</span> QTWEBENGINE_DISABLE_SANDBOX=1</span><br></pre></td></tr></table></figure><h3 id="自定义宏编译"><a class="header-anchor" href="#自定义宏编译">¶</a>自定义宏编译</h3><p>题外话，在编译阶段，如果想根据宏的开关选择不同的链接库活着编译不同的代码，</p><p>可以在项目-&gt;构建-&gt;构建的步骤-&gt;qmake-&gt;额外的参数中添加’DEFINES+=XXX’(单引号不要漏掉)；</p><p>这样就可以在pro文件和工程其他文件中使用了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> XXX</span></span><br><span class="line"> ......</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> ......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 平台-Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> qtcreator </tag>
            
            <tag> QtWebEngine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux平台打包qt应用程序</title>
      <link href="/2023/05/22/%E5%B9%B3%E5%8F%B0-Linux/linux%E5%B9%B3%E5%8F%B0%E6%89%93%E5%8C%85qt%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
      <url>/2023/05/22/%E5%B9%B3%E5%8F%B0-Linux/linux%E5%B9%B3%E5%8F%B0%E6%89%93%E5%8C%85qt%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>最近在做Linux平台的Qt开发，功能基本实现之后，就要考虑应用程序的打包了。</p><h2 id="LINUX打包步骤"><a class="header-anchor" href="#LINUX打包步骤">¶</a>LINUX打包步骤</h2><h3 id="环境"><a class="header-anchor" href="#环境">¶</a>环境</h3><p>os：ubuntu 20.04</p><p>开发工具：qt5.15.2(默认安装目录/opt/Qt)</p><h3 id="linuxdeployqt打包"><a class="header-anchor" href="#linuxdeployqt打包">¶</a>linuxdeployqt打包</h3><p>linux平台打包qt可以用linuxdeployqt一键部署，不用担心会少了什么，推荐先使用这个方法！</p><ol><li><p>下载<br><a href="https://github.com/probonopd/linuxdeployqt/releases">Download linuxdeployqt</a><br>下载编译好的linuxdeployqt应用程序，我这里用的是linuxdeployqt-continuous-x86_64.AppImage，或者也可以下载源码创建linuxdeployqt docker版。</p></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x linuxdeployqt-5-x86_64.AppImage</span><br><span class="line"><span class="built_in">cp</span> linuxdeployqt-5-x86_64.AppImage /usr/local/bin/linuxdeployqt</span><br></pre></td></tr></table></figure></li><li><p>添加环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># QT_HOME是自己安装的路径</span></span><br><span class="line"><span class="built_in">export</span> QT_HOME=/opt/Qt/5.15.2/gcc_64  <span class="comment">#修改QT_HOME</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:<span class="variable">$&#123;QT_HOME&#125;</span>/lib</span><br><span class="line"><span class="built_in">export</span> QT_PLUGIN_PATH=<span class="variable">$QT_PLUGIN_PATH</span>:<span class="variable">$&#123;QT_HOME&#125;</span>/plugins</span><br><span class="line"><span class="built_in">export</span> QML2_IMPORT_PATH=<span class="variable">$QML2_IMPORT_PATH</span>:<span class="variable">$&#123;QT_HOME&#125;</span>/qml</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$&#123;QT_HOME&#125;</span>/bin</span><br></pre></td></tr></table></figure></li><li><p>打包qt程序<br>编译Release版本的目标程序，执行linuxdeployqt。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># linuxdeployqt 程序名称 -appimage -always-overwrite</span></span><br><span class="line">linuxdeployqt VPNClient_Web -appimage -always-overwrite</span><br></pre></td></tr></table></figure></li><li><p>运行打包好的程序<br>运行linuxdeployqt中生成的AppRun程序。</p></li></ol><h3 id="自制脚本打包"><a class="header-anchor" href="#自制脚本打包">¶</a>自制脚本打包</h3><p>当然linuxdeployqt可能会拷贝不全，从而导致程序运行出错。<br>比如对含有QtWebEngine的程序，使用linuxdeployqt一键打包，运行时出现缺少libsoftokn3.so库、缺少libmozsqlite3.so库等错误。<br>根本原因就是缺少了需要的nss，这时需要手动把nss目录下的所有文件拷贝到linuxdeployqt生成的lib文件夹下。<br>这时可以寄几制作打包脚本，运行脚本一键打包，不过脚本的制作需要考虑全面，可能比较复杂，可以对比两种方式实现打包。</p><h4 id="准备ldd-sh"><a class="header-anchor" href="#准备ldd-sh">¶</a><a href="http://xn--ldd-361er54a.sh">准备ldd.sh</a></h4><p><code>ldd.sh</code>：在当前目录下新建lib文件夹，拷贝目标程序的依赖库，存放到新建的lib下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 ldd.sh</span><br></pre></td></tr></table></figure><h4 id="制作打包脚本（copy-lib-sh）"><a class="header-anchor" href="#制作打包脚本（copy-lib-sh）">¶</a>制作打包脚本（copy_lib.sh）</h4><ol><li><p>变量设置</p><p>设置QT安装路径 QT_HOME=</p><p>设置目标文件夹 target_dir=</p><p>设置应用程序命 appname=</p></li><li><p>添加目标程序<br>将目标程序(mytest)、<a href="http://ldd.sh">ldd.sh</a> 和它的依赖库拷贝到目标文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> mytest <span class="variable">$target_dir</span></span><br><span class="line"><span class="built_in">cp</span> ldd.sh <span class="variable">$target_dir</span></span><br></pre></td></tr></table></figure></li><li><p>添加程序依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ldd.sh mytest</span><br></pre></td></tr></table></figure><p>会在目标文件夹下生成lib目录，存放程序的依赖库。</p></li><li><p>添加qt依赖<br>创建plugins目录，拷贝qt的platfroms文件夹到目标文件夹的plugins目录;对platforms目录下的libqxcb.so生成qt依赖库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> plugins</span><br><span class="line"><span class="built_in">cp</span> -r <span class="variable">$QT_HOME</span>/plugins/platforms  <span class="variable">$target_dir</span>/plugins</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$target_dir</span>/plugins/platforms</span><br><span class="line">./ldd.sh libqxcb.so</span><br></pre></td></tr></table></figure><p>拷贝platfroms/lib目录下的所有文件到目标文件夹的lib目录，删除lib目录和目标文件夹中的ldd.sh文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> <span class="variable">$target_dir</span>/platforms/lib/* <span class="variable">$target_dir</span>/lib</span><br><span class="line"><span class="built_in">rm</span> -r <span class="variable">$target_dir</span>/platforms/lib</span><br><span class="line"><span class="built_in">rm</span> <span class="variable">$target_dir</span>/ldd.sh</span><br></pre></td></tr></table></figure></li><li><p>添加XCB</p><p>拷贝qt的xcbglintegrations目录到目标文件夹的plugins目录；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r <span class="variable">$QT_HOME</span>/plugins/xcbglintegrations  <span class="variable">$target_dir</span>/plugins</span><br></pre></td></tr></table></figure></li><li><p>（可选）拷贝WebEngine依赖</p><p>如果项目工程里用到了QtWebEngine插件，那么为了WebEngine的正常运行，还需要拷贝其他依赖库。</p><ol><li>添加QtWebEngine程序</li></ol><p>目标文件夹下新建libexec目录，拷qt的QtWebEngineProcess程序到libexec目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>  <span class="variable">$target_dir</span></span><br><span class="line"><span class="built_in">mkdir</span> libexec</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$QT_HOME</span>/libexec/QtWebEngineProcess <span class="variable">$target_dir</span>/libexec/</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>拷贝插件<br>拷贝qt目录的bearer、imageformats、platforminputcontexts、platformthemes拷贝到目标文件夹的plugins目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r <span class="variable">$QT_HOME</span>/plugins/bearer <span class="variable">$target_dir</span>/plugins/</span><br><span class="line"><span class="built_in">cp</span> -r <span class="variable">$QT_HOME</span>/plugins/imageformats <span class="variable">$target_dir</span>/plugins/</span><br><span class="line"><span class="built_in">cp</span> -r <span class="variable">$QT_HOME</span>/plugins/platforminputcontexts <span class="variable">$target_dir</span>/plugins/</span><br><span class="line"><span class="built_in">cp</span> -r <span class="variable">$QT_HOME</span>/plugins/platformthemes <span class="variable">$target_dir</span>/plugins/</span><br></pre></td></tr></table></figure></li><li><p>拷贝资源文件<br>拷贝qt的resources目录到目标文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r <span class="variable">$QT_HOME</span>/resources <span class="variable">$target_dir</span></span><br></pre></td></tr></table></figure></li><li><p>拷贝翻译文件<br>拷贝qt的translations目录到目标文件夹；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r <span class="variable">$QT_HOME</span>/translations <span class="variable">$target_dir</span></span><br></pre></td></tr></table></figure></li><li><p>添加nss<br>拷贝系统的nss文件夹下所有文件到到目标文件夹的lib目录；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nss_path=`find /usr/ -name nss`</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$nss_path</span>/* <span class="variable">$target_dir</span>/lib</span><br></pre></td></tr></table></figure></li></ol><h4 id="制作运行脚本"><a class="header-anchor" href="#制作运行脚本">¶</a>制作运行脚本</h4><p>打包好的程序怎么执行呢？</p><p>解压压缩包，<a href="http://xn--sudomytest-cc9tv146a.sh">sudo执行mytest.sh</a>。</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./mytest.sh</span><br></pre></td></tr></table></figure><h3 id="脚本示例："><a class="header-anchor" href="#脚本示例：">¶</a>脚本示例：</h3><p>源码模板</p><ol><li><p><a href="http://ldd.sh">ldd.sh</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">LibDir=<span class="variable">$PWD</span><span class="string">&quot;/lib&quot;</span></span><br><span class="line">Target=<span class="variable">$1</span></span><br><span class="line">lib_array=($(ldd <span class="variable">$Target</span> | grep -o <span class="string">&quot;/.*&quot;</span> | grep -o <span class="string">&quot;/.*/[^[:space:]]*&quot;</span>))</span><br><span class="line">$(<span class="built_in">mkdir</span> <span class="variable">$LibDir</span>)</span><br><span class="line"><span class="keyword">for</span> Variable <span class="keyword">in</span> <span class="variable">$&#123;lib_array[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">cp</span> <span class="string">&quot;<span class="variable">$Variable</span>&quot;</span> <span class="variable">$LibDir</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p><a href="http://xn--mytest-2g4m562owsnywr.sh">运行脚本mytest.sh</a>(与可执行程序同名)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">appname=`<span class="built_in">basename</span> <span class="variable">$0</span> | sed s,\.sh$,,`</span><br><span class="line"><span class="built_in">dirname</span>=`<span class="built_in">dirname</span> <span class="variable">$0</span>`</span><br><span class="line">tmp=<span class="string">&quot;<span class="variable">$&#123;dirname#?&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;dirname%$tmp&#125;</span>&quot;</span> != <span class="string">&quot;/&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">dirname</span>=<span class="variable">$PWD</span>/<span class="variable">$dirname</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">LD_LIBRARY_PATH=<span class="variable">$dirname</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH</span><br><span class="line"><span class="variable">$dirname</span>/<span class="variable">$appname</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span> </span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 平台-Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
            <tag> linuxdeployqt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用U盘重装Win10系统</title>
      <link href="/2023/05/12/%E5%B9%B3%E5%8F%B0-Windows/%E4%BD%BF%E7%94%A8U%E7%9B%98%E9%87%8D%E8%A3%85Win10%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/05/12/%E5%B9%B3%E5%8F%B0-Windows/%E4%BD%BF%E7%94%A8U%E7%9B%98%E9%87%8D%E8%A3%85Win10%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="工具准备"><a class="header-anchor" href="#工具准备">¶</a>工具准备</h2><ol><li>U盘<br>准备一个8G以上的空白U盘<br>注意：<strong>制作系统重装工具会格式化U盘，需要做好U盘文件备份</strong></li><li>Windows下载工具<br><a href="https://www.microsoft.com/zh-cn/software-download/windows10">官方下载连接</a></li></ol><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-12-10-08-55-image.png" alt></p><h2 id="制作安装U盘"><a class="header-anchor" href="#制作安装U盘">¶</a>制作安装U盘</h2><ol><li><p>双击下载的文件</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-12-10-10-24-image.png" alt></p></li><li><p>同意所有不平等条约</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-12-10-11-46-image.png" alt></p></li><li><p>选择为另一台电脑创建安装介质</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-12-10-12-38-image.png" alt></p></li><li><p>取消勾选“对这台电脑使用推荐的选项”，如果是DIY主机，建议选择“专业版”；否则选择家庭版，可以免去激活过程。</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-12-10-14-01-image.png" alt></p></li><li><p>选择使用的介质</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-12-10-17-25-image.png" alt></p></li><li><p>选择U盘</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-12-10-18-11-image.png" alt></p><p><strong>制作系统重装工具会格式化U盘，需要做好U盘文件备份</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 平台-Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> U盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux捕获程序崩溃异常——qbreakpad</title>
      <link href="/2023/05/08/%E5%B9%B3%E5%8F%B0-Linux/Linux%E6%8D%95%E8%8E%B7%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E5%BC%82%E5%B8%B8/"/>
      <url>/2023/05/08/%E5%B9%B3%E5%8F%B0-Linux/Linux%E6%8D%95%E8%8E%B7%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>在进行Linux平台的qt程序开发时，出现程序崩溃退出的情况，而且没有什么信息(ˉ▽ˉ；)…。</p><p>bing了一下发现一个可以定位崩溃位置的工具qbreakpad，这里记录一下qbreakpad的安装过程。</p><h1>qbreakpad的安装过程</h1><h2 id="源码准备"><a class="header-anchor" href="#源码准备">¶</a>源码准备</h2><h3 id="下载Breakpad源码"><a class="header-anchor" href="#下载Breakpad源码">¶</a>下载Breakpad源码</h3><p><a href="https://github.com/google/breakpad">下载地址</a></p><p>建议选择tags=<strong>v2021.08.09</strong></p><h3 id="下载LSS源码"><a class="header-anchor" href="#下载LSS源码">¶</a>下载LSS源码</h3><p><a href="https://github.com/ithaibo/linux-syscall-support">下载地址</a></p><p>需要注意，如果您的gcc版本高于9.0，在构建breakpad时可能会报错：</p><p><code>linux\_syscall\_support.h: error: listing the stack pointer register 'rsp' in a clobber list is deprecated</code></p><p>解决：更换修正版lss</p><p><a href="https://chromium.googlesource.com/linux-syscall-support/+/8048ece6c16c91acfe0d36d1d3cc0890ab6e945c">下载地址</a></p><h3 id="下载qBreakpad源码"><a class="header-anchor" href="#下载qBreakpad源码">¶</a>下载qBreakpad源码</h3><p><a href="https://github.com/buzzySmile/qBreakpad">下载地址</a></p><h2 id="编译qBreakpad"><a class="header-anchor" href="#编译qBreakpad">¶</a>编译qBreakpad</h2><p>下载qBreakpad源码，在<code>qBreakpad/third_party</code>目录下，把下载好的LSS源码和Breakpad源码放入其中；修改文件夹名为lss和breakpad;</p><p><a href="http://xn--qtcreatorqBreakpad-ci98aj42blj7g.pro">用qtcreator打开qBreakpad.pro</a>，直接构建；</p><p>构建成功后，会在<code>qBreakpad/handler</code> 目录下生成<code>libqBreakpad.a</code>文件，保存目录下的头文件<code>QBreakpadHandler.h、QBreakpadHttpUploader.h、singletone/call_once.h、singletone/singleton.h</code>。</p><h2 id="调用qBreakpad"><a class="header-anchor" href="#调用qBreakpad">¶</a>调用qBreakpad</h2><p>在自己的qt工程(qbreakpadTest)下新建qBreakpad目录，将<code>libqBreakpad.a</code>拷贝至，<code>qBreakpad\lib\</code>目录下；</p><p>将调用库所需的头文件<code>QBreakpadHandler.h、QBreakpadHttpUploader.h、call_once.h、singleton.h</code>共4个文件拷贝至<code>qBreakpad\include</code>下。</p><p>在qbreakTest.pro下增加以下内容：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############ for qBreakpad ############</span></span><br><span class="line"><span class="comment"># qBreakpad中需要使用到network模块</span></span><br><span class="line"><span class="attr">QT</span> <span class="string">+= network</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 启用多线程、异常、RTTI、STL支持</span></span><br><span class="line"><span class="attr">CONFIG</span> <span class="string">+= thread exceptions rtti stl</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># without c++11 &amp; AppKit library compiler can&#x27;t solve address for symbols</span></span><br><span class="line"><span class="attr">CONFIG</span> <span class="string">+= c++11</span></span><br><span class="line"><span class="attr">macx</span>: <span class="string">LIBS += -framework AppKit</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 配置头文件搜索路径和链接库路径</span></span><br><span class="line"><span class="attr">unix</span>:<span class="string">!macx: LIBS += -L$$PWD/qBreakpad/lib/ -lqBreakpad</span></span><br><span class="line"></span><br><span class="line"><span class="attr">INCLUDEPATH</span> <span class="string">+= $$PWD/qBreakpad/include</span></span><br><span class="line"><span class="attr">DEPENDPATH</span> <span class="string">+= $$PWD/qBreakpad/include</span></span><br><span class="line"></span><br><span class="line"><span class="attr">unix</span>:<span class="string">!macx: PRE_TARGETDEPS += $$PWD/qBreakpad/lib/libqBreakpad.a</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">############ for qBreakpad ############</span></span><br></pre></td></tr></table></figure><p>在main.cpp中添加</p><p><code> QBreakpadInstance.setDumpPath(&quot;crashes&quot;); // 设置生成dump文件路径</code></p><p>崩溃示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">qBreakpadTest::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QLabel * label = <span class="literal">nullptr</span>;</span><br><span class="line">    label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;crash&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译，运行程序，生成的<code>dump</code>文件存放在<code>Debug/crashes</code>目录下。</p><h2 id="编译breakpad"><a class="header-anchor" href="#编译breakpad">¶</a>编译breakpad</h2><p><code>Breakpad</code>提供了两个工具<code>dump_syms</code>和<code>minidump_stackwalk</code>，用于分析<code>dump</code>，定位<code>bug</code>。</p><p>下载<code>Breakpad</code>源码，将<code>LSS(linux-syscall-support)</code>源码拷贝至<code>breakpad\src\third_party</code>目录下，并重命名为lss；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> breakpad</span><br><span class="line"><span class="built_in">chmod</span> 755 configure</span><br><span class="line">./configure</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>编译完成后，在<code>breakpad/src/tools/linux/dump_syms</code>目录下，生成了<code>dump_syms</code>；</p><p>在<code>breakpad/src/processor</code>目录下，生成了<code>minidump_stackwalk</code>。</p><h2 id="使用dump-syms和minidump-stackwalk定位bug"><a class="header-anchor" href="#使用dump-syms和minidump-stackwalk定位bug">¶</a>使用dump_syms和minidump_stackwalk定位bug</h2><h3 id="1、生成符号文件"><a class="header-anchor" href="#1、生成符号文件">¶</a>1、生成符号文件</h3><p>使用<code>dump_syms</code>读取带调试信息的程序文件，并生成符号文件<code>qBreakpadTest.sym</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump_syms ./qBreakpadTest &gt; qBreakpadTest.sym</span><br></pre></td></tr></table></figure><h3 id="2、将符号文件移动到特定路径"><a class="header-anchor" href="#2、将符号文件移动到特定路径">¶</a>2、将符号文件移动到特定路径</h3><p>在自己的qt工程(qBreakpadTest)所在目录下，创建目录结构：</p><ul><li>第一级目录，固定为<code>symbols</code>；</li><li>第二级目录，为即将放入的<code>符号文件名称</code>，如<code>qBreakpadTest.sym</code>，则目录名为<code>qBreakpadTest</code>；</li><li>第三级目录，在sym文件中第一行内容，有一串<code>16进制</code>编号，将其作为<code>目录名</code>。</li></ul><p>建立好以上路径后，将<code>qBreakpadTest.sym</code>移动到此路径下。</p><h3 id="3、生成崩溃处调用堆栈信息"><a class="header-anchor" href="#3、生成崩溃处调用堆栈信息">¶</a>3、生成崩溃处调用堆栈信息</h3><p>将<code>crashes目录</code>拷贝到和<code>symbols目录</code>一个级别目录下；</p><p>然后执行如下命令，生成调用堆栈信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minidump_stackwalk ./crashes/7211c8b8-126d-4de2-7f8f00a4-db86eecc.dmp ./symbols &gt; error.log</span><br></pre></td></tr></table></figure><p>第一个参数，是dump文件名；<br>第二个参数，固定为./symbols，应该是指定符号文件位于当前symbols目录下默认路径位置；<br>第三个参数，将命令执行结果，写入到error.log文件中。</p><p>查看生成的堆栈调用信息文件<code>error.log</code>，找到<code>“crashed”</code>字样，与它最近的一行，就是发生崩溃时，程序的调用堆栈。</p><h3 id="4、dump文件上报"><a class="header-anchor" href="#4、dump文件上报">¶</a>4、dump文件上报</h3><p>将生成的<code>dump</code>文件上传到指定的服务器。</p><ul><li>先通过setDumpPath设置dump文件生成目录；以便在发生崩溃时，自动在该目录下生成dump文件。</li><li>再通过setUploadUrl设置上报地址，以便后续将dump文件，上传到该地址。</li><li>最后，通过sendDumps将dump文件发送至服务器。该函数会自动遍历，前面设置的dump生成目录，将每一个dump文件进行发送。</li></ul><p>上报演示程序，位于<code>qBreakpad\demo\reporter</code>下。</p>]]></content>
      
      
      <categories>
          
          <category> 平台-Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> qBreakpad </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>u盘格式错误</title>
      <link href="/2023/05/05/%E5%B9%B3%E5%8F%B0-Windows/u%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%98%E4%B8%BARAW/"/>
      <url>/2023/05/05/%E5%B9%B3%E5%8F%B0-Windows/u%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%98%E4%B8%BARAW/</url>
      
        <content type="html"><![CDATA[<p>好久没有用的u盘，今天插了试了一下，发现U盘无法被读取，于是开始排查原因；</p><p>首先检查驱动，计算机-&gt;管理-&gt;设备管理器查看驱动，驱动没有问题；</p><p>检查磁盘分区，win+R，输入diskmgmt.msc，找到出错的u盘，发现文件系统为RAW？？(ˉ▽ˉ；)…</p><p><code>RAW格式(未格式化)磁盘代表文档系统已损坏，导致系统无法识别是FAT、NTFS、EXT2或EXT3…等格式。在这种情况下，您无法存取这台磁盘且无法使用磁盘中的文档。引发这种问题的原因有很多种，可能是因为感染病毒、，格式化失败、意外关机、停电…等原因所造成的。</code></p><p><code>如果一块磁盘在Windows中显示为RAW格式硬盘，可能（但非全部）的症状是：</code></p><p><code>无效的磁盘媒体格式。中止，重试，失败？ </code></p><p><code>文档系统显示为「RAW」— RAW文档系统 </code></p><p><code>Windows可能会提示是否要格式化磁盘，比如「硬盘未格式化，是否要立即格式化？」 </code></p><p><code>文件名称包含奇怪的字符。 </code></p><p><code>「找不到磁区」讯息</code></p><p>所以需要把U盘格式化为NTFS，方法：</p><p><strong>使用chkdsk命令</strong></p><p>我这里用这个命令就搞好了，</p><p>打开win+R-&gt;cmd，输入chkdsk G:(损坏U盘)/f /r /x</p><p>是否将丢失的链转换为文件(Y/N)? N</p><p>如果这个命令不好使，显示<code>文件系统的类型是RAW，CHKDSK无法供RAW驱动器使用</code>，那就参考一下文章——<a href="https://zhuanlan.zhihu.com/p/393142509">文件系统的类型是RAW，CHKDSK无法供RAW驱动器使用 - 知乎 (zhihu.com)</a> 叭</p>]]></content>
      
      
      <categories>
          
          <category> 平台-Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> U盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(Linux平台)qtcreator的安装与常见问题</title>
      <link href="/2023/05/04/%E5%B9%B3%E5%8F%B0-Linux/(Linux)qtcreator%E5%AE%89%E8%A3%85%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2023/05/04/%E5%B9%B3%E5%8F%B0-Linux/(Linux)qtcreator%E5%AE%89%E8%A3%85%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="qtcreator安装"><a class="header-anchor" href="#qtcreator安装">¶</a>qtcreator安装</h2><p>环境：ubuntu2004</p><p>准备：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure><h3 id="apt-get安装"><a class="header-anchor" href="#apt-get安装">¶</a>apt-get安装</h3><p><a href="https://blog.csdn.net/weixin_48560325/article/details/124373125">参考文章</a></p><p>apt安装会直接安装固定版本的qtcreator</p><h3 id="在线安装"><a class="header-anchor" href="#在线安装">¶</a>在线安装</h3><ol><li><p>下载在线安装器<br><a href="https://www.qt.io/download-qt-installer">Download Qt: Get Qt Online Installer</a></p></li><li><p>双击在线安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> a+x qt-unified-linux-x64-4.5.2-online.run</span><br><span class="line">./qt-unified-linux-x64-4.5.2-online.run</span><br></pre></td></tr></table></figure><p>没有账户的话需要注册</p><p>安装目录(/opt/Qt)</p></li><li><p>创建快捷方式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /opt/Qt/Tools/QtCreator/bin/qtcreator /usr/bin/qtcreator</span><br></pre></td></tr></table></figure></li><li><p>创建桌面文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /opt/Qt/Tools/QtCreator/share/applications/org.qt-project.qtcreator.desktop /usr/share/applications/org.qt-project.qtcreator.desktop</span><br></pre></td></tr></table></figure></li><li><p>配置构建套件</p><p>配置Qt版本</p><p>自动检测-&gt;qmake在/opt/Qt/5.15.2/gcc_64/bin下</p><p>配置编译器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install gcc</span><br><span class="line">apt install g++</span><br></pre></td></tr></table></figure></li><li><p>修改qmake默认编译器</p><p>到这一步qtcreator的使用基本没什么问题了，但是在命令行输入qmake -v，发现qmake报错</p><p><code>could not exec '/usr/lib/x86\_64-linux-gnu/qt4/bin/qmake': No such file or directory</code></p><p>需要修改qmake默认编译器:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/lib/x86_64-linux-gnu/qt-default/qtchooser/default.conf</span><br></pre></td></tr></table></figure><p>在第一行添加qmake位置<code>/opt/Qt/5.15.2/gcc_64/bin</code></p></li></ol><h3 id="国内源在线安装"><a class="header-anchor" href="#国内源在线安装">¶</a>国内源在线安装</h3><p>如果虚拟机在线安装qt十分缓慢（长达2-3小时），可以试试换国内源（约半小时-40分钟），或者挂个梯子。</p><p><a href="https://zhuanlan.zhihu.com/p/597695401#:~:text=Linux%E5%AE%89%E8%A3%85Qt6%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%EF%BC%88%E4%BB%A5Ubuntu22.04%E4%B8%BA%E4%BE%8B%EF%BC%89%201%201.%20%E4%B8%8B%E8%BD%BD%E6%B8%85%E5%8D%8E%E6%8F%90%E4%BE%9B%E7%9A%84%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85%E5%99%A8%20%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85%E5%99%A8%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5%202%202.%20%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E5%9C%B0%E5%9D%80%E8%BF%90%E8%A1%8C%E5%AE%89%E8%A3%85%E5%99%A8,CMake%20configuration%20found%21%20sudo%20apt%20install%20libgl-dev%20">参考文章</a></p><ol><li><p>下载清华在线安装器<br><a href="https://link.zhihu.com/?target=https%3A//mirrors.tuna.tsinghua.edu.cn/qt/official_releases/online_installers/qt-unified-linux-x64-online.run">Download Qt: Get Tuna Qt Online Installer</a></p></li><li><p>配置镜像地址运行在线安装器</p><ul><li>清华源</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./qt-unified-linux-x64-online.run --mirror https://mirrors.tuna.tsinghua.edu.cn/qt</span><br></pre></td></tr></table></figure><ul><li>南大源</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./qt-unified-linux-x64-online.run --mirror http://mirrors.nju.edu.cn/qt/</span><br></pre></td></tr></table></figure></li><li><p>继续上面的步骤安装qt</p></li></ol><h2 id="qt开发中出现的错误"><a class="header-anchor" href="#qt开发中出现的错误">¶</a>qt开发中出现的错误</h2><h3 id="qt安装错报错："><a class="header-anchor" href="#qt安装错报错：">¶</a>qt安装错报错：</h3><p><code>./qt-unified-linux-x64-4.5.2-online.run: error while loading shared libraries: libxcb-xinerama.so.0: cannot open shared object file: No such file or directory</code></p><p>解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install --reinstall libxcb-xinerama0</span><br></pre></td></tr></table></figure><h3 id="配置文件报错"><a class="header-anchor" href="#配置文件报错">¶</a>配置文件报错</h3><p><code>No CMake configuration found!</code></p><p>解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libgl-dev</span><br></pre></td></tr></table></figure><h3 id="pro文件报错：GL"><a class="header-anchor" href="#pro文件报错：GL">¶</a>pro文件报错：GL</h3><p><code>/opt/Qt/5.15.2/gcc_64/include/QtGui/qopengl.h:141:13: fatal error: GL/gl.h: No such file or directory 141 | # include &lt;GL/gl.h&gt; | ^~~~~~~~~</code></p><p>解决：</p><p>安装缺少的插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mesa-common-dev`</span><br></pre></td></tr></table></figure><h3 id="使用WebEngine编译报错：libQt5WebEngineCore-so"><a class="header-anchor" href="#使用WebEngine编译报错：libQt5WebEngineCore-so">¶</a>使用WebEngine编译报错：<a href="http://libQt5WebEngineCore.so">libQt5WebEngineCore.so</a></h3><p><code>libQt5WebEngineCore.so: .dynsym local symbol at index 3 (&gt;= sh_info of 3)</code></p><p>解决：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -sf <span class="regexp">/usr/</span>bin<span class="regexp">/x86_64-linux-gnu-ld.gold /u</span>sr<span class="regexp">/bin/</span>ld</span><br></pre></td></tr></table></figure><h3 id="Qt运行出现-Ignoring-XDG-SESSION-TYPE-wayland-on-Gnome-Use-QT-QPA-PLATFORM-wayland-to-run…解决"><a class="header-anchor" href="#Qt运行出现-Ignoring-XDG-SESSION-TYPE-wayland-on-Gnome-Use-QT-QPA-PLATFORM-wayland-to-run…解决">¶</a>Qt运行出现 Ignoring XDG_SESSION_TYPE=wayland on Gnome. Use QT_QPA_PLATFORM=wayland to run…解决</h3><p>解决：</p><p>vim /etc/gdm3/custom.conf</p><p>WaylandEnable=false</p><p>reboot</p>]]></content>
      
      
      <categories>
          
          <category> 平台-Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> qtcreator </tag>
            
            <tag> QtWebEngine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vector</title>
      <link href="/2023/04/24/tips%E6%95%B4%E7%90%86/C++%20vector%20%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/04/24/tips%E6%95%B4%E7%90%86/C++%20vector%20%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>Vector（C++）</h1><p>Vector是一个封装了<strong>动态</strong>大小数组的<strong>顺序</strong>*容器，即一个可以存放任意类型的动态数组。</p><h2 id="容器特性"><a class="header-anchor" href="#容器特性">¶</a>容器特性</h2><h3 id="顺序存储"><a class="header-anchor" href="#顺序存储">¶</a>顺序存储</h3><p>顺序容器中的元素线性排列，通过元素在序列中的位置访问元素。</p><h3 id="动态数组"><a class="header-anchor" href="#动态数组">¶</a>动态数组</h3><p>支持对序列中的元素进行快速访问，在序列末尾快速增删元素。</p><h3 id="感知内存分配器的Alloctor-aware"><a class="header-anchor" href="#感知内存分配器的Alloctor-aware">¶</a>感知内存分配器的Alloctor-aware</h3><p><strong>内存分配器（Memory Alloctor）</strong></p><p>通常使用的内存分配器,即malloc/free函数并非系统提供的，而是C标准库提供的。也被称为动态内存分配器。</p><p><em><code>目的</code></em>：平衡内存分配的性能和提高内存使用的效率。</p><p><em><code>内存不足的原因</code></em>：程序内的bug；系统内存不足；内存分配浪费大量空间，导致大量内存碎片。</p><p><strong>Alloctor Aware Container</strong></p><p>所有的STL容器，都保存一个或默认，或由用户提供的allocator的实例，用来提供对象内存分配和构造的方法（除了std::array），这样的容器，被称作Allocator Aware Container。</p><p>Allocator Aware Container的拷贝：</p><p>调用被拷贝对象的std::allocator_traits<TAllocator>::select_on_container_copy_construction()函数，按情况拷贝，如果没有，就直接返回容器本体。</TAllocator></p><p>拷贝对象调用静态的propagate_on_container_copy_assignment，获取被拷贝容器的allocator副本，避免出现直接拷贝容器的bug。</p><p>每一个std::allocator_traits<Tallocator>都拥有三个别名类型：propagate_on_container_copy_assignment， propagate_on_container_move_assignment 和 propagate_on_container_swap，他们都是true_type或false_type的别名，这三个属性除非用户自定义，否则默认是false_type，也即allocator在容器拷贝、移动或交换的时候不能直接进行allocator所分配的内存的所有权的转移<br>对于拷贝赋值（copy assignment），需要运行时判断容器的propagate_on_copy_assignement trait，如果为true，并且两个容器不相等，那么lhs的容器应该先析构所有内存，再拷贝allocator，最后执行对象的拷贝。</Tallocator></p><p>容器在移动赋值（move assignment）的时候需要考虑如下情况，来正确操作容器的allocator:</p><ul><li>propagate_on_container_move_assignemnt 为 true_type<br>lhs拷贝容器使用alloctor释放分配内存，rhs被拷贝者alloctor所有权转移，内存的所有权从rhs转移到lhs。</li><li>propagate_on_container_move_assignemnt 为 false_type，但两个allocator相等<br>lhs拷贝容器使用alloctor释放分配内存，不交换所有权。</li><li>propagete_on_container_move_assignment 为 false_type，两个allocator<br>不等无法执行内存级别的移动，只能进行对象级别的移动。</li></ul><h2 id="函数实现"><a class="header-anchor" href="#函数实现">¶</a>函数实现</h2><h3 id="构造函数"><a class="header-anchor" href="#构造函数">¶</a>构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>() <span class="comment">//创建一个空vector</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">int</span> nSize) <span class="comment">//创建一个vector,元素个数为nSize</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">int</span> nSize,<span class="type">const</span> t&amp; t) <span class="comment">//创建一个vector，元素个数为nSize,且值均为t</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&amp;) <span class="comment">//复制构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(begin,end) <span class="comment">//复制[begin,end)区间内另一个数组的元素到vector中</span></span><br></pre></td></tr></table></figure><h3 id="增加函数"><a class="header-anchor" href="#增加函数">¶</a>增加函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="comment">//向量尾部增加一个元素X</span></span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it,<span class="type">const</span> T&amp; x)</span> <span class="comment">//向量中迭代器指向元素前增加一个元素x</span></span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it,<span class="type">int</span> n,<span class="type">const</span> T&amp; x)</span> <span class="comment">//向量中迭代器指向元素前增加n个相同的元素x</span></span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it,const_iterator first,const_iterator last)</span> <span class="comment">//向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</span></span></span><br></pre></td></tr></table></figure><h3 id="删除函数"><a class="header-anchor" href="#删除函数">¶</a>删除函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span> <span class="comment">//删除向量中迭代器指向元素</span></span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first,iterator last)</span> <span class="comment">//删除向量中[first,last)中元素</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> <span class="comment">//删除向量中最后一个元素</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> <span class="comment">//清空向量中所有元素</span></span></span><br></pre></td></tr></table></figure><h3 id="遍历函数"><a class="header-anchor" href="#遍历函数">¶</a>遍历函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">reference <span class="title">at</span><span class="params">(<span class="type">int</span> pos)</span> <span class="comment">//返回pos位置元素的引用</span></span></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> <span class="comment">//返回首元素的引用</span></span></span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> <span class="comment">//返回尾元素的引用</span></span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="comment">//返回向量头指针，指向第一个元素</span></span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="comment">//返回向量尾指针，指向向量最后一个元素的下一个位置</span></span></span><br><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="comment">//反向迭代器，指向最后一个元素</span></span></span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="comment">//反向迭代器，指向第一个元素之前的位置</span></span></span><br></pre></td></tr></table></figure><h3 id="判空"><a class="header-anchor" href="#判空">¶</a>判空</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//判断向量是否为空，若为空，则向量中无元素</span></span></span><br></pre></td></tr></table></figure><h3 id="大小函数"><a class="header-anchor" href="#大小函数">¶</a>大小函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//返回向量中元素的个数</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//返回当前向量所能容纳的最大元素值</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> max\_<span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//返回最大可允许的vector元素数量值</span></span></span><br></pre></td></tr></table></figure><h3 id="7-其他函数"><a class="header-anchor" href="#7-其他函数">¶</a>7.其他函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&amp;)</span> <span class="comment">//交换两个同类型向量的数据</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">int</span> n,<span class="type">const</span> T&amp; x)</span> <span class="comment">//设置向量中前n个元素的值为x</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">const</span>\_iterator first,<span class="type">const</span>\_iterator last)</span> <span class="comment">//向量中[first,last)中元素设置成当前向量元素</span></span></span><br></pre></td></tr></table></figure><h2 id="使用"><a class="header-anchor" href="#使用">¶</a>使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt; vector&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><ol><li>Vector&lt;类型&gt;标识符</li><li>Vector&lt;类型&gt;标识符(最大容量)</li><li>Vector&lt;类型&gt;标识符(最大容量,初始所有值)</li><li>Int i[5]={1,2,3,4,5}<br>Vector&lt;类型&gt;vi(I,i+2);//得到i索引值为3以后的值</li><li>Vector&lt; vector&lt; int&gt; &gt;v;</li></ol>]]></content>
      
      
      <categories>
          
          <category> tips整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> Vector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware错误</title>
      <link href="/2023/04/23/tips%E6%95%B4%E7%90%86/VMware%E9%94%99%E8%AF%AF/"/>
      <url>/2023/04/23/tips%E6%95%B4%E7%90%86/VMware%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<p>记录一下在使用VMware workstation的过程中出现的问题。</p><h2 id="虚拟机正在使用"><a class="header-anchor" href="#虚拟机正在使用">¶</a>虚拟机正在使用</h2><p>VMware虚拟机由于一些原因卡死，用Windows任务管理器关闭VMware也关不掉，然后重启电脑，再次打开虚拟机报错。</p><p>错误信息：</p><p><code>该虚拟机似乎正在使用中。如果该虚拟机未在使用，请按“获取所有权(T)”按钮获取它的所有权。否则，请按“取消(C)”按钮以防损坏。</code></p><p>解决方法：</p><p>打开虚拟机所在文件夹，删除.lck结尾的文件夹(不放心的话可以转为备份文件)；重启VMware，即可打开虚拟机;</p><p>分析原因：</p><p>当运行一个“虚拟系统”时，为防止该系统被另外一个VMware程序打开，导致数据被修改或损坏，VMware会自动在该“虚拟系统”所在的文件夹下，生成三个锁定文件（虚拟系统锁定，虚拟磁盘锁定，虚拟内存锁定），分别为：”.vmx.lck”,”.vmdk.lck”,”.vmem.lck”；</p><p>在正常关机的情况下，这些文件会自动删除，当非正常关机的情况下，这些文件就不会自动删除，这就导致了再次打开Ubuntu的时候由于锁的存在而打不开。</p><h2 id="未能连接到虚拟机"><a class="header-anchor" href="#未能连接到虚拟机">¶</a>未能连接到虚拟机</h2><p>强制关闭虚拟机，再次打开时报错。</p><p>错误信息：</p><p><code>未能将管道连接到虚拟机: 所有的管道范例都在使用中。</code></p><p>解决方法：</p><p>打开任务管理器-&gt;详细信息：结束所有vm开头的任务(vmnet不用关);</p><p>分析原因：</p><p>有些相关进程没有关掉，导致管道未释放。</p><h2 id="网络连接失败"><a class="header-anchor" href="#网络连接失败">¶</a>网络连接失败</h2><p>在任务管理器中不小心关掉了vmnat.ext,vmnetdhcp.exe等VMware虚拟网络进程，导致虚拟机网络连接失败。</p><p>解决方法：</p><p>关闭虚拟机，编辑-&gt;虚拟网络编辑器-&gt;还原默认设置;</p>]]></content>
      
      
      <categories>
          
          <category> tips整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode通过SSH远程连接主机失败</title>
      <link href="/2023/04/23/tips%E6%95%B4%E7%90%86/VScode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5/"/>
      <url>/2023/04/23/tips%E6%95%B4%E7%90%86/VScode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<p>报错信息：</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-16-14-14-42-image.png" alt></p><p>原因：</p><p>我这里是之前安装过一个ubuntu2204，VMware分配了ip，并且使用ssh连接过这个ip。删除虚拟机后，再次安装的ubuntu又恰好被分配了此ip，但用户名或密码与之前不同。这使得本地记录的信息和现有本地记录的服务器信息和现有的产生了冲突，连接失败。</p><p>解决：</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-16-14-19-26-image.png" alt></p><p>把有冲突的本地记录删掉就好了，找到C:\Users\Administrator\ssh\known_hosts文件，删除冲突ip的信息。然后重新连接。</p>]]></content>
      
      
      <categories>
          
          <category> tips整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vs Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中发送UDP数据包</title>
      <link href="/2023/04/23/%E5%B9%B3%E5%8F%B0-android/%E5%8F%91%E9%80%81UDP%E6%95%B0%E6%8D%AE%E5%8C%85(java)/"/>
      <url>/2023/04/23/%E5%B9%B3%E5%8F%B0-android/%E5%8F%91%E9%80%81UDP%E6%95%B0%E6%8D%AE%E5%8C%85(java)/</url>
      
        <content type="html"><![CDATA[<h2 id="UDP发送数据"><a class="header-anchor" href="#UDP发送数据">¶</a>UDP发送数据</h2><h3 id="步骤"><a class="header-anchor" href="#步骤">¶</a>步骤</h3><ol><li>创建发送端socket对象</li><li>创建数据并打包</li><li>调用socket发送方法发送数据包</li><li>释放资源</li></ol><h3 id="方法"><a class="header-anchor" href="#方法">¶</a>方法</h3><p><strong>类 DatagramSocket</strong></p><p>此类表示用来<strong>发送和接收数据报包</strong>的套接字</p><p><strong>类 DatagramPacket</strong></p><p>此类表示数据报包</p><p>public void <strong>send</strong>(DatagramPacket p)：</p><p>从套接字发送数据报包。DatagramPacket 包含的信息指示：将要发送的数据、其长度、远程主机的 IP 地址和远程主机的端口号。</p><p>public <strong>DatagramPacket</strong>(byte[] buf,int length,InetAddress address,int port)</p><p>构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。</p><h3 id="步骤-v2"><a class="header-anchor" href="#步骤-v2">¶</a>步骤</h3><ol><li>创建socket对象</li><li>创建数据包（接受容器）</li><li>调用socket接受方法接受数据包</li><li>解析数据</li><li>释放资源</li></ol><h3 id="方法-v2"><a class="header-anchor" href="#方法-v2">¶</a>方法</h3><p>public <strong>DatagramSocket</strong>(int port)</p><p>创建数据报套接字并绑定到指定端口</p><p><strong>DatagramPacket</strong>(byte[] buf, int length)</p><p>构造长度为length的数据包</p><p>public void <strong>receive</strong>(DatagramPacket p)</p><p>从套接字接受数据包</p><p>public InetAddress <strong>getAddress</strong>()</p><p>返回某台机器的 IP地址，此数据报将要发往该机器或者是从该机器接收到的。</p><p>public byte[] <strong>getData</strong>()</p><p>返回数据缓冲区。</p><p>public int <strong>getLength()</strong></p><p>返回将要发送或接收到的数据的长度。</p>]]></content>
      
      
      <categories>
          
          <category> 平台-android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> java </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gmssl各平台编译</title>
      <link href="/2023/04/21/%E5%9B%BD%E5%AF%86/gmssl%E5%90%84%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"/>
      <url>/2023/04/21/%E5%9B%BD%E5%AF%86/gmssl%E5%90%84%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1>gmssl各平台编译</h1><p>官址<a href>click here</a></p><p>我的项目<a href="https://github.com/115Jiege/Gmssl.git">click here</a></p><h2 id="linux版编译-v2"><a class="header-anchor" href="#linux版编译-v2">¶</a>linux版编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./config --prefix=/usr/local --openssldir=/usr/local</span><br><span class="line">sudo make &amp;&amp; make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><h2 id="Windows版编译"><a class="header-anchor" href="#Windows版编译">¶</a>Windows版编译</h2><p>使用</p><p>下载perl工具</p><p>[click here](<a href="https://strawberryperl.com/">Strawberry Perl for Windows</a>)</p><p>以管理员身份打开<code>x86 Native Tools Command Prompt for VS 2019</code> cd gmssl目录 运行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">perl Configure VC-WIN32</span><br><span class="line">nmake </span><br><span class="line">nmake install</span><br></pre></td></tr></table></figure><h2 id="安卓版编译-v2"><a class="header-anchor" href="#安卓版编译-v2">¶</a>安卓版编译</h2><h3 id="编译环境"><a class="header-anchor" href="#编译环境">¶</a>编译环境</h3><p>os: mint 20.1</p><p>(5.4.0-58-generic #64-Ubuntu SMP Wed Dec 9 08:16:25 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux)</p><p>NDK: android-r14b</p><p>Android-abi: android-21</p><h3 id="初步准备"><a class="header-anchor" href="#初步准备">¶</a>初步准备</h3><h4 id="NDK"><a class="header-anchor" href="#NDK">¶</a>NDK</h4><p>选用android-ndk-r14b，可以在<a href="https://www.androiddevtools.cn/">此处</a>下载合适版本;</p><h4 id="环境变量"><a class="header-anchor" href="#环境变量">¶</a>环境变量</h4><p>将android-ndk-r14b所在位置添加到系统环境变量中;</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vim <span class="regexp">/etc/</span>profile</span><br><span class="line"><span class="comment">#编辑文件</span></span><br><span class="line">export ANROID_NDK_PATH=<span class="regexp">/usr/</span>local/android-ndk-r14b</span><br><span class="line"><span class="comment">#:wq保存</span></span><br><span class="line">source <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure><h3 id="编译合适版本"><a class="header-anchor" href="#编译合适版本">¶</a>编译合适版本</h3><p>编写sh文件，在linux系统上使用ndk进行交叉编译</p><h4 id="x86"><a class="header-anchor" href="#x86">¶</a>x86</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">ANDROID_PATH</span>=<span class="variable">$ANDROID_NDK_PATH</span></span><br><span class="line"><span class="attribute">PLATFORM_VERSION</span>=21</span><br><span class="line"></span><br><span class="line"><span class="attribute">MAKE_TOOLCHAIN</span>=<span class="variable">$ANDROID_PATH</span>/build/tools/make-standalone-toolchain.sh</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOLCHAIN_PATH</span>=<span class="variable">$ANDROID_PATH</span>/x86</span><br><span class="line"><span class="variable">$MAKE_TOOLCHAIN</span> <span class="attribute">--arch</span>=x86 <span class="attribute">--platform</span>=android-$PLATFORM_VERSION <span class="attribute">--install-dir</span>=<span class="variable">$TOOLCHAIN_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">CROSS_SYSROOT</span>=<span class="variable">$TOOLCHAIN_PATH</span>/sysroot</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOL_BASENAME</span>=<span class="variable">$TOOLCHAIN_PATH</span>/bin</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$CROSS_SYSROOT</span>:$PATH</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$TOOL_BASENAME</span>:$PATH</span><br><span class="line"></span><br><span class="line">./Configure <span class="attribute">--prefix</span>=/usr/local <span class="attribute">--cross-compile-prefix</span>=i686-linux-android- no-asm no-async shared android-x86</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h4 id="x86-64"><a class="header-anchor" href="#x86-64">¶</a>x86_64</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">ANDROID_PATH</span>=<span class="variable">$ANDROID_NDK_PATH</span></span><br><span class="line"><span class="attribute">PLATFORM_VERSION</span>=21</span><br><span class="line"></span><br><span class="line"><span class="attribute">MAKE_TOOLCHAIN</span>=<span class="variable">$ANDROID_PATH</span>/build/tools/make-standalone-toolchain.sh</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOLCHAIN_PATH</span>=<span class="variable">$ANDROID_PATH</span>/x86_64</span><br><span class="line"><span class="variable">$MAKE_TOOLCHAIN</span> <span class="attribute">--arch</span>=x86_64 <span class="attribute">--platform</span>=android-$PLATFORM_VERSION <span class="attribute">--install-dir</span>=<span class="variable">$TOOLCHAIN_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">CROSS_SYSROOT</span>=<span class="variable">$TOOLCHAIN_PATH</span>/sysroot</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOL_BASENAME</span>=<span class="variable">$TOOLCHAIN_PATH</span>/bin</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$CROSS_SYSROOT</span>:$PATH</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$TOOL_BASENAME</span>:$PATH</span><br><span class="line"></span><br><span class="line">./Configure <span class="attribute">--prefix</span>=/usr/local <span class="attribute">--cross-compile-prefix</span>=x86_64-linux-android- no-asm no-async shared android64</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h4 id="arm64-v8a"><a class="header-anchor" href="#arm64-v8a">¶</a>arm64-v8a</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">ANDROID_PATH</span>=<span class="variable">$ANDROID_NDK_PATH</span></span><br><span class="line"><span class="attribute">PLATFORM_VERSION</span>=21</span><br><span class="line"></span><br><span class="line"><span class="attribute">MAKE_TOOLCHAIN</span>=<span class="variable">$ANDROID_PATH</span>/build/tools/make-standalone-toolchain.sh</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOLCHAIN_PATH</span>=<span class="variable">$ANDROID_PATH</span>/aarch64-linux-android</span><br><span class="line"><span class="variable">$MAKE_TOOLCHAIN</span> <span class="attribute">--arch</span>=arm64 <span class="attribute">--platform</span>=android-$PLATFORM_VERSION <span class="attribute">--install-dir</span>=<span class="variable">$TOOLCHAIN_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">CROSS_SYSROOT</span>=<span class="variable">$TOOLCHAIN_PATH</span>/sysroot</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOL_BASENAME</span>=<span class="variable">$TOOLCHAIN_PATH</span>/bin</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$CROSS_SYSROOT</span>:$PATH</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$TOOL_BASENAME</span>:$PATH</span><br><span class="line"></span><br><span class="line">./Configure <span class="attribute">--prefix</span>=/usr/local <span class="attribute">--cross-compile-prefix</span>=aarch64-linux-android- no-asm no-async shared android64-aarch64</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h4 id="arm-v7a"><a class="header-anchor" href="#arm-v7a">¶</a>arm-v7a</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">ANDROID_PATH</span>=<span class="variable">$ANDROID_NDK_PATH</span></span><br><span class="line"><span class="attribute">PLATFORM_VERSION</span>=21</span><br><span class="line"></span><br><span class="line"><span class="attribute">MAKE_TOOLCHAIN</span>=<span class="variable">$ANDROID_PATH</span>/build/tools/make-standalone-toolchain.sh</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOLCHAIN_PATH</span>=<span class="variable">$ANDROID_PATH</span>/arm-linux-android</span><br><span class="line"><span class="variable">$MAKE_TOOLCHAIN</span> <span class="attribute">--arch</span>=arm <span class="attribute">--platform</span>=android-$PLATFORM_VERSION <span class="attribute">--install-dir</span>=<span class="variable">$TOOLCHAIN_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">CROSS_SYSROOT</span>=<span class="variable">$TOOLCHAIN_PATH</span>/sysroot</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOL_BASENAME</span>=<span class="variable">$TOOLCHAIN_PATH</span>/bin</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$CROSS_SYSROOT</span>:$PATH</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$TOOL_BASENAME</span>:$PATH</span><br><span class="line"></span><br><span class="line">./Configure <span class="attribute">--prefix</span>=/usr/local <span class="attribute">--cross-compile-prefix</span>=arm-linux-androideabi- no-asm no-async shared android-armeabi</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="查看so库信息"><a class="header-anchor" href="#查看so库信息">¶</a>查看so库信息</h3><p>编译后通过</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">readelf</span> -h libcrypto.so.<span class="number">1</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure><p>查看系统架构等信息</p><p>例如：</p><p>Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00<br>类别:                              ELF64<br>数据:                              2 补码，小端序 (little endian)<br>Version:                           1 (current)<br>OS/ABI:                            UNIX - System V<br>ABI 版本:                          0<br>类型:                              DYN (共享目标文件)<br>系统架构:                          AArch64<br>版本:                              0x1<br>入口点地址：               0x78240<br>程序头起点：          64 (bytes into file)<br>Start of section headers:          2968008 (bytes into file)<br>标志：             0x0<br>Size of this header:               64 (bytes)<br>Size of program headers:           56 (bytes)<br>Number of program headers:         6<br>Size of section headers:           64 (bytes)<br>Number of section headers:         32<br>Section header string table index: 29</p>]]></content>
      
      
      <categories>
          
          <category> 国密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gmssl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sodium各平台编译</title>
      <link href="/2023/04/21/tips%E6%95%B4%E7%90%86/libsodium.so%E5%90%84%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"/>
      <url>/2023/04/21/tips%E6%95%B4%E7%90%86/libsodium.so%E5%90%84%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1>sodium各平台编译</h1><h2 id="linux版编译"><a class="header-anchor" href="#linux版编译">¶</a>linux版编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.libsodium.org/libsodium/releases/LATEST.tar.gz</span><br><span class="line">tar -zxvf LATEST.tar.gz</span><br><span class="line"><span class="built_in">cd</span> libsodium-stable</span><br><span class="line"> ./configure</span><br><span class="line">make &amp;&amp; make check</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><h2 id="安卓版编译"><a class="header-anchor" href="#安卓版编译">¶</a>安卓版编译</h2><h3 id="交叉编译环境"><a class="header-anchor" href="#交叉编译环境">¶</a>交叉编译环境:</h3><p>打开终端，apt安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt-get install build-enssitial</span><br><span class="line">apt-get install clang</span><br><span class="line">apt-get install libtool</span><br><span class="line">apt-get install autoconf</span><br><span class="line">apt-get install automake</span><br></pre></td></tr></table></figure><h3 id="设置环境变量"><a class="header-anchor" href="#设置环境变量">¶</a>设置环境变量</h3><p>sudo vim /etc/profile<br>添加:<br>export ANDROID_NDK_HOME=/home/Android/Sdk/ndk/23.1.7779620<br>export PATH=$PATH:$ANDROID_NDK_HOME</p><p>source  /etc/profile</p><p>](<a href="https://github.com/jedisct1/libsodium.git">https://github.com/jedisct1/libsodium.git</a>)</p><h3 id="生成configure文件"><a class="header-anchor" href="#生成configure文件">¶</a>生成configure文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> libsodium-stable</span><br><span class="line">./autogen.sh -s</span><br><span class="line"><span class="comment">#可以先用./autogen.sh -h查看使用说明;</span></span><br></pre></td></tr></table></figure><h3 id="选择合适的版本编译"><a class="header-anchor" href="#选择合适的版本编译">¶</a>选择合适的版本编译</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp ./dist-build/android-build<span class="selector-class">.sh</span> android-build<span class="selector-class">.sh</span></span><br><span class="line">cp ./dist-build/android-armv8-<span class="selector-tag">a</span><span class="selector-class">.sh</span> android-armv8-<span class="selector-tag">a</span><span class="selector-class">.sh</span></span><br><span class="line">chmod a+x android-build<span class="selector-class">.sh</span></span><br><span class="line">chmod a+x android-armv8-<span class="selector-tag">a</span><span class="selector-class">.sh</span></span><br><span class="line">./android-armv8-<span class="selector-tag">a</span>.sh</span><br></pre></td></tr></table></figure><p>如果编译过程中报错，需要clean，然后重新编译<br>make distclean</p>]]></content>
      
      
      <categories>
          
          <category> tips整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sodium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于线程与进程的Windows-api</title>
      <link href="/2023/04/18/%E5%B9%B3%E5%8F%B0-Windows/Windows%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/04/18/%E5%B9%B3%E5%8F%B0-Windows/Windows%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一些常用的Windows-api"><a class="header-anchor" href="#一些常用的Windows-api">¶</a>一些常用的Windows-api</h2><h3 id="WSAGetLastError"><a class="header-anchor" href="#WSAGetLastError">¶</a>WSAGetLastError</h3><h4 id="用途"><a class="header-anchor" href="#用途">¶</a>用途</h4><p>返回该线程进行的上一次 Windows Sockets API 函数调用时的错误代码</p><h4 id="函数原型"><a class="header-anchor" href="#函数原型">¶</a>函数原型</h4><p>int WSAGetLastError ( );</p><h4 id="注意"><a class="header-anchor" href="#注意">¶</a>注意</h4><ol><li>当特定 Windows 套接字函数指示发生错误时，应立即调用<strong>WSAGetLastError</strong>以检索扩展错误代码。</li><li>如果函数调用的返回值指示错误或其他相关数据是在错误代码中返回的，则应立即调用 <strong>WSAGetLastError</strong> ，否则，某些函数可能会将最后一个扩展错误代码重置为 0</li><li>使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winsock/nf-winsock-wsasetlasterror">WSASetLastError</a> 函数重置扩展错误代码，并将 <em>iError</em> 参数设置为零。 使用 <em>SO_ERROR optname</em> 参数调用的 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winsock/nf-winsock-getsockopt">getsockopt</a> 函数也会将扩展错误代码重置为零。</li><li>不应使用 <strong>WSAGetLastError</strong> 函数在收到异步消息时检查扩展错误值。 在这种情况下，扩展错误值在消息的 <em>lParam</em> 参数中传递，这可能与 <strong>WSAGetLastError</strong> 返回的值不同。</li><li><strong>WSAGetLastError</strong> 函数是 Winsock 2.2 DLL 中唯一可在 <strong>WSAStartup</strong> 失败时调用的函数之一。</li></ol><h4 id="要求"><a class="header-anchor" href="#要求">¶</a>要求</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>最低支持的客户端</td><td>windows8.1 Windows Vista</td></tr><tr><td>最低支持的服务端</td><td>Windows server 2003</td></tr><tr><td>标头</td><td>winsock.h</td></tr><tr><td>Library</td><td>Ws2_32.lib</td></tr><tr><td>DLL</td><td>Ws2_32.dll</td></tr></tbody></table><h3 id="beginthread、beginthreadex"><a class="header-anchor" href="#beginthread、beginthreadex">¶</a>beginthread、beginthreadex</h3><h4 id="用途-v2"><a class="header-anchor" href="#用途-v2">¶</a>用途</h4><p>用于创建线程</p><h4 id="语法"><a class="header-anchor" href="#语法">¶</a>语法</h4><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef void     (<span class="variable">__cdecl</span>*   <span class="variable">_beginthread_proc_type</span>  )(void*);</span><br><span class="line">typedef unsigned (<span class="variable">__stdcall</span>* <span class="variable">_beginthreadex_proc_type</span>)(void*);</span><br><span class="line"></span><br><span class="line"><span class="variable">_ACRTIMP</span> uintptr_t <span class="variable">__cdecl</span> <span class="variable">_beginthread</span>(</span><br><span class="line">    <span class="variable">_In_</span>     <span class="variable">_beginthread_proc_type</span> <span class="variable">_StartAddress</span>,</span><br><span class="line">    <span class="variable">_In_</span>     unsigned               <span class="variable">_StackSize</span>,</span><br><span class="line">    <span class="variable">_In_opt_</span> void*                  <span class="variable">_ArgList</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="variable">_ACRTIMP</span> uintptr_t <span class="variable">__cdecl</span> <span class="variable">_beginthreadex</span>(</span><br><span class="line">    <span class="variable">_In_opt_</span>  void*                    <span class="variable">_Security</span>,</span><br><span class="line">    <span class="variable">_In_</span>      unsigned                 <span class="variable">_StackSize</span>,</span><br><span class="line">    <span class="variable">_In_</span>      <span class="variable">_beginthreadex_proc_type</span> <span class="variable">_StartAddress</span>,</span><br><span class="line">    <span class="variable">_In_opt_</span>  void*                    <span class="variable">_ArgList</span>,</span><br><span class="line">    <span class="variable">_In_</span>      unsigned                 <span class="variable">_InitFlag</span>,</span><br><span class="line">    <span class="variable">_Out_opt_</span> unsigned*                <span class="variable">_ThrdAddr</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h4 id="参数"><a class="header-anchor" href="#参数">¶</a>参数</h4><p><em><code>Security</code></em></p><p>指向 <a href="https://learn.microsoft.com/zh-cn/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)"><code>SECURITY_ATTRIBUTES</code></a> 结构的指针，此结构确定返回的句柄是否由子进程继承。 <code>Security</code>为<code>NULL</code>表示默认安全性，无法继承句柄。</p><p><em><code>StackSize</code></em></p><p>新线程的堆栈大小，一般默认为0</p><p><em><code>StartAddress</code></em></p><p>启动开始执行新线程的例程的地址，对于 <strong><code>_beginthread</code></strong>，调用约定是 <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/cdecl?view=msvc-170"><code>__cdecl</code></a> （本机代码) ，或者是 <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/clrcall?view=msvc-170"><code>__clrcall</code></a> （托管代码) 。 对于 <strong><code>_beginthreadex</code></strong>，调用约定是 <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/stdcall?view=msvc-170"><code>__stdcall</code></a> （本机代码) ，或者是 <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/clrcall?view=msvc-170"><code>__clrcall</code></a> （托管代码) 。</p><p><em><code>ArgList</code></em></p><p>要传递到新线程的参数列表or <code>NULL</code></p><p><em><code>InitFlag</code></em></p><p>控制新线程的初始状态的标志。</p><p>设置为 0 则立即运行，</p><p>设置为 <code>CREATE_SUSPENDED</code>则创建后挂起,使用 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread"><code>ResumeThread</code></a> 来执行此线程。</p><p><em><code>ThrdAddr</code></em></p><p>存放线程标识符，它是CreateThread函数中的线程ID</p><h4 id="区别"><a class="header-anchor" href="#区别">¶</a>区别</h4><ol><li>参数形式不同</li><li><code>ex</code>能够创建悬挂状态线程，在nt中能够指定级别，能够被<code>thrdaddr</code>访问，因为它有了<code>id</code>。</li><li><code>ex</code>使用<code>__stdcall</code>调用格式，必须返回<code>exit code</code>。</li><li><code>ex</code>返回0代表失败，原先的返回-1L。</li><li><code>ex</code>创建的必须用ex销毁</li></ol><h3 id="endthread、endthreadex"><a class="header-anchor" href="#endthread、endthreadex">¶</a>endthread、endthreadex</h3><h4 id="用途-v3"><a class="header-anchor" href="#用途-v3">¶</a>用途</h4><p>用于结束线程终止线程；<strong><code>_endthread</code></strong> 终止由 <strong><code>_beginthread</code></strong> 创建的线程，<strong><code>_endthreadex</code></strong> 终止由 <strong><code>_beginthreadex</code></strong> 创建的线程。</p><p>语法</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*释放线程空间、释放线程TLS空间、调用ExiteThread结束线程。*/</span></span><br><span class="line"><span class="variable">_ACRTIMP</span> void <span class="variable">__cdecl</span> <span class="variable">_endthread</span>(void);</span><br><span class="line"></span><br><span class="line"><span class="comment">// retval:设定的线程结束码，与ExiteThread函数的参数功能一样，</span></span><br><span class="line"><span class="comment">//其实这个函数释放线程TLS空间，再调用ExiteThread函数，但没有释放线程空间。</span></span><br><span class="line"><span class="variable">_ACRTIMP</span> void <span class="variable">__cdecl</span> <span class="variable">_endthreadex</span>(</span><br><span class="line">    <span class="variable">_In_</span> unsigned <span class="variable">_ReturnCode</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h4 id="参数-v2"><a class="header-anchor" href="#参数-v2">¶</a>参数</h4><p><em><code>retval</code></em>  线程退出代码</p><h4 id="注意-v2"><a class="header-anchor" href="#注意-v2">¶</a>注意</h4><ol><li>当线程从作为 <strong><code>_endthread</code></strong> 或 <strong><code>_endthreadex</code></strong> 参数传递的例程中返回时，会自动调用 <strong><code>_beginthread</code></strong> 或 <strong><code>_beginthreadex</code></strong>。这有助于适当恢复为线程分配的资源。</li><li><strong><code>_endthread</code></strong> 会自动关闭线程句柄。</li><li><strong><code>_endthreadex</code></strong> 不会关闭线程句柄，所以使用 <strong><code>_beginthreadex</code></strong> 和 <strong><code>_endthreadex</code></strong> 时，必须通过调用 Win32 <code>CloseHandle</code> API 来关闭线程句柄。</li><li>对于与 Libcmt.lib 链接的可执行文件，请不要调用 Win32 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread"><code>ExitThread</code></a> API；这将阻止运行时系统回收已分配的资源。</li><li><strong><code>_endthread</code></strong> 和 <strong><code>_endthreadex</code></strong> 会导致 C++ 析构函数在不会调用的线程中处于挂起状态。</li></ol><h3 id="WaitForSingleObject"><a class="header-anchor" href="#WaitForSingleObject">¶</a>WaitForSingleObject</h3><h4 id="用途-v4"><a class="header-anchor" href="#用途-v4">¶</a>用途</h4><p>等待指定对象处于信号状态或超时间隔已过。</p><p><em>如果要等待多个对象则使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/synchapi/nf-synchapi-waitformultipleobjects">WaitForMultipleObjects</a></em></p><h4 id="语法-v2"><a class="header-anchor" href="#语法-v2">¶</a>语法</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD WaitForSingleObject(</span><br><span class="line"><span class="string">  [in]</span> HANDLE hHandle,</span><br><span class="line"><span class="string">  [in]</span> DWORD  dwMilliseconds</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="参数-v3"><a class="header-anchor" href="#参数-v3">¶</a>参数</h4><p><em><code>[in] hHandle</code></em></p><p>传递一个内核对象句柄，该句柄标识一个内核对象，句柄必须具有 <strong>SYNCHRONIZE</strong> 访问权限。</p><p>如果该内核对象处于未通知状态，则该函数导致线程进入<strong>阻塞状态</strong>；如果该内核对象处于已通知状态，则该函数立即返回WAIT_OBJECT_0</p><p><em><code>[in] dwMilliseconds</code></em></p><p>超时间隔（以毫秒为单位）。</p><p>如果指定了非零值，该函数将等待对象发出信号或间隔。</p><p>如果 <em>dwMilliseconds</em> 为零，则如果对象未发出信号，则函数不会输入等待状态;它始终会立即返回。</p><p>如果 <em>dwMilliseconds</em> 为 <strong>INFINITE</strong>，则仅当发出对象信号时，该函数才会返回。</p><h4 id="返回值"><a class="header-anchor" href="#返回值">¶</a>返回值</h4><table><thead><tr><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>WAIT_OBJECT_0<br>0x00000080L</td><td>等待的对象有信号（对线程来说，表示执行结束）</td></tr><tr><td>WAIT_TIMEOUT<br>0x00000000L</td><td>等待指定时间内，对象一直没有信号（线程没执行完)</td></tr><tr><td>WAIT_ABANDONED<br>0x00000102L</td><td>对象有信号，但还是不能执行 一般是因为未获取到锁或其他原因</td></tr><tr><td>WAIT_FAILED<br>(DWORD) 0xFFFFFFFF</td><td>函数失败。 要获得更多的错误信息，请调用 GetLastError。</td></tr></tbody></table><h3 id="TerminateThread"><a class="header-anchor" href="#TerminateThread">¶</a>TerminateThread</h3><h4 id="用途-v5"><a class="header-anchor" href="#用途-v5">¶</a>用途</h4><p>在线程外终止一个线程，用于强制终止线程。</p><h4 id="语法-v3"><a class="header-anchor" href="#语法-v3">¶</a>语法</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="constructor">TerminateThread( HANDLE <span class="params">hThread</span>, DWORD <span class="params">dwExitCode</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="参数-v4"><a class="header-anchor" href="#参数-v4">¶</a>参数</h4><p><em><code>hThread</code></em></p><p>被终止的线程的句柄</p><p><em><code>dwExitCode</code></em></p><p>退出码</p><h4 id="返回值-v2"><a class="header-anchor" href="#返回值-v2">¶</a>返回值</h4><p>函数执行成功则返回非零值，执行失败返回0。调用getlasterror获得返回的值</p><h4 id="要求-v2"><a class="header-anchor" href="#要求-v2">¶</a>要求</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>最低支持的客户端</td><td>Windows XP</td></tr><tr><td>最低支持的服务端</td><td>Windows server 2003</td></tr><tr><td>标头</td><td>processthreadsapi.h</td></tr><tr><td>Library</td><td>Kernel32.lib</td></tr><tr><td>DLL</td><td>Kernel32.dll</td></tr></tbody></table><h4 id="注意-v3"><a class="header-anchor" href="#注意-v3">¶</a>注意</h4><ol><li>如果目标线程拥有关键部分，则不会释放关键部分。</li><li>如果目标线程从堆分配内存，则不会释放堆锁。</li><li>如果目标线程在终止时正在执行某些 kernel32 调用，则线程进程的 kernel32 状态可能不一致。</li><li>如果目标线程正在操作共享 DLL 的全局状态，可能会销毁 DLL 的状态，从而影响 DLL 的其他用户。</li><li>如果目标线程是调用此函数时进程的最后一个线程，则线程的进程也会终止。线程对象的状态会发出信号，释放等待线程终止的任何其他线程。 线程的终止状态从 <strong>STILL_ACTIVE</strong> 更改为 <em>dwExitCode</em> 参数的值。</li><li>终止线程不一定从系统中删除线程对象。 关闭最后一个线程句柄时，将删除线程对象。</li></ol><h3 id="GetBestInterfaceEx"><a class="header-anchor" href="#GetBestInterfaceEx">¶</a>GetBestInterfaceEx</h3><h4 id="用途-v6"><a class="header-anchor" href="#用途-v6">¶</a>用途</h4><p>检索具有指向指定 IPv4 或 IPv6 地址的最佳路由的接口的索引</p><h4 id="语法-v4"><a class="header-anchor" href="#语法-v4">¶</a>语法</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="constructor">GetBestInterfaceEx(<span class="params">int</span> <span class="operator">*</span><span class="params">pIndex</span>, <span class="params">int</span> <span class="params">maxSize</span>, <span class="params">char</span> <span class="operator">*</span><span class="params">pGateway</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="参数-v5"><a class="header-anchor" href="#参数-v5">¶</a>参数</h4><p><em><code>[in] pIndex</code></em></p><p>要为其检索具有最佳路由的接口的目标 IPv6 或 IPv4 地址</p><p><em><code>[in] maxSize</code></em></p><p>地址最大长度</p><p><code>[out] pdwBestIfIndex</code></p><p><em>pIndex</em> 指定的 IPv6 或 IPv4 地址的最佳路由。</p><h3 id="WSASocketA"><a class="header-anchor" href="#WSASocketA">¶</a>WSASocketA</h3><h4 id="用途-v7"><a class="header-anchor" href="#用途-v7">¶</a>用途</h4><p>创建绑定到特定传输服务提供程序的套接字</p><h4 id="语法-v5"><a class="header-anchor" href="#语法-v5">¶</a>语法</h4><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SOCKET WSAAPI WSASocketA(</span><br><span class="line">    <span class="variable">_In_</span> int af,</span><br><span class="line">    <span class="variable">_In_</span> int <span class="built_in">type</span>,</span><br><span class="line">    <span class="variable">_In_</span> int protocol,</span><br><span class="line">    <span class="variable">_In_opt_</span> LPWSAPROTOCOL_INFOA lpProtocolInfo,</span><br><span class="line">    <span class="variable">_In_</span> <span class="built_in">GROUP</span> g,</span><br><span class="line">    <span class="variable">_In_</span> DWORD dwFlags</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p><em><code>[in] af</code></em></p><p>地址系列规范</p><table><thead><tr><th>af</th><th>含义</th></tr></thead><tbody><tr><td>AF_UNSPEC</td><td></td></tr><tr><td><br>0</td><td>未指定地址系列</td></tr><tr><td>AF_INET</td><td></td></tr><tr><td><br>2</td><td>指定IPV4地址系列</td></tr><tr><td>AF_IPX</td><td></td></tr><tr><td><br>6</td><td>指定IPX/SPX 地址系列</td></tr><tr><td>AF_APPLETALK</td><td></td></tr><tr><td><br>16</td><td>指定AppleTalk 地址系列</td></tr><tr><td>AF_NETBIOS</td><td></td></tr><tr><td><br>17</td><td>指定NetBIOS 地址系列<br>Windows 32位系统</td></tr><tr><td>AF_INET6</td><td></td></tr><tr><td><br>23</td><td>指定I9V6地址系列</td></tr><tr><td>AF_IRDA</td><td></td></tr><tr><td><br>26</td><td>指定红外数据关联 (IrDA) 地址系列</td></tr><tr><td>AF_BTH</td><td></td></tr><tr><td><br>32</td><td>指定蓝牙地址系列</td></tr></tbody></table><p><em><code>[in] type</code></em></p><p>新套接字的类型规范</p><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>SOCK_STREAM</td><td></td></tr><tr><td><br>1</td><td>对应TCP</td></tr><tr><td>SOCK_DGRAM</td><td></td></tr><tr><td><br>2</td><td>对应UDP</td></tr><tr><td>SOCK_RAW</td><td></td></tr><tr><td><br>3</td><td>提供原始套接字的套接字类型，允许应用程序操作下一层协议标头。 若要操作 IPv4 标头，必须在套接字上设置 IP_HDRINCL 套接字选项。 若要操作 IPv6 标头，必须在套接字上设置 IPV6_HDRINCL 套接字选项。</td></tr><tr><td>SOCK_RDM</td><td></td></tr><tr><td><br>4</td><td>对应多播</td></tr><tr><td>SOCK_SEQPACKET</td><td></td></tr><tr><td><br>5</td><td>提供基于数据报的伪流数据包的套接字类型。</td></tr></tbody></table><p><em><code>[in] protocol</code></em></p><p>使用的协议</p>]]></content>
      
      
      <categories>
          
          <category> 平台-Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Android模拟器</title>
      <link href="/2023/04/18/%E5%B9%B3%E5%8F%B0-android/%E4%BD%BF%E7%94%A8Android%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
      <url>/2023/04/18/%E5%B9%B3%E5%8F%B0-android/%E4%BD%BF%E7%94%A8Android%E6%A8%A1%E6%8B%9F%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Android模拟器"><a class="header-anchor" href="#安装Android模拟器">¶</a>安装Android模拟器</h2><p>Android模拟器这步真的太痛苦了ε=( o｀ω′)ノ<br>搞了好多办法最后搞得Android studio总是闪退，解决办法：重装软件啦╮(╯▽╰)╭</p><h3 id="AndroidStudio自带的安卓模拟器"><a class="header-anchor" href="#AndroidStudio自带的安卓模拟器">¶</a>AndroidStudio自带的安卓模拟器</h3><p>在虚拟机里安装Android Studio，使用它自带的安卓模拟器;</p><p>打开Android Studio，第一次打开会进行一些基础设置和安装sdk，默认就好；<br>新建工程，打开tools-&gt;sdk manager;安装Android Emulator(最新版),Android SDK plantform-tools,ndk(自定义奥);</p><p>打开Device Manager，create virtual device:<br>1)choose a device definition — Nexus 5X;</p><p>2)select a system image — Nougat(api:24,ABI:X86)<br>可以自主选择需要的不同api等级和ABI的镜像，但是需要注意:<br><strong>①系统缺少/不支持VT-x/AMD-V;</strong><br>解决：关闭虚拟机，打开设置-系统-处理器-勾选启用嵌套VT-x/AMD-V;</p><p>如果无法启用，选项为灰色，则使用VBoxManage以命令行的方式进行开启,操作步骤如下:<br>物理机管理员身份打开cmd，cd到virtualbox安装目录;<br>VBoxManage.exe list vms   #列出虚拟机名字<br>.\vboxmanage.exe modifyvm hostname --nested-hw-virt on  #打开hostname的嵌套VT-x/AMD-V功能</p><p><strong>②选择api level</strong><br>新建项目工程时选择的api等级是工程支持的最低SDK版本，所以选择镜像的api等级应该不小于这个等级;</p><p>如果想要修改min-api，可以打开工程结构File-&gt;Project Structure(or快捷键Ctrl+Alt+Shift+S)，修改Default Config-&gt;Min SDK version;</p><p><strong>③选择ABI</strong><br>科普：<br>ABI (Application Binray interface):应用程序二进制接口，描述了应用程序和操作系统之间，一个应用和它的库之间，或应用的组成部分之间的底层接口。<br>早期的Android系统几乎只支持ARMv5的CPU架构，后面发展到支持七种不同的CPU架构：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起)，每一种都关联着一个相应的ABI。<br>应用程序二进制接口（Application Binary Interface）定义了二进制文件（尤其是.so文件）如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库。<br>在Android 系统上，每一个CPU架构对应一个ABI：armeabi，armeabi-v7a，x86，mips，arm64- v8a，mips64，x86_64。<br>AndroidStudio自带的模拟器中只有常用的四种：armeabi-v7a，x86，arm64- v8a，x86_64;可以按需选择。</p><p>但是最好是对应系统的CPU架构，建议先查看系统cpu架构(unix系统使用命令&quot;uname -a&quot;查看)，然后选择对应的CPU架构;<br>比如我的ubuntu2204的CPU架构是X86_64，所以就可以选择X86和X86_64位的;<br>尝试使用armeabi-v7a的镜像，结果启动后一直卡在开机页面(Windows试过也是这样，可能是不兼容);</p><p>不过这些虚拟设备动辄四五个G，还有八九个G的，运行起来也很卡，最关键的是，连接不上！！！！<br>经过一番努力后，选择放弃，改用别的安卓模拟器。</p><h3 id="genymotion"><a class="header-anchor" href="#genymotion">¶</a>genymotion</h3><p>寻找资料发现ubuntu等linux系统可用安卓模拟器很多，不仅安装方便，运行也不会很卡;<br>这里我是用的是genymotion，原因是好看。</p><h4 id="安装VirtualBox"><a class="header-anchor" href="#安装VirtualBox">¶</a>安装VirtualBox</h4><p>genymotion依赖于VirtualBox，所以不仅物理机的Virtualbox要开启VT-x/AMD-V扩展功能，还要在虚拟机内安装virtualbox;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install virtualbox</span><br></pre></td></tr></table></figure><h4 id="安装genymotion"><a class="header-anchor" href="#安装genymotion">¶</a>安装genymotion</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.genymotion.com/releases/genymotion-3.1.2/genymotion-3.1.2-linux_x64.bin</span><br><span class="line">sudo ./genymotion-3.1.2-linux_x64.bin</span><br></pre></td></tr></table></figure><p><em>默认安装目录：/opt/genymobile/genymotion</em></p><h4 id="添加快捷方式"><a class="header-anchor" href="#添加快捷方式">¶</a>添加快捷方式</h4><p>打开终端，命令行输入以下内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim</span><br><span class="line"><span class="built_in">ln</span> -s /opt/genymobile/genymotion/genymotion /usr/bin/genymotion</span><br><span class="line"><span class="built_in">ln</span> -s /opt/genymobile/genymotion/icons/genymotion-logo.png /usr/local/share/genymotion-logo.png</span><br><span class="line"><span class="built_in">cd</span> /usr/share/applications </span><br><span class="line">sudo vim ./genymotion.desktop</span><br></pre></td></tr></table></figure><p>新建桌面文件，添加以下内容:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Desktop Entry]</span><br><span class="line"></span><br><span class="line"><span class="attribute">Name</span> <span class="operator">=</span> genymotion</span><br><span class="line"></span><br><span class="line"><span class="attribute">Exec</span> <span class="operator">=/</span>usr/bin/genymotion</span><br><span class="line"></span><br><span class="line"><span class="attribute">Icon</span> <span class="operator">=/</span>usr/local/share/genymotion-logo.png</span><br><span class="line"></span><br><span class="line"><span class="attribute">Comment</span> <span class="operator">=</span> genymotion</span><br><span class="line"></span><br><span class="line"><span class="attribute">Type</span> <span class="operator">=</span> Application   </span><br></pre></td></tr></table></figure><h4 id="注册"><a class="header-anchor" href="#注册">¶</a>注册</h4><p>因为genymotion需要账号登陆，因此我们需要去官网创建账号，因此才可以登陆软件；<br><a href="https://www.genymotion.com/account/create/">创建账号</a><br>创建好账号之后，回到genymotion软件，输入帐号密码，点击next，选择Personal Use，继续next即可使用个人版;</p><h4 id="AndroidStudio插件"><a class="header-anchor" href="#AndroidStudio插件">¶</a>AndroidStudio插件</h4><p>打开AndroidStudio，找到setting-plugins，搜索genymotion，安装插件并重启Android Studio;<br>点击Genymotion插件图标，打开插件;<br>(没有UI工具栏的，需要依次点击 View =&gt; Appearance =&gt; Toolbar 即可找到)<br>打开setting-tools-genymotion plugin，填入Genymotion安装路径;</p>]]></content>
      
      
      <categories>
          
          <category> 平台-android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android studio </tag>
            
            <tag> 模拟器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Virtualbox搭建虚拟机</title>
      <link href="/2023/04/18/tips%E6%95%B4%E7%90%86/Virtualbox%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2023/04/18/tips%E6%95%B4%E7%90%86/Virtualbox%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="安装virtualbox"><a class="header-anchor" href="#安装virtualbox">¶</a>安装virtualbox:</h2><p><a href="https://www.virtualbox.org/wiki/Downloads">virtualbox主程序</a><br>点击链接，选择合适的版本下载virtualbox;</p><h2 id="安装ubuntu虚拟机"><a class="header-anchor" href="#安装ubuntu虚拟机">¶</a>安装ubuntu虚拟机</h2><p>下载镜像:<br><a href="https://ubuntu.com/download/desktop">官方下载地址</a><br>推荐，官方不花里胡哨，国内镜像源下载的ubuntu-22.04.2-desktop-amd64.iso出现了写入错误，内核编译缺少头文件等情况。<br>写入错误导致ubuntu无法安装，内核头文件确实导致virtualbox安装增强功能失败。</p><p><a href="https://mirrors.cloud.tencent.com/ubuntu-releases/22.04/">腾讯镜像站</a></p><p><a href="https://mirrors.aliyun.com/ubuntu-releases/22.04/">阿里镜像站</a></p><p><a href="https://repo.huaweicloud.com/ubuntu-releases/22.04">华为镜像站</a></p><p><em>ps:widows镜像可以到<a href="https://msdn.itellyou.cn/">msdn</a> 上下载</em></p><p>点击新建，填写虚拟机名称、安装位置，镜像位置，默认安装;<br>虚拟机里装模拟器，要把内存设置的大一点，我设置了100G(‾◡◝)</p><h3 id="修改分辨率"><a class="header-anchor" href="#修改分辨率">¶</a>修改分辨率</h3><p>进入系统之后发现缩放比例不对，其实是分辨率的问题，找到setting-&gt;desplays修改分辨率;</p><p>系统中没有1920x1080的肿么办，可以自己添加:<br>打开终端，输入xrandr，查看到屏幕分辨率最小是1x1，目前是:800x600，最大是8192x8192，虚拟机编号是&quot;Virtual1&quot;;<br>输入cvt 1920 1080，查看显示模式的相关信息:“Modeline xxxxxx”;<br>添加显示模式，输入下面两条命令:<br>sudo xrandr --newmode xxxxxx<br>sudo xrandr --addmode Virtual1(虚拟机编号) “1920x1080 60.00”<br>使用命令xrandr查看，可以发现可供选择的分辨率多了自己自定义的模式，可以到设置里设置显示屏分辨率了;</p><p>或者：<br>点击界面的设备，选择安装增强功能，点击运行;<br>点击光盘，sudo ./VBoxLinuxAdditions.run，成功后重启虚拟机;<br>点击视图-自动调整显示尺寸；可以使显示窗口自动填满界面。</p><h3 id="共享文件夹"><a class="header-anchor" href="#共享文件夹">¶</a>共享文件夹</h3><p>首先弹出上一步安装增强功能所用的光盘(不然挂载会失败);<br>修改虚拟机的设置，点击共享文件夹，新建:填写共享文件夹目录(物理机D:\shared)，文件夹名称(shared)，勾选自动挂载，固定分配;<br>回到虚拟机，打开终端，输入命令行创建文件夹:<br>sudo mkdir /home/Win10<br>将主机共享文件夹与Ubuntu的共享文件夹连接起来:<br>sudo mount -t vboxsf shared /home/Win10<br>在主机的共享文件夹放置一个文件，如果Ubuntu内的对应共享文件夹内能看到该文件，则说明共享文件夹创建成功。</p><p><em>注意：物理机的共享目录不要放到C盘或者virtualbox的安装目录下(需要管理员权限的那种)，不然操作共享目录需要物理机管理员权限，在Ubuntu上就算是sudo也没用。</em></p><h3 id="共享粘贴板和拖放"><a class="header-anchor" href="#共享粘贴板和拖放">¶</a>共享粘贴板和拖放</h3><p>设备-将禁用改为双向;</p>]]></content>
      
      
      <categories>
          
          <category> tips整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> virtualbox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android开发--活动的创建与使用</title>
      <link href="/2023/03/31/%E5%B9%B3%E5%8F%B0-android/android%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/03/31/%E5%B9%B3%E5%8F%B0-android/android%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本章学习Android中的活动，活动是一种可以包含用户界面的组件，主要用于和用户交互。</p><h2 id="活动的基本用法"><a class="header-anchor" href="#活动的基本用法">¶</a>活动的基本用法</h2><h3 id="创建活动"><a class="header-anchor" href="#创建活动">¶</a>创建活动</h3><h4 id="新建项目"><a class="header-anchor" href="#新建项目">¶</a>新建项目</h4><p>打开Android Studio新建Android项目，选择no Activity，等待gradle构建;</p><h4 id="新建活动"><a class="header-anchor" href="#新建活动">¶</a>新建活动</h4><p>右击 app/src/main/java/com.example.activitytest-&gt;New-&gt;Actvity-&gt;Empty Activity，创建活动FirstActivity，注意不勾选Generate Layout和Launcher Activity;<br>打开创建的FirstActivity，发现Android Studio自动完成了重写Activity的onCreate()方法，即调用父类的onCreate()方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建布局"><a class="header-anchor" href="#创建布局">¶</a>创建布局</h3><p>布局用于显示页面内容，最好每个活动对应一个布局;</p><h4 id="新建布局文件"><a class="header-anchor" href="#新建布局文件">¶</a>新建布局文件</h4><p>右击app/src/main/res-&gt;New-&gt;Directory，新建layout文件夹；<br>右击layout-&gt;NeW-&gt;Layout resource file,创建first_layout布局文件，选择根元素为LinearLayout;<br>布局文件创建完成后，Android Studio会显示可视化布局编辑器(右上角可切换模式);</p><h4 id="编辑布局文件"><a class="header-anchor" href="#编辑布局文件">¶</a>编辑布局文件</h4><p>编辑布局文件，添加一个按钮：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/button_1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;150dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginEnd</span>=<span class="string">&quot;150dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;400dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;START&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这里添加了一个Button元素，并增加了几个属性。<br><strong>id</strong><br>android:id为当前元素定义一个唯一标识符：在XML中引用一个id，使用@id/id_name;在XML中定义一个id，使用@+id/id_name;<br><strong>width、height</strong><br>android:layout_width、android:layout_height定义了元素的宽高，使用wrap_content表示当前元素的高度只要刚好能包含里面的内容;<br><strong>margin</strong><br>android:layout_marginStart、android:layout_marginTop、android:layout_marginEnd、android:layout_marginBottom定义了元素的位置;</p><p>layout_marginTop 指定该属性所在控件距上部最近控件的最小值;<br>layout_marginBottom 指定该属性所在控件距下部最近控件的最小值;<br>layout_marginLeft 指定该属性所在控件距左边最近控件的最小值;<br>layout_marginRight 指定该属性所在控件距右边最近控件的最小值;<br>layout_marginStart：如果在LTR布局模式下，该属性等同于layout_marginLeft。如果在RTL布局模式下，该属性等同于layout_marginRight。<br>layout_marginEnd：如果在LTR布局模式下，该属性等同于layout_marginRight。如果在RTL布局模式下，该属性等同于layout_marginLeft。<br><strong>text</strong><br>android:text制定了元素显示的文字内容;<br><strong>constraint</strong><br>控件在ConstraintLayout里面要实现margin，必须先约束该控件在ConstraintLayout里的位置;<br>app:layout_constraintBottom_toBottomOf、app:layout_constraintEnd_toEndOf、app:layout_constraintStart_toStartOf、app:layout_constraintTop_toTopOf约束元素在parent里的位置，使得margin生效。</p><blockquote><p>约束布局ConstraintLayout是一个ViewGroup，可以在Api9以上的Android系统使用它，它的出现主要是为了解决布局嵌套过多的问题，以灵活的方式定位和调整小部件。<br>例如：首先是一个垂直的LinearLayout，里面放两个水平的LinearLayout，然后在水平的LinearLayout里面放TextView。这样的写法就嵌套了两层LinearLayout，可能会出现布局嵌套过多的问题，嵌套得越多，设备绘制视图所需的时间和计算功耗也就越多。<br>ConstraintLayout横空出世，ConstraintLayout可以按照比例约束控件位置和尺寸，能够更好地适配屏幕大小不同的机型。</p></blockquote><p>使用ConstraintLayout首先需要添加依赖，在build.gradle(app)中添加<br>implementation ‘com.android.support.constraint:constraint-layout:1.1.3’</p><p>使用ConstraintLayout可以实现控件位置的控制:</p><p>布局文件中添加:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/TextView1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;TextView1&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/TextView2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintLeft_toRightOf</span>=<span class="string">&quot;@+id/TextView1&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>可以实现元素TextView2的相对定位，使用属性app:layout_constraintLeft_toRightOf=“@+id/TextView1”，把TextView2的左边约束到TextView1的右边;</p><p>相对定位的常用属性：<br>layout_constraintLeft_toLeftOf<br>layout_constraintLeft_toRightOf<br>layout_constraintRight_toLeftOf<br>layout_constraintRight_toRightOf<br>layout_constraintTop_toTopOf<br>layout_constraintTop_toBottomOf<br>layout_constraintBottom_toTopOf<br>layout_constraintBottom_toBottomOf<br>layout_constraintBaseline_toBaselineOf<br>layout_constraintStart_toEndOf<br>layout_constraintStart_toStartOf<br>layout_constraintEnd_toStartOf<br>layout_constraintEnd_toEndOf</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:id</span>=<span class="string">&quot;@+id/TextView1&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:text</span>=<span class="string">&quot;TextView1&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:id</span>=<span class="string">&quot;@+id/TextView2&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">app:layout_constraintCircle</span>=<span class="string">&quot;@+id/TextView1&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">app:layout_constraintCircleAngle</span>=<span class="string">&quot;60&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">app:layout_constraintCircleRadius</span>=<span class="string">&quot;100dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>可以实现TextView2的角度定位，属性app:layout_constraintCircle=&quot;@+id/TextView1&quot;确定中心为TextView1，属性app:layout_constraintCircleAngle=&quot;160&quot;确定在TextView1的中心的60°，属性app:layout_constraintCircleRadius=&quot;100dp确定和TextView1距离为100dp;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/TextView1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintHorizontal_bias</span>=<span class="string">&quot;0.618&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">app:layout_constraintVertical_bias</span>=<span class="string">&quot;0.618&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>可以实现TextView1的偏移，layout_constraintHorizontal_bias 水平偏移，layout_constraintVertical_bias 垂直偏移;此外，constraint还可以实现更多更复杂的布局。</p><p>总之，这样一个简单的布局就编写完成了，接下来要在活动中加载这个布局。</p><h4 id="加载布局文件"><a class="header-anchor" href="#加载布局文件">¶</a>加载布局文件</h4><p>编辑FirstActivity，onCreate()方法调用setContentView()方法加载布局:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.first_layout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册活动"><a class="header-anchor" href="#注册活动">¶</a>注册活动</h3><p>所有的活动都要在AndroidManifest.xml中进行注册才能生效，打开app/src/main/AndroidMainfest.xml:</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">application</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    ···</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"> &lt;<span class="attr">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.FirstActivity&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在activity标签中使用android.name注册活动;并在其中加入<intent-filter>标签，设置FirstActivity为主活动，即当程序运行时，首先启动FirstActivity;</intent-filter></p><h3 id="Toast的使用"><a class="header-anchor" href="#Toast的使用">¶</a>Toast的使用</h3><p>Toast是Android系统提供的提醒方式，在程序中可以把一些短小的消息传给用户，这些消息在一定时间后会自动消失，且不占用任何屏幕空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.first_layout);</span><br><span class="line">    <span class="type">Button</span> <span class="variable">button1</span> <span class="operator">=</span> (Button) findViewById(R.id.button_1);</span><br><span class="line">    button1.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">            Toast.makeText(FirstActivity.<span class="built_in">this</span>,<span class="string">&quot;开始测试&quot;</span>,</span><br><span class="line">                    Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">                               &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在活动中，通过findViewById()方法获取到定义在布局文件中的元素，传入R.id.button_1(first_layout中android:id规定的唯一标识符)获取按钮的实例，且findViewById()返回的是一个view对象，需要转化成Button对象;<br>然后调用setOnClickListener()方法为按钮注册一个监听器，点击按钮时就会执行监听器中的onClick()方法;<br>编写onClick()方法，通过静态方法makeText()创建出一个Toast对象，然后显示;</p><p>makeText()方法的输入参数为Context(活动要求的上下文)、Toast现实的文本内容、Toast的显示时长。</p>]]></content>
      
      
      <categories>
          
          <category> 平台-android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> xml </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android从0开发（二）.md</title>
      <link href="/2023/03/30/%E5%B9%B3%E5%8F%B0-android/android%E4%BB%8E0%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/03/30/%E5%B9%B3%E5%8F%B0-android/android%E4%BB%8E0%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Android开发第二弹来啦~~<br>在进行jni开发的时候，发现生成的Native函数声明的第一个参数影院是JNIEnv指针，第二个参数永远是jobject或者jclass;<br>JNIEnv是一个JNI接口指针，指向了本地方法的一个函数表，该函数表中的每一个成员指向了一个JNI函数，本地方法通过JNI函数来访问JVM中的数据结构;<br>jobject与jclass通常作为JNI函数的第二个参数，当所声明Native方法是静态方法时，对应参数jclass，因为静态方法不依赖对象实例，而依赖于类；<br>如果声明的Native方法时非静态方法时，那么对应参数是jobject。<br>jni中常使用数组和字符串，这里总结一下开发时用到的一些知识。</p><h2 id="jni数组使用"><a class="header-anchor" href="#jni数组使用">¶</a>jni数组使用</h2><h3 id="NewArray"><a class="header-anchor" href="#NewArray">¶</a>NewArray</h3><p>构造原始数组，构造失败则返回null;</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayType New&lt;PrimitiveType&gt;<span class="constructor">Array(JNIEnv <span class="operator">*</span><span class="params">env</span>, <span class="params">jsize</span> <span class="params">length</span>)</span>;</span><br></pre></td></tr></table></figure><p>基本数组类型:<br>|-- jni |-- java |<br>| := | := |<br>| jbooleanArray | boolean[] |<br>| jbyteArray | byte[] |<br>| jcharArray | char[] |<br>| jshortArray | short[] |<br>| jintArray | int[] |<br>| jlongArray | long[] |<br>| jdoubleArray | double[] |</p><h3 id="GetArrayLength"><a class="header-anchor" href="#GetArrayLength">¶</a>GetArrayLength</h3><p>返回数组长度;</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsize <span class="constructor">GetArrayLength(JNIEnv <span class="operator">*</span><span class="params">env</span>, <span class="params">jarray</span> <span class="params">array</span>)</span>;</span><br></pre></td></tr></table></figure><p>基本数组类型<br>| c++ | jni | 说明 |<br>| := | := | := |<br>| uint8_t/unsigned char | jboolean | unsigned 8 bits |<br>| int8_t/signed char | jbyte | signed 8 bits |<br>| uint16_t/unsigned short | jchar | unsined 16 bits |<br>| int16_t/short | jshort | signed 16 bits |<br>| int32_t/int | jint | signed 32 bits |<br>| int64_t | jlong | signed 64 bits |<br>| float | jfloat | 32-bit IEEE 754 |<br>| double | jdouble | 64-bit IEEE 754 |</p><h3 id="GetArrayElements"><a class="header-anchor" href="#GetArrayElements">¶</a>GetArrayElements</h3><p>返回数组指针，结果一直有效,直至调用的ReleaseArrayElements()函数;<br>调用失败则返回为空;<br>需要注意第三个参数isCopy指针，表示是否返回源数组的拷贝;<br>一般我们不关心是否拷贝原数组，所以设置为null;<br>当isCopy不为null时,如果进行了复制，则isCopy设置为JNI_TRUE; 如果没有复制，则设置为JNI_FALSE。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NativeType *Get&lt;PrimitiveType&gt;<span class="constructor">ArrayElements(JNIEnv <span class="operator">*</span><span class="params">env</span>, ArrayType <span class="params">array</span>, <span class="params">jboolean</span> <span class="operator">*</span><span class="params">isCopy</span>)</span>;</span><br></pre></td></tr></table></figure><p>对于每次调用GetArrayElements，都需要调用ReleaseArrayElements(就像new 和 delete一样成对使用);</p><h3 id="ReleaseArrayElements"><a class="header-anchor" href="#ReleaseArrayElements">¶</a>ReleaseArrayElements</h3><p>释放缓冲区：<br>参数mode为0表示复制回内容并释放缓冲区，JNI_COMMIT表示复制回内容但不释放缓冲区，JNI_ABORT表示释放缓冲区而不复制回可能的更改。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Release&lt;PrimitiveType&gt;<span class="constructor">ArrayElements(JNIEnv <span class="operator">*</span><span class="params">env</span>, ArrayType <span class="params">array</span>, NativeType <span class="operator">*</span><span class="params">elems</span>, <span class="params">jint</span> <span class="params">mode</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="GetArrayRegion"><a class="header-anchor" href="#GetArrayRegion">¶</a>GetArrayRegion</h3><p>将数组内容复制到缓冲区;<br>参数start表示数组需要复制的起始索引;<br>参数len表示需要复制的数组长度;<br>参数buf为目标缓冲区;</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Get&lt;PrimitiveType&gt;<span class="constructor">ArrayRegion(JNIEnv <span class="operator">*</span><span class="params">env</span>, ArrayType <span class="params">array</span>, <span class="params">jsize</span> <span class="params">start</span>, <span class="params">jsize</span> <span class="params">len</span>, NativeType <span class="operator">*</span><span class="params">buf</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="SetArrayRegion"><a class="header-anchor" href="#SetArrayRegion">¶</a>SetArrayRegion</h3><p>从缓冲区中复制回原始数组的某个区域;<br>参数buf为源缓冲区;</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Set&lt;PrimitiveType&gt;<span class="constructor">ArrayRegion(JNIEnv <span class="operator">*</span><span class="params">env</span>, ArrayType <span class="params">array</span>, <span class="params">jsize</span> <span class="params">start</span>, <span class="params">jsize</span> <span class="params">len</span>, <span class="params">const</span> NativeType <span class="operator">*</span><span class="params">buf</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="字符串使用"><a class="header-anchor" href="#字符串使用">¶</a>字符串使用</h2><p>jni通过jstring在java和c<ins>中传递字符串;<br>Java默认使用Unicode编码，C/C</ins> 默认使用UTF编码，而JNI支持字符串在Unicode和UTF-8两种编码之间转换；<br>使用GetStringUTFChars 可以把一个 jstring 指针(指向JVM内部的Unicode字符序列)转换成一个UTF-8格式的C字符串。<br>关于GetStringUTFChars第三个参数iscopy，同上文所述，一般不关心其返回值，所以一般填null;<br>当iscopy不为null时：如果iscopy=JNI_TRUE则表示返回 JVM 内部源字符串的一份拷贝，并为新产生的字符串分配内存空间;<br>如果iscopy=JNI_FALSE则返回 JVM 内部源字符串的指针(不推荐，遵循java字符串不可修改的规定);</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">char</span>* <span class="constructor">GetStringUTFChars(<span class="params">jstring</span> <span class="params">string</span>, <span class="params">jboolean</span><span class="operator">*</span> <span class="params">isCopy</span>)</span></span><br><span class="line">&#123; return functions-&gt;<span class="constructor">GetStringUTFChars(<span class="params">this</span>, <span class="params">string</span>, <span class="params">isCopy</span>)</span>; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与GetArrayElements相同，用完需要释放，使用ReleaseStringUTFChars释放字符串;</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void <span class="constructor">ReleaseStringUTFChars(<span class="params">jstring</span> <span class="params">string</span>, <span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">utf</span>)</span></span><br><span class="line">&#123; functions-&gt;<span class="constructor">ReleaseStringUTFChars(<span class="params">this</span>, <span class="params">string</span>, <span class="params">utf</span>)</span>; &#125;</span><br></pre></td></tr></table></figure><p>不用怕不好记，反正用了 GetXXX 就必须调用 ReleaseXXX ~<s>///(<sup>v</sup>)\~</s>。</p><h2 id="异常抛出"><a class="header-anchor" href="#异常抛出">¶</a>异常抛出</h2><p>程序如果在运行期间没有按正常的程序逻辑执行，出现了错误，就会导致程序崩溃。</p><p>在java中如果觉得某段逻辑可能引发异常,使用try…catch捕获异常即可;如果发生了异常，程序回直接崩溃退出，不会执行后续代码。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">        <span class="built_in">sayHello</span>();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e<span class="selector-class">.printStackTrace</span>();</span><br></pre></td></tr></table></figure><p>jni没有try…catch…final异常处理机制，并且如果jni中发生了异常，不会立即停止执行，而是会继续执行后续代码；<br>所以需要将异常抛出给java:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">char</span> *hello = (*env).<span class="constructor">GetStringUTFChars(<span class="params">hello_str</span>, <span class="params">nullptr</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (hello<span class="operator"> == </span>null) &#123; <span class="comment">/* 异常检查 */</span></span><br><span class="line">        env-&gt;<span class="constructor">ThrowNew(<span class="params">env</span>-&gt;FindClass(<span class="string">&quot;java/lang/Exception&quot;</span>)</span>, <span class="string">&quot;GetStringUTFChars fail.&quot;</span>);<span class="comment">// 发生异常后释放前面所分配的内存</span></span><br><span class="line">        return; </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>比较常见的就是由于内存不足导致的JNI调用异常:<br>通常调用GetXX，NewXXX函数时回分配内存，所以调用后需要进行异常检查;<br>如果发生了异常，则抛出异常并释放前面分配的内存。</p><p>关于内存，除了调用JNI函数可能需要分配内存，更明显的例如：<br>使用new,new[&amp;#93,malloc,calloc等C语言函数分配内存，要记得使用进行初始化，防止混入脏数据，并且用完后记得使用delete,delete[&amp;#93,free进行回收。</p><h2 id="日志打印"><a class="header-anchor" href="#日志打印">¶</a>日志打印</h2><p>通过使用android自带的log打印输出信息到LOGCAT中，方便调试。<br>对于java代码的log，只需要引入log包，然后使用log.e,log.w,log.v,log.i,log.d等函数</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.<span class="keyword">Log</span></span><br><span class="line"></span><br><span class="line">final <span class="keyword">public</span> <span class="built_in">Boolean</span> isEng =Build.<span class="keyword">TYPE</span>.<span class="keyword">equals</span>(<span class="string">&quot;eng&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isEng)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">Log</span>.v(“LOG_TAG”,“LOG_MESSAGE”);</span><br></pre></td></tr></table></figure><p>对于jni可以使用Android的日志库;</p><h3 id="编辑CmakelLists-txt"><a class="header-anchor" href="#编辑CmakelLists-txt">¶</a>编辑CmakelLists.txt</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_library</span>( <span class="comment"># Sets the name of the path variable.</span></span><br><span class="line">        log-lib</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Specifies the name of the NDK library that</span></span><br><span class="line">        <span class="comment"># you want CMake to locate.</span></span><br><span class="line">        log)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>( <span class="comment"># Specifies the target library.</span></span><br><span class="line">        xxx</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Links the target library to the log library</span></span><br><span class="line">        <span class="comment"># included in the NDK.</span></span><br><span class="line">        <span class="variable">$&#123;log-lib&#125;</span>)</span><br></pre></td></tr></table></figure><h3 id="添加log-h"><a class="header-anchor" href="#添加log-h">¶</a>添加log.h</h3><p>app/src/main/cpp-&gt;New c++ header;</p><p>这里主要使用了&lt;android/log.h&gt;中的__android_log_print函数，使用方法和printf差不多;<br>第一个参数时打印的级别:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef enum <span class="keyword">android_LogPriority </span>&#123;</span><br><span class="line">  <span class="comment">/** For internal use only.  */</span></span><br><span class="line">  <span class="keyword">ANDROID_LOG_UNKNOWN </span>= <span class="number">0</span>,</span><br><span class="line">  <span class="comment">/** The default priority, for internal use only.  */</span></span><br><span class="line">  <span class="keyword">ANDROID_LOG_DEFAULT, </span><span class="comment">/* only for SetMinPriority() */</span></span><br><span class="line">  <span class="comment">/** Verbose logging. Should typically be disabled for a release apk. */</span></span><br><span class="line">  <span class="keyword">ANDROID_LOG_VERBOSE,</span></span><br><span class="line"><span class="keyword"></span>  <span class="comment">/** Debug logging. Should typically be disabled for a release apk. */</span></span><br><span class="line">  <span class="keyword">ANDROID_LOG_DEBUG,</span></span><br><span class="line"><span class="keyword"></span>  <span class="comment">/** Informational logging. Should typically be disabled for a release apk. */</span></span><br><span class="line">  <span class="keyword">ANDROID_LOG_INFO,</span></span><br><span class="line"><span class="keyword"></span>  <span class="comment">/** Warning logging. For use with recoverable failures. */</span></span><br><span class="line">  <span class="keyword">ANDROID_LOG_WARN,</span></span><br><span class="line"><span class="keyword"></span>  <span class="comment">/** Error logging. For use with unrecoverable failures. */</span></span><br><span class="line">  <span class="keyword">ANDROID_LOG_ERROR,</span></span><br><span class="line"><span class="keyword"></span>  <span class="comment">/** Fatal logging. For use when aborting. */</span></span><br><span class="line">  <span class="keyword">ANDROID_LOG_FATAL,</span></span><br><span class="line"><span class="keyword"></span>  <span class="comment">/** For internal use only.  */</span></span><br><span class="line">  <span class="keyword">ANDROID_LOG_SILENT, </span><span class="comment">/* only for SetMinPriority(); must be last */</span></span><br><span class="line">&#125; <span class="keyword">android_LogPriority;</span></span><br></pre></td></tr></table></figure><p>第二个参数是LOGTAG，可以定义宏为工程名;<br>最后一个参数是用__VA_ARGS__(可变参数宏):<br>把参数传递给宏LOGD，宏定义展开后，实际的参数就传给_android_log_print了;</p><p>如果只是想简单的打印出错信息就可以这样定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGTAG <span class="string">&quot;test&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)</span></span><br></pre></td></tr></table></figure><p>如果要打印详细信息，则需要添加format:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="constructor">LOG_ERROR(<span class="params">format</span>,<span class="operator">...</span>)</span> <span class="constructor">__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, <span class="string">&quot;function: %s, line: %d &quot;</span> <span class="params">format</span>, <span class="params">__FUNCTION__</span>,<span class="params">__LINE__</span>, ##<span class="params">__VA_ARGS__</span>)</span></span><br></pre></td></tr></table></figure><p>上面就是打印了出错的函数名和行号，注意在C++中当可变参数个数为0时，需要使用##号将前面的逗号去掉，才能正确打印。</p><h2 id="AS项目编译"><a class="header-anchor" href="#AS项目编译">¶</a>AS项目编译</h2><h3 id="so文件编译"><a class="header-anchor" href="#so文件编译">¶</a>so文件编译</h3><p>差不多完成项目的开发后，就可以试着编译一下了;<br>通过Build-&gt;select build variants选择编译debug或release;<br>点击Build-&gt;make project进行编译，编译后的so文件存放在app/build/intermediates/cmake下</p><h3 id="so文件的使用（java层）"><a class="header-anchor" href="#so文件的使用（java层）">¶</a>so文件的使用（java层）</h3><p>对于编好的so文件，如何在Android工程中使用他们呢(・∀・(・∀・(・∀・*)</p><p>1.拷贝上面编好的项目中app/build/intermediates/cmake/debug(relaese)/obj/arm64-v8a(armebi,x86,x86_64)文件夹放入新工程的app/libs下</p><p>2.修改build.gradle(:app)</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">android</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">defaultConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">ndk</span> &#123;</span><br><span class="line">            abiFilters <span class="symbol">&#x27;arm64</span><span class="operator">-</span>v8a&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">sourceSets</span> &#123;</span><br><span class="line">        <span class="keyword">main</span> &#123;</span><br><span class="line">            jniLibs.srcDirs <span class="operator">=</span> [<span class="symbol">&#x27;libs</span>&#x27;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.新建java类test，确保包名(com.example.hello),函数名(sayHello)和so文件中的一致;</p><p>4.在活动中调用:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.hello.test</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        test jnitest = <span class="keyword">new</span> test();  </span><br><span class="line">test.sayHello() </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 平台-android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> jni </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>针对一种新型Modbus Dos攻击的讨论</title>
      <link href="/2023/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Modbus%20DOS%E6%94%BB%E5%87%BB/"/>
      <url>/2023/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Modbus%20DOS%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<p>工作一个周，摸鱼一个周，摩尔庄园也玩腻了，在much哥哥的诱惑下开始建立自己的博客。平时就记录一些学习的新知识和生活上的小乐趣，yey!</p><span id="more"></span><h2 id="WORK"><a class="header-anchor" href="#WORK">¶</a>WORK</h2><h3 id="Modbus-学习情况"><a class="header-anchor" href="#Modbus-学习情况">¶</a>Modbus 学习情况</h3><p>Modbus协议广泛用于工控系统（ICS/SCADA）上，主要分为Modbus TCP、Modbus RTU、Modbus ASCⅡ。目前学习的是Modbus TCP。</p><h4 id="Modbus-TCP包结构"><a class="header-anchor" href="#Modbus-TCP包结构">¶</a>Modbus TCP包结构</h4><p><img src="/../pic/Modbus%20TCP%20structure.png" alt="img"></p><p>Modbus TCP包最大为260字节：其中，MBAP报头占7字节，PDU最大可占252字节。<br>MBAP报头：事务处理ID 2字节，协议ID 2字节，长度2字节<br>PDU：单位ID 1字节，功能码 1字节，数据部分最大252字节</p><h4 id="poster2022-Wheels-on-the-Modbus-Attacking-ModbusTCP-Communications"><a class="header-anchor" href="#poster2022-Wheels-on-the-Modbus-Attacking-ModbusTCP-Communications">¶</a>poster2022-Wheels on the Modbus - Attacking ModbusTCP Communications</h4><p>师兄发的poster</p><p><strong>1.关注点</strong><br>Modbus TCP协议及漏洞<br>攻击：Mimt、Dos、未授权的访问攻击<br><strong>2.演示工具</strong><br>Mobdus服务器仿真工具：Modbuspal<br>wireshark<br>scapy<br><strong>3.创新点</strong><br>利用包寄存器构造flood<br><strong>4.试验台</strong><br>实验试验台由西门子标志PLC、温度和湿度传感器组成。<br>温度和湿度的值被不断地读取和实时显示在HMI上。<br>这些传感器都是硬连接到西门子LogoPLC的，而PLC使用ModbusTCP将这些值实时通信到HMI。<br>温度值存储在保持寄存器中，而湿度值存储在输入寄存器中。<br>HMI分别使用Modbus函数代码0x03（读取保持寄存器）和0x04（读取输入寄存器）定期轮询西门子LogoPLC的温度和湿度值。<br><strong>度量标准</strong>：通讯时间<br>一个查询-响应-攻击循环大约7 ms，在循环之间大约100 ms（100 ms是用于编写和注入我们的恶意数据包到网络的时间段）<br><strong>5.手段</strong><br>修改MBAP标头的长度字段（长度+2）<br>PDU层中加2个附加字段（4字节）<br>注入<br><strong>6.实验结果</strong><br>现场洪水攻击有效地迫使PLC进入只听模式约7分钟，最终达到DoS场景</p><p><strong>小结论</strong><br>这篇论文中通过轮询两个寄存器来模拟HMI和PLC之间的通讯（一般两者间的ModbusTCP通信是连续循环的）；实验中修改PDU报头中的长度字段（长度字段占2字节，数值范围0-2^16）使长度数值＋2，就有可能使Modbus ADU超出最大260字节，但长度字段未超出数值范围，最终导致通信中断，实现Dos攻击。<br>这类针对设备的Dos攻击一般都是发包，效果极其明显；目前需要研究的是能否实现对单个寄存器写操作的DOS攻击（使用smod框架）……</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dos </tag>
            
            <tag> Modbus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android从0开发（一）</title>
      <link href="/2023/03/22/%E5%B9%B3%E5%8F%B0-android/android%E4%BB%8E0%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/03/22/%E5%B9%B3%E5%8F%B0-android/android%E4%BB%8E0%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>开发安卓平台(ˉ▽ˉ;)…<br>痛苦至极，踩了好多坑/(ㄒoㄒ)/~~</p><h2 id="开发流程"><a class="header-anchor" href="#开发流程">¶</a>开发流程</h2><p>对于在安卓平台的开发，考虑进行以下过程<br>1)安装依赖库<br>2)gmssl在安卓平台的安装<br>3)工程调用c++源码并进行调试<br>4)安卓程序细节调整<br>5)导出工程文件</p><h2 id="环境配置"><a class="header-anchor" href="#环境配置">¶</a>环境配置</h2><p><strong>开发环境</strong><br>Vmware workstation<br>ubuntu 22.04</p><p><strong>开发平台</strong><br>Android studio</p><p><strong>依赖库</strong><br>sodium<br>gmssl</p><p><strong>调试</strong><br>真机调试</p><h2 id="android-studio安装"><a class="header-anchor" href="#android-studio安装">¶</a>android studio安装</h2><h3 id="安装jdk："><a class="header-anchor" href="#安装jdk：">¶</a>安装jdk：</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> update</span><br><span class="line">sudo apt-<span class="built_in">get</span><span class="built_in"> upgrade</span></span><br><span class="line"><span class="built_in"></span>sudo apt-<span class="built_in">get</span> install default-jre</span><br><span class="line">sudo apt-<span class="built_in">get</span> install default-jdk</span><br></pre></td></tr></table></figure><p>Android studio的安装有以下三种方法(亲测)<br>法一：apt在线安装<br>法二：官网下载直接安装<br>法三：源码安装</p><h3 id="apt在线安装"><a class="header-anchor" href="#apt在线安装">¶</a>apt在线安装</h3><p>终端输入以下命令;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:maarten-fonville/android-studio</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install android-studio</span><br></pre></td></tr></table></figure><p>如果报错缺少公钥，则&quot;apt-key adv --keyserver <a href="http://keyserver.ubuntu.com">keyserver.ubuntu.com</a> --recv-keys 问题提示的公钥&quot;;</p><p>添加快捷方式:<br>‘sudo ln -s /opt/android-studio/bin/studio.sh /usr/bin/AndroidStudio’<br>在终端输入AndroidStudio或者在应用中点击图标都可以运行Android studio;</p><h3 id="官网下载直接安装"><a class="header-anchor" href="#官网下载直接安装">¶</a>官网下载直接安装</h3><p>安装jdk;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get install default-jre</span><br><span class="line">sudo apt-get install default-jdk</span><br></pre></td></tr></table></figure><p><a href="https://developer.android.google.cn/studio/#downloads">下载</a> 压缩包;</p><p>解压，sudo  ./studio.sh运行;</p><h3 id="源码安装"><a class="header-anchor" href="#源码安装">¶</a>源码安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https://redirector.gvt1.com/edgedl/android/studio/ide-zips/2021.1.1.22/android-studio-2021.1.1.22-linux.tar.gz</span><br></pre></td></tr></table></figure><p><em>ps:如果是虚拟机安装，最好把运行内存和分配的磁盘空间大一点(eg:8G 60G),AndroidStudio太大了会卡。不建议使用双核，处理器数量增多可能导致VMware变卡。</em></p><h2 id="调试"><a class="header-anchor" href="#调试">¶</a>调试</h2><p>本意是使用Android Studio自带的模拟器，但是很卡，这里使用真机调试</p><h3 id="使用adb连接手机"><a class="header-anchor" href="#使用adb连接手机">¶</a>使用adb连接手机</h3><p>当然除了使用模拟器外，还可以通过usb或者wifi连接实体机;</p><p>1)lsusb 查看usb;<br>“Bus 001 Device 022: ID xxxx:XXXX Google Inc. MI 8”</p><p>2)修改文件<br>sudo gedit /etc/udev/rules.d/51-android.rules<br>“SUBSYSTEM==“usb”, ATTR{idVendor}==“xxxx”, ATTRS{idProduct}==“XXXX”, MODE=“0666”, GROUP=“plugdev””</p><p>3)授权<br>sudo chmod a+rx /etc/udev/rules.d/51-android.rules</p><p>4)连接<br>sudo service udev restart<br>sudo udevadm trigger<br>adb kill-server<br>adb start-server<br>adb devices</p><p>总之，这样安卓模拟器就安装好了，</p><h3 id="使用usb连接真机"><a class="header-anchor" href="#使用usb连接真机">¶</a>使用usb连接真机</h3><p>虚拟机-&gt;可移动设备-&gt;连接；</p><p>打开Android Studio，可以看到真机在devices manager的physical device板块;</p><h2 id="sodium-android编译"><a class="header-anchor" href="#sodium-android编译">¶</a>sodium-android编译</h2><p>由于多数真机的cpu架构是arm64-v8a，所以这里编译的是android-arm64-v8a的libsodium库~</p><h3 id="下载项目："><a class="header-anchor" href="#下载项目：">¶</a>下载项目：</h3><p><a href="https://github.com/jedisct1/libsodium.git">libsodium项目</a></p><p>经过一系列操作，得到了一个文件夹&quot;libsodium-XXX&quot;，<a href="http://xn--androidlibsodium-h310ay26adj8lpyra.so">内含android版的libsodium.so</a>;<br>接下来进行依赖库的调用。</p><h2 id="Android-Studio调用so（C-层面）"><a class="header-anchor" href="#Android-Studio调用so（C-层面）">¶</a>Android Studio调用so（C++层面）</h2><p>首先打开Android studio，新建native c++工程;<br>第一次打开需要下载很多包，时间可能长一点，耐心等待(<em><sup>_</sup></em>)</p><h3 id="libsodium-so调用"><a class="header-anchor" href="#libsodium-so调用">¶</a>libsodium.so调用</h3><p>打开native c++工程;填写NDK安装位置(File-&gt;Project Structures:Android NDK location);<br>如果输入框无法填写，则修改项目的local.properties文件&quot;ndk.dir=/home/Android/Sdk/ndk/23.1.7779620&quot;<br>在app/src/main下新建jniLibs，把第三方so库放入jniLibs;</p><p><strong>修改Cmakelist.txt</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(sodium</span><br><span class="line">        SHARED</span><br><span class="line">        IMPORTED)</span><br><span class="line"><span class="keyword">set_target_properties</span>( sodium</span><br><span class="line">        PROPERTIES IMPORTED_LOCATION</span><br><span class="line">        <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/../jniLibs/libsodium.so)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>( <span class="comment"># Specifies the target library.</span></span><br><span class="line">        XXX</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Links the target library to the log library</span></span><br><span class="line">        <span class="comment"># included in the NDK.</span></span><br><span class="line">        sodium</span><br><span class="line">        <span class="variable">$&#123;log-lib&#125;</span>)</span><br></pre></td></tr></table></figure><p><strong>修改app/build.gradle</strong><br>配置 ndk 指定 ABI</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">android</span> &#123;</span><br><span class="line">    <span class="keyword">defaultConfig</span> &#123;</span><br><span class="line">        <span class="keyword">ndk</span> &#123;</span><br><span class="line">            abiFilters <span class="symbol">&#x27;arm64</span><span class="operator">-</span>v8a&#x27;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，编译过后，将项目目录切换至Android试图，可以看到，app目录下多了一个jniLibs文件夹，里面包含了引入的so文件和jar包，表示集成成功。</p><p>奇奇怪怪，这种方式我在win10、ubuntu2004(VM虚拟机)、mint2001(VM虚拟机)的Android Studio上都试过，都是可行的;<br>但是ubuntu2204(virtualbox)上编译build.grade时出现了怪怪的警告,所以按照要求删除local.properties文件中的ndk.dir，在setting中添加ndk版本;</p><h2 id="Android-C-开发"><a class="header-anchor" href="#Android-C-开发">¶</a>Android C++开发</h2><p>配置好依赖的so库之后，就可以调用写好的C++文件了;</p><h3 id="android-studio调用C-文件"><a class="header-anchor" href="#android-studio调用C-文件">¶</a>android studio调用C++文件</h3><p>c++文件的导入很简单，将源文件和头文件放入文件夹app/src/main/cpp;</p><p><strong>修改Cmakelist</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>( <span class="comment"># Sets the name of the library.</span></span><br><span class="line">        XXX</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Sets the library as a shared library.</span></span><br><span class="line">        SHARED</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Provides a relative path to your source file(s).</span></span><br><span class="line">        native-lib.cpp<span class="comment">#源文件)</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span><span class="comment">#头文件位置)</span></span><br></pre></td></tr></table></figure><h3 id="java-与-c-数据类型对应"><a class="header-anchor" href="#java-与-c-数据类型对应">¶</a>java 与 c++ 数据类型对应</h3><p>Android下jni所用的数据结构和c++不同；需要进行转化;</p><p><strong>转化对应关系如下</strong></p><table><thead><tr><th style="text-align:left">c++</th><th style="text-align:left">java</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">char</td><td style="text-align:left">byte</td><td style="text-align:left">8位整数</td></tr><tr><td style="text-align:left">char*</td><td style="text-align:left">String</td><td style="text-align:left">\0结尾的字符数组</td></tr><tr><td style="text-align:left">char**</td><td style="text-align:left">String[ ]</td><td style="text-align:left">字符串数组</td></tr><tr><td style="text-align:left">short</td><td style="text-align:left">short</td><td style="text-align:left">16位整数</td></tr><tr><td style="text-align:left">int</td><td style="text-align:left">int</td><td style="text-align:left">32位整数</td></tr><tr><td style="text-align:left">long long,_int64</td><td style="text-align:left">long</td><td style="text-align:left">64位整数</td></tr><tr><td style="text-align:left">float</td><td style="text-align:left">float</td><td style="text-align:left">32位浮点数</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">double</td><td style="text-align:left">64位浮点数</td></tr><tr><td style="text-align:left">struct*/struct</td><td style="text-align:left">Structure</td><td style="text-align:left">结构体数据</td></tr><tr><td style="text-align:left">(&amp;#42fp)[ ]</td><td style="text-align:left">Callback</td><td style="text-align:left">函数指针</td></tr></tbody></table><p>此外，Android中使用char有大坑，Android下的char默认是unsigned char;<br>要想用char类型,得显式的定义为 singed char c = -1.</p><p>开发目标：实现页面添加一个按钮，点击后进行连接，可实现函数某些功能等，再次点击则断开连接;<br>这里需要编写java活动，下一章再搞！</p>]]></content>
      
      
      <categories>
          
          <category> 平台-android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> android studio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qt开发--实战</title>
      <link href="/2023/03/13/qt%E5%BC%80%E5%8F%91/qt%E5%BC%80%E5%8F%91--%E5%AE%9E%E6%88%98/"/>
      <url>/2023/03/13/qt%E5%BC%80%E5%8F%91/qt%E5%BC%80%E5%8F%91--%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a class="header-anchor" href="#目标">¶</a>目标</h2><p>实现目标：<br>1)增加模式：<br>定向出国，定向回国，组网模式;<br>2)去掉shell文件的使用:(脚本变函数)<br>定向加速 — 远程路由组<br>组网 — 静态路由<br>3)优化布局<br>消息输出到label中;<br>按钮的美化;<br>模式选择;</p><p>增加一个主窗口，包含三种组网模式:<br>如果是定向加速–&gt;跳转到myWidget窗口–&gt;start_vpn调用远程路由配置函数;<br>如果是组网–&gt;打开输入框(请输入静态ip)–&gt;组网函数;</p><h2 id="初步搭建"><a class="header-anchor" href="#初步搭建">¶</a>初步搭建</h2><h3 id="调用动态链接库"><a class="header-anchor" href="#调用动态链接库">¶</a>调用动态链接库</h3><p>1)新建QT Widgets Application工程(myWidget)，选择QWidget类;</p><p>2)引入工程文件(en)动态链接库:<br>将工程项目编译成动态链接库;(编写makefile,CFLAGS添加-fPIC -shared，连接时添加 -shared)<br>使用宏编译，对于多个宏，编译的时候可以选择:<br>“make p1=1\make p2=1”<br>myWidget工程右键-&gt;添加库-&gt;外部库-&gt;选择库文件-&gt;添加;</p><p>3)修改myWidget.pro文件:<br>添加qt组件:“QT += concurrent”;<br>添加宏开关:“DEFINES += p1”;<br>添加外部调用路径:&quot;INCLUDEPATH += /root/qt/en/include &quot;;</p><h3 id="框架设计"><a class="header-anchor" href="#框架设计">¶</a>框架设计</h3><h4 id="添加按钮"><a class="header-anchor" href="#添加按钮">¶</a>添加按钮:</h4><pre><code>  双击myWidget.ui文件，添加两个pushButton，修改类名为startButton、stopButton，修改按钮text为ustart、stop;  (此时需要先编译一次，生成build_myWidget_XXX_debug文件夹，包含ui生成的ui_myWidget.h头文件)</code></pre><h4 id="添加槽声明"><a class="header-anchor" href="#添加槽声明">¶</a>添加槽声明:</h4><p>myWidget.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">conn</span><span class="params">()</span></span>;          <span class="comment">//startButton连接函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disconn</span><span class="params">()</span></span>;       <span class="comment">//startButton连接函数</span></span><br></pre></td></tr></table></figure><p>myWidget.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">myWidget::<span class="built_in">myWidget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::myWidget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;startButton,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;myWidget::conn);     </span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;stopButton,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;myWidget::disconn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myWidget::conn</span><span class="params">()</span>    <span class="comment">//槽函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">start</span>(sn_verify_pk,uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myWidget::disconn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">stop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理函数输入"><a class="header-anchor" href="#处理函数输入">¶</a>处理函数输入:</h4><p>add New-&gt;c class 添加c++类;<br>使用宏设置输入<br>stdafx.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SN_VERIFY_PK            <span class="string">&quot;04123456789XXXX&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SN_VERIFY_PK            <span class="string">&quot;123456789&quot;</span></span></span><br></pre></td></tr></table></figure><pre><code> 从函数中获取作为输入   int get_uuid(const char *cmd, int buf_size, char *result);</code></pre><h4 id="设置连接状态（已连接、未连接）"><a class="header-anchor" href="#设置连接状态（已连接、未连接）">¶</a>设置连接状态（已连接、未连接）</h4><p>添加bool型指针m_isConnected，监控连接状况;</p><p>myWidget.h 中添加私有指针&quot;std::atomic_bool m_isConnected;&quot;</p><p>myWidget.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myWidget::conn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_isConnected)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">showlabel</span>(<span class="built_in">QStringLiteral</span>(<span class="string">&quot;请先断开连接！&quot;</span>));  <span class="meta">#start之前判断是否已连接</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="built_in">start</span>(sn_verify_pk,uuid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="监控程序运行状态"><a class="header-anchor" href="#监控程序运行状态">¶</a>监控程序运行状态</h4><p>添加自定义状态监控指针:<br>m_startResultwatcher //监控start()程序运行状态<br>m_stopResultwatcher  //监控stop()程序运行状态</p><p>myWidget.h添加私有指针<br>&quot;<br>QFutureWatcher&lt;en_state_t&gt;* m_startResultwatcher;   //start()函数返回en_state_t型指针<br>QFutureWatcher<void>* m_stopResultwatcher;   //stop()返回void<br>&quot;</void></p><p>myWidget.cpp<br>添加错误状态;</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;ENstate_t, QString&gt; g_errmsg</span><br><span class="line">&#123;</span><br><span class="line">    &#123; NO_RESPONSE, <span class="built_in">QStringLiteral</span>(<span class="string">&quot;未响应......&quot;</span>) &#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>添加监控状态返回函数;</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">void</span> <span class="variable">myWidget</span>::<span class="function"><span class="title">on_Started</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">_state_t</span> <span class="variable"><span class="class">result</span></span> = <span class="variable">m_startResultwatcher</span>-&gt;<span class="function"><span class="title">future</span>().<span class="class">result</span>();</span></span><br><span class="line"><span class="function">        <span class="variable"><span class="keyword">if</span></span> (<span class="variable"><span class="class">result</span></span> <span class="variable">!</span>= <span class="variable">OK</span>) &#123;</span></span><br><span class="line"><span class="function">            <span class="title">qCritical</span>() &lt;&lt; <span class="string">&quot;start__service failed, result=&quot;</span> &lt;&lt; <span class="variable"><span class="class">result</span></span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="variable"><span class="keyword">else</span></span> &#123;</span></span><br><span class="line"><span class="function">            <span class="variable">m_isConnected</span> = <span class="variable"><span class="literal">true</span></span>;</span></span><br><span class="line"><span class="function"><span class="title">showlabel</span>(<span class="title">QStringLiteral</span>(<span class="string">&quot;已连接&quot;</span>));</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>连接信号槽;</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">myWidget::myWidget(QWidget *parent)</span><br><span class="line">    : QWidget(parent)</span><br><span class="line">    , ui(<span class="keyword">new</span> Ui::myWidget)</span><br><span class="line">    , m_isConnected(<span class="keyword">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line">m_startResultwatcher = <span class="keyword">new</span> QFutureWatcher&lt;en_state_t&gt;(this);  <span class="comment">//监控start()</span></span><br><span class="line">    connect(ui-&gt;startButton,&amp;QPushButton::clicked,this,&amp;myWidget::conn);</span><br><span class="line">connect(m_startResultwatcher, &amp;QFutureWatcher&lt;<span class="keyword">int</span>&gt;::finished, this, &amp;myWidget::on_Started);   <span class="comment">//返回start()结果给on_Started函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myWidget::conn()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_isConnected)</span><br><span class="line">        &#123;</span><br><span class="line">            showlabel(QStringLiteral(<span class="string">&quot;请先断开连接！&quot;</span>));  #start之前判断是否已连接</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     QFuture&lt;vpn_state_t&gt; result = QtConcurrent::run([=]()-&gt;vpn_state_t</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> start(sn_verify_pk,uuid);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">        m_startResultwatcher-&gt;setFuture(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这一步，编译运行后，点击start按钮:start启动成功，弹出窗口显示&quot;已连接！“;连接失败，显示失败原因;<br>点击stop按钮:stop启动成功，弹出窗口显示&quot;已断开”;断开失败，qdebug显示失败原因;但是不够漂亮，下面进行界面的优化。</p><h2 id="界面优化"><a class="header-anchor" href="#界面优化">¶</a>界面优化</h2><h3 id="设计mainWindow"><a class="header-anchor" href="#设计mainWindow">¶</a>设计mainWindow</h3><p>参考 src/03/3-6 设计框架<br>主窗口选择模式，如果为out/in，则进入widget窗口:按下start按钮，运行start()函数;弹起start按钮，运行stop()函数;点击go back，回到主页面;<br>如果为inner，则弹出输入框，填写后进入widget窗口。</p><h4 id="添加主窗口"><a class="header-anchor" href="#添加主窗口">¶</a>添加主窗口</h4><p>添加c class，选择QMainWindow类,添加mymainwindow的ui文件。<br>编辑mymainwindow.ui文件，添加pushubutton，设置文本显示为mode;右键添加选中槽函数;</p><p>mymainwindow.h中添加class myWidget类声明;<br>添加私有制指针:myWidget* m_myWidget;</p><p>mymainwindow.cpp中添加选中槽函数声明</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void myMainWindow::on<span class="constructor">_pushButton_toggled(<span class="params">bool</span> <span class="params">checked</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(checked)<span class="comment">//如果mode按钮按下</span></span><br><span class="line">    &#123;</span><br><span class="line">    close<span class="literal">()</span>;<span class="comment">//关闭当前窗口</span></span><br><span class="line">    m_myWidget = <span class="keyword">new</span> my<span class="constructor">Widget()</span>;<span class="comment">//新建wmyWidget类窗口</span></span><br><span class="line">    m_myWidget-&gt;show<span class="literal">()</span>;<span class="comment">//显示</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的方法修改mywidget.ui、mywidget.h、mywidget.cpp，添加go back按钮及对应槽。<br><strong>未完</strong><br>参考 src/03/3-7 设计对话框(!!!important)<br>参考 src/03/3-9 设计模式选择模块</p><h3 id="优化widget布局"><a class="header-anchor" href="#优化widget布局">¶</a>优化widget布局</h3><h4 id="通过代码设置样式表"><a class="header-anchor" href="#通过代码设置样式表">¶</a>通过代码设置样式表</h4><p>“ui-&gt;pushButton-&gt;setStyleSheet(“background:green”);”</p><p>调用指定部件setStyleSheet()函数只会对这个部件(pushButton)引用样式表;<br>可以通过设置父部件的样式表，实现对所有相同部件的设置。</p><p>“setStyleSheet(“QPushButton{background:yellow}QSlider{background:blue}”);”</p><p>除了使用代码设置样式表外，也可以在设计模式种为添加到界面上的部件设置样式表。</p><h4 id="在设计模式中设置样式表"><a class="header-anchor" href="#在设计模式中设置样式表">¶</a>在设计模式中设置样式表</h4><p>双击ui文件，右键点击按钮pushButton，选择&quot;改变样式表&quot;，添加代码;</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:checked</span> &#123;</span><br><span class="line">  <span class="comment">/*设置选中时按钮的样式*/</span></span><br><span class="line"><span class="attribute">background-color</span>:green</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">QPushButton:!checked &#123;</span><br><span class="line">  <span class="comment">/*设置未选中时按钮的样式*/</span></span><br><span class="line"><span class="attribute">background-color</span>:white</span><br><span class="line">&#125;</span><br><span class="line">QPushButton<span class="selector-pseudo">:disabled</span> &#123;</span><br><span class="line">  <span class="comment">/*设置禁用时按钮的样式*/</span></span><br><span class="line">&#125;</span><br><span class="line">QPushButton<span class="selector-pseudo">:checked</span><span class="selector-pseudo">:disabled</span> &#123;</span><br><span class="line">  <span class="comment">/*设置选中并且禁用时按钮的样式*/</span></span><br><span class="line">&#125;</span><br><span class="line">QPushButton:pressed &#123;</span><br><span class="line">  <span class="comment">/*设置点击按钮时按钮的样式*/</span></span><br><span class="line">&#125;</span><br><span class="line">QPushButton<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="comment">/*设置鼠标悬浮在按钮上的样式*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>彩虹色太少不够选？没关系，可以选择自定颜色。点击&quot;添加颜色”，选择颜色，修改代码;<br>“QPushButton:checked {<br>background-color:rgb(253, 222, 255);<br>}”<br>甚至可以选择渐变色！！<br>“QPushButton:!checked {<br>background-color:qlineargradient(spread:pad, x1:0, y1:0, x2:1, y2:1, stop:0 rgba(136, 233, 255, 242), stop:1 rgba(255, 255, 255, 255));<br>}”</p><h4 id="自定义样式"><a class="header-anchor" href="#自定义样式">¶</a>自定义样式</h4><p>上面的方法都不够花里胡哨，可以自定义qss；在项目文件中添加资源文件，直接调用;<br>添加Qt资源文件;打开资源编辑器，添加前缀images,qss,js。</p><p><strong>设置背景</strong><br>直接使用制作好的背景图片<a href="http://thepatternlibrary.com/">这里</a> 背景花里胡哨的，很好看但是种类少;<br>使用svg图片做背景<a href="https://heropatterns.com/">这里</a> 是我最爱的perple;<br>纯手工制作背景<a href="https://www.iconfont.cn/">矢量图标库</a> 下载喜欢的图标(svg)，然后在<a href="https://patterninja.com/">这里</a> 手工制作背景图；</p><p>把选好的背景图片(orange.png)放在项目文件下，前缀images右键添加orange.png;</p><p>Qt样式表可以存放在.qss文件中，add New-&gt;Gneneral-&gt;Empty File 新建mywidget.qss，然后就可以添加自定义样式了。</p><p><strong>设计按钮</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> QPushButton<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>:  <span class="number">#b4a7d6</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>布局设计</strong></p><p><strong>未完</strong></p>]]></content>
      
      
      <categories>
          
          <category> qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qt开发-信号槽和样式表</title>
      <link href="/2023/03/06/qt%E5%BC%80%E5%8F%91/qt%E5%BC%80%E5%8F%91-3/"/>
      <url>/2023/03/06/qt%E5%BC%80%E5%8F%91/qt%E5%BC%80%E5%8F%91-3/</url>
      
        <content type="html"><![CDATA[<p>最近使用按钮很多，本节学习一下按钮的一些用法。</p><h2 id="信号槽"><a class="header-anchor" href="#信号槽">¶</a>信号槽</h2><h3 id="信号和槽"><a class="header-anchor" href="#信号和槽">¶</a>信号和槽</h3><p>信号和槽都是函数，对于一个窗口中的按钮，我们期望实现点击按钮后可以调用某个函数，此时就用到了信号槽。</p><p>例：src/03/3-4<br><strong>目标</strong><br>单击按钮弹出对话框。</p><p><strong>实现</strong><br>ui界面添加Push Button(start、stop)，修改窗口类属性名;</p><p>头文件添加槽声明:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">showconn</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">showdisconn</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>cpp添加槽的实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>();</span><br><span class="line">label-&gt;<span class="built_in">setText</span>(QObject::<span class="built_in">tr</span>(<span class="string">&quot;Connect.&quot;</span>));</span><br><span class="line">label-&gt;<span class="built_in">resize</span>(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">label-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure><p>更改窗口构造函数:<br>“connect(ui-&gt;startButton, &amp;QPushButton::clicked,this, &amp;MyWidget::showconn);”<br>//使用connect()函数将单击信号clicked()与新建的槽进行关联,参数(发射信号的对象，发射的信号，接收信号的对象，要执行的槽);</p><h3 id="自定义对话框"><a class="header-anchor" href="#自定义对话框">¶</a>自定义对话框</h3><p><strong>未完</strong></p><h2 id="样式"><a class="header-anchor" href="#样式">¶</a>样式</h2><h3 id="Qt样式表语法"><a class="header-anchor" href="#Qt样式表语法">¶</a>Qt样式表语法</h3><p>Qt样式表的术语和语法规则和HTML CSS基本相同，可以通过The Style Sheet Syntax关键字在帮助中查看详细讲解。</p><h4 id="样式规则"><a class="header-anchor" href="#样式规则">¶</a>样式规则</h4><p>样式规则由选择器和声明组成，选择器指明了受该规则影响的部件，声明指明了这个部件上要设置的属性。<br>eg:“QPushButton{color:red}”<br>QPushButton是选择器，{color:red}是声明，其中，color是属性，red是值。这套规则适用于QpushButton和其子类。<br>值得注意的是，Qt样式表中一般不区分大小写，这又类名、对象名、Qt属性名是区分大小写的。</p><p>不同的选择器可以指定相同的声明;<br>eg:“QPushButton,QLabel,QComboBox{color:green}”</p><p>同一的选择器可以指定不同的声明;<br>eg:“QPushButton{color:red,background-color:white)”</p><p>Qt支持的所有属性在关键字Qt Syntax Sheet Reference对应的帮助文档List of Properties中查看。</p><h4 id="选择器类型"><a class="header-anchor" href="#选择器类型">¶</a>选择器类型</h4><p>Qt样式表支持CSS2中定义的所有选择器:</p><table><thead><tr><th style="text-align:left">选择器</th><th style="text-align:left">示例</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">通用选择器</td><td style="text-align:left">*</td><td style="text-align:left">匹配所有部件</td></tr><tr><td style="text-align:left">类型选择器</td><td style="text-align:left">QPushButton</td><td style="text-align:left">匹配QPusButton实例和其子类</td></tr><tr><td style="text-align:left">属性选择器</td><td style="text-align:left">QPushButton[checkable = “true”]</td><td style="text-align:left">匹配QPusButton的属性checkable为true的实例</td></tr><tr><td style="text-align:left">类选择器</td><td style="text-align:left">.QPushButton</td><td style="text-align:left">匹配所有QPushButton实例，但不包含其子类</td></tr><tr><td style="text-align:left">ID选择类</td><td style="text-align:left">QPushButton#startButton</td><td style="text-align:left">匹配QPusButton中对象名为startButton的实例</td></tr><tr><td style="text-align:left">后代选择器</td><td style="text-align:left">QWidget QPushButton</td><td style="text-align:left">匹配所有QWidget中的QPushButton子孙部件</td></tr><tr><td style="text-align:left">孩子选择器</td><td style="text-align:left">QWidget&gt;QPushButton</td><td style="text-align:left">匹配所有QWidget中的QPushButton直接子部件</td></tr></tbody></table><h4 id="子控件"><a class="header-anchor" href="#子控件">¶</a>子控件</h4><p>选择器可以包含子空间来对部件的特定子控件应用规则;<br>eg:<br>“QComboBox::drop=down{image:url(drown.png)}”<br>为QComboBox的下拉按钮设置图片。</p><h4 id="伪状态"><a class="header-anchor" href="#伪状态">¶</a>伪状态</h4><p>选择器可以包含伪状态来限制规则在部件的指定状态上应用。<br>eg:<br>“QPushButton:hover{color:white}”;//鼠标悬停在按钮上时设置按钮颜色为白色<br>“QPushButton:checked{color:green}”;//按钮选中时设置其颜色未绿色<br>“QPushButton:hover:!checked{color:pink}”; //鼠标悬停并且按钮未选中时设置其颜色为粉色</p><h4 id="冲突解决"><a class="header-anchor" href="#冲突解决">¶</a>冲突解决</h4><p>不同的样式对相同的属性规则指定了不同的值会发生冲突;<br>eg:<br>“QPushButton:{color:white}”;<br>“QPushButton# startButton{color:pink}”;<br>解决冲突的原则：特殊的选择器优先，Qt样式表使用CSS2规范来确定规则的特殊性;<br>有伪状态比没有伪状态的优先;如果两个选择器特殊性相同则后面出现的比前面的有限;部件的样式优先于继承的样式表。</p><h4 id="继承"><a class="header-anchor" href="#继承">¶</a>继承</h4><p>使用Qt样式表时，部件不会自动从父部件继承字体和颜色设置。<br>eg:<br>&quot;qApp-&gt;setStyleSheet(“qGroupBox{color:pink})”    //这里QGroupBox的子部件QPushButton不会继承样式，颜色仍然是默认色。</p><p>可以添加不同类型的选择器，实现样式继承。<br>eg:<br>&quot;qApp-setStyleSheet(&quot;qGroupBox, .QComboBox * {color:pink}) &quot;  //这里QGroupBox的所有子部件都会继承样式</p><h4 id="设置QObject属性"><a class="header-anchor" href="#设置QObject属性">¶</a>设置QObject属性</h4><p>可以使用&quot;qproperty-属性名&quot;设置样式表;<br>eg:<br>“Mylabel {qproperty-titleColor: rgb(100,200,100);}”</p><h3 id="自定义部件外观"><a class="header-anchor" href="#自定义部件外观">¶</a>自定义部件外观</h3><h4 id="盒子模型"><a class="header-anchor" href="#盒子模型">¶</a>盒子模型</h4><p>每个部件都可以看作是由内容(content)、填衬(padding)、边框(bordor)、边距(margin)组成的盒子，默认下，padding、bordor、margin值为0;<br>使用background-image指定部件的背景时，默认background-image只在border以内的区域内绘制，可以通过修改backgroung-clip属性更改;</p><p>可以通过修改background-repeat属性，实现用一个比较小的图案重复铺满整个背景;其中，background-origin属性可以指定背景重复的原点;</p><p>background-image不能随部件大小自动缩放，使用border-image实现背景图片随部件大小自动缩放;<br>同时指定了background-image和border-image，会使得border-image绘制在background-image上;</p><p>使用的图片和指定部件大小不匹配时，图片不会平铺或拉伸，可以使用image-position属性设置图片位置。</p><h4 id="自定义部件样式"><a class="header-anchor" href="#自定义部件样式">¶</a>自定义部件样式</h4><p>将要使用的资源文件(js、image、video etc)添加到项目文件中,添加Qt资源文件(add New-&gt;Qt Resource File)，添加前缀(add Perfix)“/image”,添加项目文件下的资源。</p><p><strong>未完</strong></p><h3 id="3-布局管理"><a class="header-anchor" href="#3-布局管理">¶</a>3. 布局管理</h3>]]></content>
      
      
      <categories>
          
          <category> qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qt开发-鼠标事件与进程</title>
      <link href="/2023/03/03/qt%E5%BC%80%E5%8F%91/qt%E5%BC%80%E5%8F%91-2/"/>
      <url>/2023/03/03/qt%E5%BC%80%E5%8F%91/qt%E5%BC%80%E5%8F%91-2/</url>
      
        <content type="html"><![CDATA[<p>继续学习qt开发，学习一下事件和进程，想做点花里胡哨的~~</p><h2 id="事件过滤器"><a class="header-anchor" href="#事件过滤器">¶</a>事件过滤器</h2><p>例：源码 src/06/6-2/myevent<br>mylineedit.cpp定义函数,MyLineEdit的evebt()函数中使用了QEvent的type()函数获取事件类型，如果是键盘按下事件QEvent::KeyPress则输出信息。<br>（event()函数返回bool型操作结果）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyLineEdit::event</span><span class="params">(QEvent *event)</span>  <span class="comment">// 事件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(event-&gt;<span class="built_in">type</span>() == QEvent::KeyPress)</span><br><span class="line">      <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">tr</span>(<span class="string">&quot;MyLineEdit的event()函数&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> QLineEdit::<span class="built_in">event</span>(event);   <span class="comment">// 执行QLineEdit类event()函数的默认操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>widget.cpp添加事件过滤器函数定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Widget::eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span> <span class="comment">// 事件过滤器</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(obj == lineEdit)&#123;           <span class="comment">// 如果是lineEdit部件上的事件</span></span><br><span class="line">      <span class="keyword">if</span>(event-&gt;<span class="built_in">type</span>() == QEvent::KeyPress)</span><br><span class="line">         <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">tr</span>(<span class="string">&quot;Widget的事件过滤器&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> QWidget::<span class="built_in">eventFilter</span>(obj, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在事件过滤器中，先判断事件的对象是不是lineEdit，是则判断事件类型，最后返回QWidget默认的事件过滤器的执行结果。<br>运行结果:“Widget的事件过滤器” “MyLineEdit的event()函数” “MyLineEdit键盘按下事件” “Widget键盘按下事件”;</p><p>事件的传递顺序:<br>（Widget窗口启动，声明MyLineEdit类对象lineEdit，移动位置到坐标(100,100),在Widget上为lineEdit安装事件过滤器)<br>事件进入事件过滤器(Widget部件)，判断事件的对象是不是lineEdit，是则判断事件类型；判断是否为键盘按下事件，返回事件过滤器执行结果；<br>进入焦点部件(lineEdit部件)的event(),获取事件类型，如果是键盘按下事件QEvent::KeyPress则输出信息，返回event操作结果;<br>进入焦点部件的事件处理函数(keyPressEvent)，如果焦点部件忽略了该事件(“event-&gt;ignore();”)，则执行父部件的事件处理函数。</p><h2 id="鼠标事件和滚轮事件"><a class="header-anchor" href="#鼠标事件和滚轮事件">¶</a>鼠标事件和滚轮事件</h2><h3 id="鼠标事件"><a class="header-anchor" href="#鼠标事件">¶</a>鼠标事件</h3><p>QMouseEvent类用来表示一个鼠标事件，QWheelEvent类用来表示鼠标滚轮事件。<br>例：源码 src/06/6-3/myevent</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QCursor cursor;                 <span class="comment">// 创建光标对象</span></span><br><span class="line">cursor.<span class="built_in">setShape</span>(Qt::OpenHandCursor); <span class="comment">// 设置光标形状</span></span><br><span class="line"><span class="built_in">setCursor</span>(cursor);               <span class="comment">// 使用光标</span></span><br></pre></td></tr></table></figure><p>鼠标指针进入窗口后改为小手形状;</p><h4 id="鼠标按压事件"><a class="header-anchor" href="#鼠标按压事件">¶</a>鼠标按压事件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mousePressEvent</span><span class="params">(QMouseEvent *event)</span> <span class="comment">// 鼠标按下事件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>() == Qt::LeftButton)&#123;      <span class="comment">// 如果是鼠标左键按下</span></span><br><span class="line">      QCursor cursor;</span><br><span class="line">      cursor.<span class="built_in">setShape</span>(Qt::PointingHandCursor);</span><br><span class="line">      QApplication::<span class="built_in">setOverrideCursor</span>(cursor); <span class="comment">// 使鼠标指针暂时改变形状</span></span><br><span class="line">      offset = event-&gt;<span class="built_in">globalPos</span>() - <span class="built_in">pos</span>();   <span class="comment">//获取指针位置(x1,y1)和窗口位置(a1,b1)的差值</span></span><br><span class="line">      <span class="comment">//offset = event-&gt;pos();</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>() == Qt::RightButton)&#123; <span class="comment">// 如果是鼠标右键按下</span></span><br><span class="line">      QCursor <span class="built_in">cursor</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;../mymouseevent/logo.png&quot;</span>));</span><br><span class="line">      QApplication::<span class="built_in">setOverrideCursor</span>(cursor);<span class="comment">// 使用自定义的图片作为鼠标指针</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用globalPos()函数获取鼠标指针位置(在桌面上的位置)，还可以使用QMouseEvent类的pos()函数获取鼠标指针在窗口中的位置;<br>(“offset = event-&gt;pos();”)</p><h4 id="鼠标释放事件"><a class="header-anchor" href="#鼠标释放事件">¶</a>鼠标释放事件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span> <span class="comment">// 鼠标释放事件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">Q_UNUSED</span>(event);</span><br><span class="line">   QApplication::<span class="built_in">restoreOverrideCursor</span>();       <span class="comment">// 恢复鼠标指针形状</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了restoreOverrideCursor()函数恢复鼠标形状，restoreOverrideCursor()函数要和setOverrideCursor()函数配合使用，不然event的参数没有使用到，编译时会出现警告。<br>使用<code>Q_UNUSED(event);</code>语句可以防止警告。</p><h4 id="鼠标移动事件"><a class="header-anchor" href="#鼠标移动事件">¶</a>鼠标移动事件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span> <span class="comment">// 鼠标移动事件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(event-&gt;<span class="built_in">buttons</span>() &amp; Qt::LeftButton)&#123;     <span class="comment">// 这里必须使用buttons()</span></span><br><span class="line">      QPoint temp;</span><br><span class="line">      temp = event-&gt;<span class="built_in">globalPos</span>() - offset;</span><br><span class="line">      <span class="built_in">move</span>(temp);<span class="comment">// 使用鼠标指针当前的位置(x2,y2)减去差值，就得到了窗口应该移动的位置(x2-x1+a1,y2-y1+b1)</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鼠标移动时会检测所有按下的键，此时QMouseEvent的button()函数无法获取被按下的按键；<br>所以使用buttons()函数获取所有按下的键，并与 Qt::LeftButton进行按位与的方法，判断目前鼠标的联合状态中是否包含了鼠标左键。</p><p>如果想不按鼠标按键，也可以获取鼠标移动事件，可以添加代码<code>setMouseTracking(true);</code><br>需要注意：<br>单独一个widgt如果mouseMove不执行需要设置setMouseTracking(true);<br>如果有子窗口，需要子窗口也设置setMouseTracking(true),否则子窗口区域捕获不到鼠标移动;<br>子窗口重写了mouseMoveEvent，需要在函数结尾调用父类的mosueMoveEvent，不然会在子窗口被截获;<br>对于一些特殊的窗口本身就带好几层窗口，需要把每一层都设置setMouseTracking(true);</p><h4 id="鼠标双击事件"><a class="header-anchor" href="#鼠标双击事件">¶</a>鼠标双击事件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mouseDoubleClickEvent</span><span class="params">(QMouseEvent *event)</span> <span class="comment">// 鼠标双击事件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>() == Qt::LeftButton)&#123;          <span class="comment">// 如果是鼠标左键按下</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">windowState</span>() != Qt::WindowFullScreen)     <span class="comment">// 如果现在不是全屏</span></span><br><span class="line">         <span class="built_in">setWindowState</span>(Qt::WindowFullScreen);     <span class="comment">// 将窗口设置为全屏</span></span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">setWindowState</span>(Qt::WindowNoState);      <span class="comment">// 否则恢复以前的大小</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="鼠标滚轮事件"><a class="header-anchor" href="#鼠标滚轮事件">¶</a>鼠标滚轮事件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::wheelEvent</span><span class="params">(QWheelEvent *event)</span>   <span class="comment">// 滚轮事件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(event-&gt;<span class="built_in">delta</span>() &gt; <span class="number">0</span>)&#123;               <span class="comment">// 当滚轮远离使用者时</span></span><br><span class="line">      ui-&gt;textEdit-&gt;<span class="built_in">zoomIn</span>();            <span class="comment">// 进行放大</span></span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;                            <span class="comment">// 当滚轮向使用者方向旋转时</span></span><br><span class="line">      ui-&gt;textEdit-&gt;<span class="built_in">zoomOut</span>();            <span class="comment">// 进行缩小</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用QWheelEvent类delta()函数获取滚轮的距离，每当滚轮旋转一下，默认是15°。当滚轮向使用者方向旋转时，返回正值；当滚轮远离使用者时，返回负值。</p><h2 id="进程的运行"><a class="header-anchor" href="#进程的运行">¶</a>进程的运行</h2><h3 id="进程的运行过程"><a class="header-anchor" href="#进程的运行过程">¶</a>进程的运行过程</h3><p>1)使用start()函数启动一个进程，参数是程序名称和使用的命令行参数;<br>2)执行完start()函数后，OProcess进入Starting状态;程序已经运行后，OProcess进入Running状态并发射started()信号；<br>3)进程退出后，QProcess重新进入NoTRunning状态(初始状态)并发射finished信号。发射的finished信号提供了程序的推出代码和退出状态，使用exitCode()和exitStatus()获取。<br>4)任何时间发生了错误，QProcess都会发射error()信号，调用errot()查看错误类型和上次发生的错误,使用staus()查看当前进程的状态。</p><p>QProcess允许将一个进程视为一个顺序I/O设备，允许读写进程。调用write()写入输入，调用read()、readLine()、getChar()等读取输出。<br><em>QProcess继承自QIODevice，可以作为QXmlReader的数据源，或者为QNetworkAccessManager产生用于上传的数据。</em></p><h3 id="示例"><a class="header-anchor" href="#示例">¶</a>示例</h3><p>例：源码 src/19/19-1/myprocess<br>//启动进程<br>mainwindow.h中添加私有对象QProcess myprocess;<br>在按钮的单击信号槽调用进程启动函数;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myProcess.<span class="built_in">start</span>(<span class="string">&quot;netstat -ntlp&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>process.start()的使用</p><table><thead><tr><th style="text-align:left">Tittle1</th><th style="text-align:center">Tittle2</th><th style="text-align:right">Tittle3</th></tr></thead><tbody><tr><td style="text-align:left">Content</td><td style="text-align:center">Content</td><td style="text-align:right">Content</td></tr><tr><td style="text-align:left">Content</td><td style="text-align:center">Content</td><td style="text-align:right">Content</td></tr><tr><td style="text-align:left">//关联QProcess信号</td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">mainwindow.h添加私有槽说明;</td><td style="text-align:center"></td><td style="text-align:right"></td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">showResult</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showState</span><span class="params">(QProcess::ProcessState)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showError</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showFinished</span><span class="params">(<span class="type">int</span>,QProcess::ExitStatus)</span></span>;</span><br></pre></td></tr></table></figure><p>mainwindow.cpp添加信号和槽的关联;</p>]]></content>
      
      
      <categories>
          
          <category> qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qt开发-窗口与事件</title>
      <link href="/2023/03/01/qt%E5%BC%80%E5%8F%91/qt%E5%BC%80%E5%8F%91-1/"/>
      <url>/2023/03/01/qt%E5%BC%80%E5%8F%91/qt%E5%BC%80%E5%8F%91-1/</url>
      
        <content type="html"><![CDATA[<p>Qt是一个完整的开发框架，其工具旨在简化桌面，嵌入式和移动平台的应用程序和用户界面的创建。</p><span id="more"></span><h2 id="项目环境："><a class="header-anchor" href="#项目环境：">¶</a>项目环境：</h2><p>linux平台：ubuntu20.04 Qt5</p><h2 id="Qt开发–hello-world"><a class="header-anchor" href="#Qt开发–hello-world">¶</a>Qt开发–hello world</h2><h3 id="使用示例程序"><a class="header-anchor" href="#使用示例程序">¶</a>使用示例程序</h3><p>1)使用Qt新建一个hello world程序，使得应用程序可以显示&quot;hello world&quot;字符串。</p><p>2)打开QtCreator新建项目:文件-&gt;新建文件或项目(或者 Ctrl + N);<br>选择Application-&gt;Qt Wigests Application,填写项目信息，基类选择QDialog(Details-&gt;基类);<br>建立完成后QtCreator会直接打开项目文件，打开helloworld.ui进行设计;<br>Filter中搜索Label，左键拖入中间的主设计区，双击输入<code>Hello World</code>。</p><p>3)使用快捷键 Ctrl + R 或者点击左下角运行程序，此时项目路径下多了一个build-XXX-unknown-Debug文件夹;<br>内有cpp源文件，生成的.o中间文件，以及可执行程序。</p><p><code>Windows平台： 生成.exe文件,运行需要把安装路径下的Qt5Cored.dll等文件复制到Debug文件中，或者直接添加环境变量; 发布:使用QtCreator进行release版本的编译(构建-&gt;打开构建套件选择器-&gt;选择构建目标为release);</code></p><h3 id="Qt-Creator纯代码并编写程序"><a class="header-anchor" href="#Qt-Creator纯代码并编写程序">¶</a>Qt Creator纯代码并编写程序</h3><p>1)新建空项目(其他项目-&gt;empty qmake project)。</p><p>2)<a href="http://xn--XXX-t29h961e.pro">编辑XXX.pro</a>:添加<code>greaterThan (QT_MAJOR_VERSION, 4): QT += widgets</code>。<br>(linux平台<code>greaterThan(QT_MAJOR_VERSION, 4): QT + = widgets</code>会报&quot;Assignment needs exactly one word on the left hand side.&quot;)</p><p>3)项目添加main.cpp源文件,右键-&gt;add new-&gt;c++ source;<br>编辑main.cpp:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc,argv)</span></span>;     <span class="comment">//每个Qt Wigests程序都要有一个QApplication类对象，用于管理应用程序的资源;</span></span><br><span class="line">    QDialog w;                  <span class="comment">//实现一个对话框界面</span></span><br><span class="line">    w.<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">300</span>);            <span class="comment">//调整对话框尺寸(宽，高)</span></span><br><span class="line">    <span class="function">QLabel <span class="title">label</span><span class="params">(&amp;w)</span></span>;            <span class="comment">//以QDialog对象为参数，新建QLabel对象；表示对话框是其父窗口。</span></span><br><span class="line">    label.<span class="built_in">setText</span>(<span class="string">&quot;Hello world!&quot;</span>);   <span class="comment">//设置标签要显示的字符串</span></span><br><span class="line">    label.<span class="built_in">move</span>(<span class="number">150</span>, <span class="number">120</span>);         <span class="comment">//调整标签位置</span></span><br><span class="line">    w.<span class="built_in">show</span>();                  <span class="comment">//显示对话框</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();            <span class="comment">//使QApplication对象进入事件循环，程序运行是可以接受产生的事件(单击，键盘按下等)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>快速查看帮助</strong>：<br>将鼠标指针放到类名或者函数上，按F1可以在编辑器右边快速打开帮助文档。</p><p>除了使用Qt Creator编译程序外，还可以使用其他编辑器(ed:Windows 记事本)编写源码，然后打开Qt5.X for Desktop使用命令行编译.</p><h3 id="使用-ui文件"><a class="header-anchor" href="#使用-ui文件">¶</a>使用.ui文件</h3><p>1)同上，在项目文件中添加.ui文件(add new-&gt;Qt-&gt;Qt Designer Form-&gt;Diagog without buttons);</p><p>2)双击.ui文件进入设计模式，在.ui文件中添加Label标签，在属性栏geoetry中修改坐标(= label.move());<br>Ctrl + 2 回到编辑模式(XML文件);</p><p>3)Ctrl + Shift + B 或 左下方块构建工程(仅可在设计模式)。<br>构建成功后在debug文件中会生成一个ui的.h头文件;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/********************************************************************************</span><br><span class="line">** Form generated from reading UI file &#x27;hellodialog.ui&#x27;</span><br><span class="line">**</span><br><span class="line">** Created by: Qt User Interface Compiler version 5.12.8</span><br><span class="line">**</span><br><span class="line">** WARNING! All changes made in this file will be lost when recompiling UI file!</span><br><span class="line">********************************************************************************/</span><br><span class="line"></span><br><span class="line">#ifndef UI_HELLODIALOG_H   /*防止对头文件的多重包含*/</span><br><span class="line">#define UI_HELLODIALOG_H</span><br><span class="line"></span><br><span class="line">#include &lt;QtCore/QVariant&gt;</span><br><span class="line">#include &lt;QtWidgets/QApplication&gt;</span><br><span class="line">#include &lt;QtWidgets/QDialog&gt;</span><br><span class="line">#include &lt;QtWidgets/QLabel&gt;</span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE      /*Qt的命名空间的开始宏*/</span><br><span class="line"></span><br><span class="line">class Ui_HelloDialog   /*定义Ui_HelloDialog类，类名 = Ui_ + 对话框类对象名*/</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    QLabel *HelloLabel;   /*定义QLabel类对象指针*/</span><br><span class="line"></span><br><span class="line">    void setupUi(QDialog *HelloDialog)   /*生成界面*/</span><br><span class="line">    &#123;</span><br><span class="line">        if (HelloDialog-&gt;objectName().isEmpty())   /*设置对话框对象名称*/</span><br><span class="line">            HelloDialog-&gt;setObjectName(QString::fromUtf8(&quot;HelloDialog&quot;));</span><br><span class="line">        HelloDialog-&gt;resize(400, 300);   /*设置窗口大小*/</span><br><span class="line">        HelloLabel = new QLabel(HelloDialog);   /*设置标签名称、大小、位置*/</span><br><span class="line">        HelloLabel-&gt;setObjectName(QString::fromUtf8(&quot;HelloLabel&quot;));</span><br><span class="line">        HelloLabel-&gt;setGeometry(QRect(150, 120, 100, 25));</span><br><span class="line"></span><br><span class="line">        retranslateUi(HelloDialog);   </span><br><span class="line"></span><br><span class="line">        QMetaObject::connectSlotsByName(HelloDialog);   /*使窗口中的部件实现按对象名进行信号和槽的关联*/</span><br><span class="line">    &#125; // setupUi</span><br><span class="line"></span><br><span class="line">    void retranslateUi(QDialog *HelloDialog)   /*对窗口中的字符串进行编码转换*/</span><br><span class="line">    &#123;</span><br><span class="line">        HelloDialog-&gt;setWindowTitle(QApplication::translate(&quot;HelloDialog&quot;, &quot;Dialog&quot;, nullptr));</span><br><span class="line">        HelloLabel-&gt;setText(QApplication::translate(&quot;HelloDialog&quot;, &quot;Hello World&quot;, nullptr));</span><br><span class="line">    &#125; // retranslateUi</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">namespace Ui &#123;   /*定义命名空间*/</span><br><span class="line">    class HelloDialog: public Ui_HelloDialog &#123;&#125;;/*定义继承于Ui_HelloDialog类的HelloDialog类</span><br><span class="line">&#125; // namespace Ui</span><br><span class="line"></span><br><span class="line">QT_END_NAMESPACE      /*Qt的命名空间的结束宏*/</span><br><span class="line"></span><br><span class="line">#endif // UI_HELLODIALOG_H</span><br></pre></td></tr></table></figure><p>4)在main.cpp中引用.ui文件:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ui_hellodialog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc,argv)</span></span>;</span><br><span class="line">    QDialog w;</span><br><span class="line">    Ui::HelloDialog ui;   <span class="comment">/*使用命名空间中的HelloDialog定义了一个ui对象</span></span><br><span class="line"><span class="comment">    ui.setupUi(&amp;w);      /*使用对话框作为参数，可以将设计好的界面应用到对象w所表示的对话框上*/</span></span><br><span class="line">    <span class="function">QLabel <span class="title">label</span><span class="params">(&amp;w)</span></span>;</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样这种方式也可以使用命令行编译ui文件和程序;</p><h3 id="自定义C-类"><a class="header-anchor" href="#自定义C-类">¶</a>自定义C++类</h3><p>1)新建项目;<br>2)添加文件(C++ class);<br>3)main.cpp中引用HelloDialog类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hellodialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">QApplication <span class="title">a</span><span class="params">(argc,argv)</span></span>;</span><br><span class="line">   HelloDialog w;</span><br><span class="line">   w.<span class="built_in">show</span>();</span><br><span class="line">   <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4)添加ui文件;<br>5)修改C<ins>头文件，在新建的C</ins>类中使用ui文件;<br>头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELLODIALOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELLODIALOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDialog&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloDialog</span>;   <span class="comment">/*声明HelloDialog类，这个类是在之前ui生成的头文件中提到的*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloDialog</span> : <span class="keyword">public</span> QDialog   <span class="comment">/*新定义的继承于QDalog的类*/</span></span><br><span class="line">&#123;</span><br><span class="line">   Q_OBJECT   <span class="comment">/*定义可扩展c++功能的宏*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">   <span class="function"><span class="keyword">explicit</span> <span class="title">HelloDialog</span><span class="params">(QWidget * parent = <span class="number">0</span>)</span></span>;      <span class="comment">/*显式构造函数，参数用于指定父窗口，默认没有父窗口*/</span></span><br><span class="line">   ~<span class="built_in">HelloDialog</span>();      <span class="comment">/*析构函数*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   Ui::HelloDialog * ui;   <span class="comment">/*定义HelloDialog类对象的指针*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HELLODIALOG_H</span></span></span><br></pre></td></tr></table></figure><p>源码文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hellodialog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_hellodialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">HelloDialog::<span class="built_in">HelloDialog</span>(QWidget * parent):</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">QDialog</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">   ui = <span class="keyword">new</span> Ui::HelloDialog;   <span class="comment">/*创建新对象*/</span></span><br><span class="line">   ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);   <span class="comment">/*表示现在这个类所代表的对话框创建页面*/</span></span><br><span class="line">&#125;</span><br><span class="line">HelloDialog::~<span class="built_in">HelloDialog</span>()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="窗口、子部件、窗口类型"><a class="header-anchor" href="#窗口、子部件、窗口类型">¶</a>窗口、子部件、窗口类型</h2><h3 id="窗口及子部件"><a class="header-anchor" href="#窗口及子部件">¶</a>窗口及子部件</h3><p>窗口部件(Widget)是Qt中设计用户页面的主要元素。</p><p>例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">QApplication <span class="title">a</span><span class="params">(argc,argv)</span></span>;</span><br><span class="line">   QWidget * widget = <span class="keyword">new</span> <span class="built_in">QWidget</span>();    <span class="comment">/*默认参数是零，所以是窗口*/</span></span><br><span class="line">   widget-&gt;<span class="built_in">setWindowTitle</span>(QObject::<span class="built_in">tr</span>(<span class="string">&quot;I am widget.&quot;</span>));</span><br><span class="line"></span><br><span class="line">   QLabel * label = <span class="keyword">new</span> <span class="built_in">QLabel</span>();      <span class="comment">/*同上，是窗口*/</span></span><br><span class="line">   label-&gt;<span class="built_in">setWindowTitle</span>(QObject::<span class="built_in">tr</span>(<span class="string">&quot;I am label.&quot;</span>));</span><br><span class="line">   label-&gt;<span class="built_in">setText</span>(QObject::<span class="built_in">tr</span>(<span class="string">&quot;label:I am a window.&quot;</span>));</span><br><span class="line">   label-&gt;<span class="built_in">resize</span>(<span class="number">200</span>，<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">   QLabel * label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(widget);   <span class="comment">/*创建QLable类对象，指定父窗口是widget*/</span></span><br><span class="line">   label2-&gt;<span class="built_in">setText</span>(QObject::<span class="built_in">tr</span>(<span class="string">&quot;label2:I am not a window,just a child of widget.&quot;</span>));</span><br><span class="line">   label2-&gt;<span class="built_in">resize</span>(<span class="number">300</span>,<span class="number">100</span>);</span><br><span class="line">   <span class="comment">//label2-&gt;move(150,50);  /*移动label2的位置，导致widget父窗口尺寸 += label2尺寸*/</span></span><br><span class="line"></span><br><span class="line">   label-&gt;<span class="built_in">show</span>();</span><br><span class="line">   widget-&gt;<span class="built_in">show</span>();</span><br><span class="line">   <span class="type">int</span> ret = a.<span class="built_in">exec</span>();</span><br><span class="line">   <span class="keyword">delete</span> label;</span><br><span class="line">   <span class="keyword">delete</span> widget;</span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="窗口分类"><a class="header-anchor" href="#窗口分类">¶</a>窗口分类</h3><p>窗口一般有标题栏和边框，但是这不是必须的。<br>QWidget的构造函数有两个参数:</p><figure class="highlight qt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QWidget * <span class="built_in">parent</span> =<span class="number">0</span>;   <span class="comment">/*默认值parent值为零，表示没有父窗口*/</span></span><br><span class="line"><span class="attribute">Qt</span>::WiwdowFlags f =<span class="number">0</span>;   <span class="comment">/*参数f是窗口类型的枚举值或组合*/</span></span><br></pre></td></tr></table></figure><h2 id="qt中的事件"><a class="header-anchor" href="#qt中的事件">¶</a>qt中的事件</h2><p>Qt中使用一个对象来表示一个事件，继承自QEvent类。事件与信号不同，例：点击按钮会产生鼠标事件QMouseEvent，而因为按钮被按下了，所以会发射clicked单击信号。<br>这里一般只关心按钮的clicked信号，但是如果要考虑点击按钮使它产生别的东西，就要担心鼠标事件了。在Qt中，任何QObject子类实例都可以接受和处理事件。</p><h3 id="事件的处理"><a class="header-anchor" href="#事件的处理">¶</a>事件的处理</h3><p>一个事件有一个特定的QEvent子类来表示，但是有事一个事件又包含多个事件类型，比如鼠标事件可以分为：鼠标单击、鼠标双击、鼠标移动等操作。<br>这些事件类型可以用QEvent::Type来表示，而对于事件的处理有五种方法：<br>1)重新实现不见的paintEvent()、mousePressEvent()等事件处理函数，只能用于处理特定部件的特定事件;<br>2)重新实现notify()函数，一次只能处理一个事件;<br>3)向QApplication对象上安装事件过滤器，功能和notify相同，并可以同时处理多个事件;<br>4)重新实现event()函数。QObject类的event()函数可以在事件达到默认的事件处理函数之前获得该事件;<br>5)在对象上安装事件过滤器;<br>实际编程中常用1)、5)。</p><h3 id="事件的传递"><a class="header-anchor" href="#事件的传递">¶</a>事件的传递</h3><p>每个main()函数最后都会调用QApplication类的exec()函数，这使得Qt应用程序进入事件循环，可以接收到运行时发生的各种事件。<br>一但事件发生，Qt会构建一个QEvent子类的对象并传递给相应的QObject对象或其子对象。</p><p>例：<a href="https://www.yafeilinux.com/">源码</a> src/06/6-1/myevent</p><p>//自定义一个继承自QLineEdit的MyLineEdit类，添加事件处理函数定义</p><p>mylineedit.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLineEdit</span> : <span class="keyword">public</span> QLineEdit</span><br><span class="line">&#123;</span><br><span class="line">   Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">explicit</span> <span class="title">MyLineEdit</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">keyPressEvent</span><span class="params">(QKeyEvent *event)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>mylineedit.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyLineEdit::<span class="built_in">MyLineEdit</span>(QWidget *parent) :</span><br><span class="line">   <span class="built_in">QLineEdit</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyLineEdit::keyPressEvent</span><span class="params">(QKeyEvent *event)</span> <span class="comment">// 键盘按下事件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">tr</span>(<span class="string">&quot;MyLineEdit键盘按下事件&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//在Widget界面添加一个MyLineEdit部件，实现MyLineEdit类的键盘按下事件处理函数和Widget类的键盘按下事件处理函数</p><p>widget.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLineEdit</span>;      <span class="comment">//MyLineEdit类前置声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">   ···</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   ···</span><br><span class="line">   MyLineEdit *lineEdit;      <span class="comment">//对象指针</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">keyPressEvent</span><span class="params">(QKeyEvent *event)</span></span>;      <span class="comment">//函数声明</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>widget.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylineedit.h&quot;</span>      <span class="comment">//添加头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QKeyEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent) :</span><br><span class="line">   <span class="built_in">QWidget</span>(parent),</span><br><span class="line">   <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">   ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">   lineEdit = <span class="keyword">new</span> <span class="built_in">MyLineEdit</span>(<span class="keyword">this</span>);   <span class="comment">//Widget类构造函数中添加代码</span></span><br><span class="line">   lineEdit-&gt;<span class="built_in">move</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::keyPressEvent</span><span class="params">(QKeyEvent *event)</span>   <span class="comment">//添加事件处理函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">tr</span>(<span class="string">&quot;Widget键盘按下事件&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行程序只显示&quot;MyLineEdit键盘按下事件&quot;，在mylineedit.cpp中添加:</p><figure class="highlight qt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">QLineEdit</span>::keyPressEvent(event);        <span class="comment">// 执行QLineEdit类的默认事件处理</span></span><br><span class="line">event-&gt;ignore();                    <span class="comment">// 忽略该事件</span></span><br></pre></td></tr></table></figure><p>运行程序显示&quot;MyLineEdit键盘按下事件&quot;,“Widget键盘按下事件”。这表明事件是先传递给指定窗口部件(MyLineEdit)，如果该部件忽略该事件，则会传递给其父部件(Widget)。<br>重新实现事件处理函数时，一般要调用父类(QLineEdit)的相应事件处理函数来实现默认操作。</p>]]></content>
      
      
      <categories>
          
          <category> qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile编写</title>
      <link href="/2023/02/28/tips%E6%95%B4%E7%90%86/Makefile%E7%BC%96%E5%86%99/"/>
      <url>/2023/02/28/tips%E6%95%B4%E7%90%86/Makefile%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>Makefile是在Linux环境下 C/C++ 程序开发必须要掌握的一个工程管理文件。</p><span id="more"></span><p>在Linux下编写程序，因为早期没有成熟的IDE，一般都是使用不同的命令进行编译：将源文件分别使用编译器、汇编器、链接器编译成可执行文件，然后手动运行。<br>如图(…/…/pic/pic1.png)</p><h2 id="gcc编译参数"><a class="header-anchor" href="#gcc编译参数">¶</a>gcc编译参数</h2><p>1.使用GCC编译程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o a.out helloworld.c</span><br></pre></td></tr></table></figure><p>2.使用-E参数，只做预处理，不编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E helloworld.c</span><br></pre></td></tr></table></figure><p>3.制作汇编处理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S -o helloworld.S helloworld.c</span><br></pre></td></tr></table></figure><h2 id="Makefile-编译"><a class="header-anchor" href="#Makefile-编译">¶</a>Makefile 编译</h2><p>例：编写</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">a.out: helloworld.o</span></span><br><span class="line">    gcc -o a.out helloworld.o</span><br><span class="line"><span class="section">helloworld.o: helloworld.c</span></span><br><span class="line">    gcc -c -o helloworld.o helloworld.c</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f a.out helloworld.o</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tips整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android-jni入门</title>
      <link href="/2023/02/24/%E5%B9%B3%E5%8F%B0-android/android%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"/>
      <url>/2023/02/24/%E5%B9%B3%E5%8F%B0-android/android%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>未完待续~<br>首先介绍一下Android studio生成的项目文件架构。</p><span id="more"></span><h2 id="简单项目架构"><a class="header-anchor" href="#简单项目架构">¶</a>简单项目架构</h2><p>Android 项目文件:<br>Gradle Script:显示项目的所有与构建相关的配置文件<br>manifests:包含 AndroidManifest.xml 文件（应用清单概览）<br>java:包含java源代码<br>res:包含所有非代码资源（eg:XML布局，img等）<br>项目架构：<br>Test1<br>│<br>└─app<br>│  ├─build#包含构建输出。<br>│  │<br>│  ├─libs#包含专用库。<br>│  │<br>│  └─src#包含相应模块在以下子目录中的所有代码和资源文件。<br>│      ├─androidTest#包含在 Android 设备上运行的插桩测试的代码。<br>│      │<br>│      ├─main#包含“主”源代码集文件：所有 build 变体共享的 Android 代码和资源（其他 build 变体的文件位于同级目录中，例如调试 build 类型的文件位于 src/debug/ 中）<br>│      │  │  AndroidManifest.xml#描述应用及其各个组件的性质。<br>│      │  │<br>│      │  ├─java#包含 Java 源代码。<br>│      │  │<br>│      │  ├─jni#包含使用 Java 原生接口 (JNI) 的原生代码。(主要封装位置）<br>│      │  │<br>│      │  ├─gen#包含 Android Studio 生成的 Java 文件。<br>│      │  │<br>│      │  ├─res#包含应用资源，例如可绘制对象文件、布局文件和界面字符串。<br>│      │  │<br>│      │  └─assets#包含应按原样编译为 .apk 文件的文件。<br>│      │<br>│      └─test#包含在主机 JVM 上运行的本地测试代码。<br>│<br>└─build.gradle（模块）#这定义了特定于模块的构建配置。<br>└─build.gradle（项目）  #这定义了适用于所有模块的构建配置。</p><h2 id="包含c、c-的Android项目"><a class="header-anchor" href="#包含c、c-的Android项目">¶</a>包含c、c++的Android项目</h2><p>向项目添加C、C<ins>代码:<br>将C、C</ins>代码放在项目模块的CPP目录中，java代码可以通过java原生接口(jni)调用原生库中的函数。<br>步骤:<br>1.下载 NDK 和构建工具;<br><a href="https://developer.android.google.cn/studio/projects/add-native-code?hl=zh-cn#download-ndk">https://developer.android.google.cn/studio/projects/add-native-code?hl=zh-cn#download-ndk</a><br>2.创建支持 C/C++ 的新项目<br><a href="https://developer.android.google.cn/studio/projects/add-native-code?hl=zh-cn#new-project">https://developer.android.google.cn/studio/projects/add-native-code?hl=zh-cn#new-project</a></p><h3 id="JNI"><a class="header-anchor" href="#JNI">¶</a>JNI</h3><p>全名 Java Native Interface，是Java本地接口，JNI是Java调用Native 语言的一种特性，通过JNI可以使得Java与C/C<ins>机型交互。<br>简单点说就是JNI是Java中调用C/C</ins>的统称。<br>2.NDK<br>全名Native Develop Kit，官方说法：Android NDK 是一套允许您使用 C 和 C++ 等语言，以原生代码实现部分应用的工具集。<br>在开发某些类型的应用时，这有助于您重复使用以这些语言编写的代码库。</p><h3 id="Android-Studio-JNI开发"><a class="header-anchor" href="#Android-Studio-JNI开发">¶</a>Android Studio JNI开发</h3><p>1.File-&gt;New-&gt;New Project 新建native C++项目；<br>2.配置CMake、NDK环境：</p><p>Tools-&gt;SDK Manager-&gt;SDK Tools下载:NDK(Side by side)、CMake、Android Emulator、Android SDK Platform-Tools等；<br>打开File-&gt;Project Structure，配置SDK、NDK目录；<br>（notices:在SDK Manager中下载完NDK后，打开File-&gt;Project Structure-&gt;Android NDK location无法配置，无法选中修改；<br>可能是NDK是存在本地的，Android studio本身没有下载导致的。<br>尝试在local.properties 中手动添加本地ndk.dir路径。<br>成功解决）</p><p>3.实现在Android中调用c<ins>代码：<br>Android 中调用C/C</ins>库的步骤：<br>1）通过System.loadLibrary引入C代码库名；<br>2）在cpp目录下的natice-lib.cpp中编写C/C++代码</p>]]></content>
      
      
      <categories>
          
          <category> 平台-android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android studio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu20.04桌面假死及解决</title>
      <link href="/2023/02/24/%E5%B9%B3%E5%8F%B0-Linux/linux%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E7%A7%AF%E7%B4%AF/"/>
      <url>/2023/02/24/%E5%B9%B3%E5%8F%B0-Linux/linux%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E7%A7%AF%E7%B4%AF/</url>
      
        <content type="html"><![CDATA[<h1>ubuntu20.04桌面假死及解决</h1><p>ubuntu20.04虚拟机桌面假死，鼠标可以移动但点击无反应。<br>解决：<br>alt + crtl +F1(F1~F6)进入tty终端<br>输入账号和密码进行登录<br>ps -t tty7 #查找桌面进程<br>sudo pkill Xorg  #注销桌面重新登陆</p><p>ubuntu键盘无反应，无法进入ty终端，xshell远程连接，ps -t tty7显示无桌面进程。可能是由于ubuntu桌面被意外卸载，重装程序，重新登陆。<br>解决方法：<br>sudo apt-get install ubuntu-desktop<br>sudo pkill Xorg  #注销桌面重新登陆</p>]]></content>
      
      
      <categories>
          
          <category> 平台-Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用VC+VS开发时编码的坑</title>
      <link href="/2023/02/23/tips%E6%95%B4%E7%90%86/%E4%BD%BF%E7%94%A8VC-VS%E5%BC%80%E5%8F%91%E6%97%B6%E7%BC%96%E7%A0%81%E7%9A%84%E5%9D%91/"/>
      <url>/2023/02/23/tips%E6%95%B4%E7%90%86/%E4%BD%BF%E7%94%A8VC-VS%E5%BC%80%E5%8F%91%E6%97%B6%E7%BC%96%E7%A0%81%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>记录以下研发过程中编码带来的坑！</p>  <span id="more"></span><h2 id="VS-和-VC"><a class="header-anchor" href="#VS-和-VC">¶</a>VS 和 VC</h2><p>使用Visual Studio 2019开发，工程文件默认以ANSI(GB2312)编码方式保存。<br>使用Visual Studio Code打开源文件，默认以UTF-8编码方式打开，所以VS编写的文件如果以VC打开会有中文乱码；<br>此时如果在VC下保存，源文件编码格式会编程UTF-8。</p><h2 id="Winduws-和-Unix"><a class="header-anchor" href="#Winduws-和-Unix">¶</a>Winduws 和 Unix</h2><p>在Winows下文件默认以CRLF换行保存，而Unix例如Linux默认以LF换行解析文件。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> -A 文件  <span class="comment">#查看文件换行,在Linux平台编译CRLF格式的文件，会自动在行尾加^M</span></span><br></pre></td></tr></table></figure></p><h2 id="git的坑"><a class="header-anchor" href="#git的坑">¶</a>git的坑</h2><p>git commit上传项目会自动把文件以LF UTF-8的形式保存，如果在Windows上拉取项目就是CRLF换行，在Unix平台拉取就是LF换行。</p><pre><code><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf <span class="literal">false</span> <span class="comment">#可以使用命令像转换开关关闭</span></span><br></pre></td></tr></table></figure></code></pre><p>关闭换行转换后，上传项目，git会保存上传文件的格式，拉取时也一样。</p>]]></content>
      
      
      <categories>
          
          <category> tips整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vs Code </tag>
            
            <tag> Visual Studio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国密SM2签名</title>
      <link href="/2023/02/22/%E5%9B%BD%E5%AF%86/%E5%9B%BD%E5%AF%86SM2%E7%AD%BE%E5%90%8D/"/>
      <url>/2023/02/22/%E5%9B%BD%E5%AF%86/%E5%9B%BD%E5%AF%86SM2%E7%AD%BE%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="About-GMSSL"><a class="header-anchor" href="#About-GMSSL">¶</a>About GMSSL</h2><p>GmSSL是由由北京大学自主开发的国产商用密码开源库，实现了对国密算法、标准和安全通信协议的全面功能覆盖，支持包括移动端在内的主流操作系统和处理器，支持密码钥匙、密码卡等典型国产密码硬件，提供功能丰富的命令行工具及多种编译语言编程接口。</p><span id="more"></span><h2 id="SM2签名"><a class="header-anchor" href="#SM2签名">¶</a>SM2签名</h2><p>SM2签名算法实际上就是使用椭圆曲线密码算法进行数字签名和验证，以通信为例，服务器使用私钥签名，客户端使用公钥验签。</p><h3 id="椭圆曲线"><a class="header-anchor" href="#椭圆曲线">¶</a>椭圆曲线</h3><p>椭圆曲线公钥密码所基于的曲线性质如下：<br>——有限域上椭圆曲线在点加运算下构成有限交换群 ,且其阶与基域规模相近；<br>——类似于有限域乘法群中的乘幂运算 ,椭圆曲线多倍点运算构成一个单向函数；</p><p>根据椭圆曲线的性质，找到曲线基点G在素数域(GFp)或二元扩域（GF2m）的k倍点P(x,y)，即：<br><code>(x,y) = kG </code><br>则点P(x,y)为公钥，k为私钥。</p><h3 id="SM2签名算法"><a class="header-anchor" href="#SM2签名算法">¶</a>SM2签名算法</h3><p><a href="https://github.com/guanzhi/GmSSL.git">GMSSL官方项目地址</a><br>在使用GMSSL-v1 SM2签名算法的过程中，发现了一下问题：<br>1.函数SM2_do_sign()中约每100次生成含有padding的签名<br>2.程序源码存在内存泄露问题</p><p>因此，本项目对GMSSL-v1做出以下改进：<br>1.按照标准文档修改函数SM2_do_sign_ex()的逻辑，返回ECDSA_SIG结构签名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ECDSA_SIG_st</span> &#123;</span><br><span class="line">    BIGNUM *r;</span><br><span class="line">    BIGNUM *s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.网络中一般以字节流的形式传输，因此新增结构体SM2_SIGNATURE_STRUCT</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">sm2_sig_structure</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> r_coordinate[<span class="number">32</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> s_coordinate[<span class="number">32</span>];</span><br><span class="line">&#125; SM2_SIGNATURE_STRUCT;</span><br></pre></td></tr></table></figure><p>3.解决随机生成含有padding的签名，修改函数SM2_do_sign()，内置BN_bn2binpad()<br>4.规范代码格式，增加可读性</p><p>官网中GMSSL-v2相比v1并没有对SM2签名、密钥交换、加解密做出改进；GMSSL-3.0.0稳定版本增加Windows+VS编译，去掉了perl的使用，但编译失败；GMSSL-3.1.0-dev版编译成功，但GMSSL-3.0以上的版本都独立于openssl，并且SM2签名、密钥交换相关仍在开发。<br>因此，本项目参考标准文档对稳定并使用广泛的GMSSL-V1进行开发改进，<a href="https://github.com/115Jiege/Gmssl.git">项目地址</a> 。</p>]]></content>
      
      
      <categories>
          
          <category> 国密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> SM2 </tag>
            
            <tag> 数字签名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客文章写作</title>
      <link href="/2022/09/23/hexo/hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%86%99%E4%BD%9C/"/>
      <url>/2022/09/23/hexo/hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%86%99%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令"><a class="header-anchor" href="#常用命令">¶</a>常用命令</h2><p><strong>hexo 安装</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g #安装</span><br><span class="line">npm update hexo -g #升级</span><br><span class="line">hexo init #初始化</span><br></pre></td></tr></table></figure><span id="more"></span><p><strong>服务器</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。</span><br><span class="line">hexo server -s #静态模式</span><br><span class="line">hexo server -p <span class="number">5000</span> #更改端口</span><br><span class="line">hexo server -i <span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span> #自定义 IP</span><br><span class="line"></span><br><span class="line">hexo clean # 清除缓存文件（db.json和已生成的静态文件，尤其是更换主题后） </span><br><span class="line"></span><br><span class="line">hexo g # 生成静态文件</span><br><span class="line">hexo s # 启动hexo  （上述两个指令需要在博客根目录下执行）</span><br><span class="line">hexo d  # 部署到cmdHub上（前提是已经添加SSH Key，设置好账户信息）</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;文章名&quot;  #新建文章</span><br><span class="line">hexo new  page &quot;页面名&quot; #新建页面</span><br></pre></td></tr></table></figure><p><strong>ssl报错</strong><br>解决方案<br>在项目文件夹的命令行窗口执行下面代码，然后再cmd commit 或cmd clone<br>取消cmd本身的https代理，使用自己本机的代理，如果没有的话，其实默认还是用cmd的</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Documents/blog</span><br><span class="line">//取消http代理</span><br><span class="line"><span class="built_in">cmd</span> config --global --unset http.proxy</span><br><span class="line">//取消https代理 </span><br><span class="line"><span class="built_in">cmd</span> config --global --unset https.proxy</span><br></pre></td></tr></table></figure><h2 id="写作介绍"><a class="header-anchor" href="#写作介绍">¶</a>写作介绍</h2><h2 id="1-字体介绍"><a class="header-anchor" href="#1-字体介绍">¶</a>1.字体介绍</h2><p><em>这是斜体</em> 或 <em>这也是斜体</em><br><strong>这是粗体</strong><br><em><strong>这是加粗斜体</strong></em><br><s>这是删除线</s></p><h2 id="2-分级标题"><a class="header-anchor" href="#2-分级标题">¶</a>2.分级标题</h2><h1>一级标题</h1><h2 id="二级标题"><a class="header-anchor" href="#二级标题">¶</a>二级标题</h2><h3 id="三级标题"><a class="header-anchor" href="#三级标题">¶</a>三级标题</h3><h4 id="四级标题"><a class="header-anchor" href="#四级标题">¶</a>四级标题</h4><h5 id="五级标题"><a class="header-anchor" href="#五级标题">¶</a>五级标题</h5><h6 id="六级标题"><a class="header-anchor" href="#六级标题">¶</a>六级标题</h6><h2 id="3-超链接"><a class="header-anchor" href="#3-超链接">¶</a>3.超链接</h2><p>写法：</p><p>行内形式：<a href="https://cmdhub.com/115Jiege/115Jiege.cmdhub.io.cmd">我的博客</a><br>参考形式：[我的博客][1]，有一个很好的平台-[简书][2]<br>[1]: <a href="https://cmdhub.com/115Jiege/115Jiege.cmdhub.io.cmd">https://cmdhub.com/115Jiege/115Jiege.cmdhub.io.cmd</a><br>[2]:<a href="http://www.baidu.com/">http://www.baidu.com/</a><br>自动链接：我的博客地址<a href="https://cmdhub.com/115Jiege/115Jiege.cmdhub.io">https://cmdhub.com/115Jiege/115Jiege.cmdhub.io</a></p><h2 id="4-列表"><a class="header-anchor" href="#4-列表">¶</a>4.列表</h2><p>无序列表：<br>写法：</p><ul><li>无序列表项1</li></ul><ul><li>无序列表项2</li></ul><ul><li>无序列表项3</li></ul><p>有序列表：<br>写法：<br>1.有序列表项1<br>2.有序列表项2<br>3.有序列表项3</p><h2 id="5-插入图片"><a class="header-anchor" href="#5-插入图片">¶</a>5.插入图片</h2><p>在 Hexo 中插入图片，首先需要将图片放在 source/img/ 文件夹下，然后如下方式进行插入：</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1535014836&amp;di=fafdb400041dc371b853cfb3fcc7b851&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fscdn.file1.gk99.com%2Fphoto%2F2015-09%2F2015-09-11%2F14419580206489.jpg" alt></p><h2 id="6-表格"><a class="header-anchor" href="#6-表格">¶</a>6.表格</h2><table><thead><tr><th>表头1</th><th style="text-align:left">表头2</th><th style="text-align:center">表头3</th><th style="text-align:right">表头4</th></tr></thead><tbody><tr><td>默认左对齐</td><td style="text-align:left">左对齐</td><td style="text-align:center">居中对其</td><td style="text-align:right">右对齐</td></tr><tr><td>默认左对齐</td><td style="text-align:left">左对齐</td><td style="text-align:center">居中对其</td><td style="text-align:right">右对齐</td></tr><tr><td>默认左对齐</td><td style="text-align:left">左对齐</td><td style="text-align:center">居中对其</td><td style="text-align:right">右对齐</td></tr></tbody></table><h2 id="7-代码"><a class="header-anchor" href="#7-代码">¶</a>7.代码</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#无序</span><br><span class="line">hexo new &quot;create a new blog&quot;</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#有序</span><br><span class="line">hexo new &quot;create blog2&quot;</span><br><span class="line">hexo new &quot;create blog3&quot;</span><br></pre></td></tr></table></figure><h2 id="8-转移字符表"><a class="header-anchor" href="#8-转移字符表">¶</a>8.转移字符表</h2><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- &amp;<span class="variable">#45</span><span class="comment">; &amp;minus; — 减号</span></span><br><span class="line">! &amp;<span class="variable">#33</span><span class="comment">; — 惊叹号Exclamation mark </span></span><br><span class="line">” &amp;<span class="variable">#34</span><span class="comment">; &quot; 双引号Quotation mark </span></span><br><span class="line"># &amp;<span class="variable">#35</span><span class="comment">; — 数字标志Number sign </span></span><br><span class="line">$ &amp;<span class="variable">#36</span><span class="comment">; — 美元标志Dollar sign </span></span><br><span class="line">% &amp;<span class="variable">#37</span><span class="comment">; — 百分号Percent sign </span></span><br><span class="line">&amp; &amp;<span class="variable">#38</span><span class="comment">; &amp; Ampersand </span></span><br><span class="line">‘ &#x27; — 单引号Apostrophe </span><br><span class="line">( &amp;<span class="variable">#40</span><span class="comment">; — 小括号左边部分Left parenthesis </span></span><br><span class="line">) &amp;<span class="variable">#41</span><span class="comment">; — 小括号右边部分Right parenthesis </span></span><br><span class="line">* &amp;<span class="variable">#42</span><span class="comment">; — 星号Asterisk </span></span><br><span class="line">+ &amp;<span class="variable">#43</span><span class="comment">; — 加号Plus sign </span></span><br><span class="line">&lt; &amp;<span class="variable">#60</span><span class="comment">; &lt; 小于号Less than </span></span><br><span class="line"><span class="operator">=</span> &amp;<span class="variable">#61</span><span class="comment">; — 等于符号Equals sign </span></span><br><span class="line">&gt; &amp;<span class="variable">#62</span><span class="comment">; &gt; 大于号Greater than </span></span><br><span class="line">? &amp;<span class="variable">#63</span><span class="comment">; — 问号Question mark </span></span><br><span class="line">@ &amp;<span class="variable">#64</span><span class="comment">; — Commercial at </span></span><br><span class="line">[ &amp;<span class="variable">#91</span><span class="comment">; --- 中括号左边部分Left square bracket </span></span><br><span class="line">\ &amp;<span class="variable">#92</span><span class="comment">; --- 反斜杠Reverse solidus (backslash) </span></span><br><span class="line">] &amp;<span class="variable">#93</span><span class="comment">; — 中括号右边部分Right square bracket </span></span><br><span class="line">&#123; &amp;<span class="variable">#123</span><span class="comment">; — 大括号左边部分Left curly brace </span></span><br><span class="line">| &amp;<span class="variable">#124</span><span class="comment">; — 竖线Vertical bar </span></span><br><span class="line">&#125; &amp;<span class="variable">#125</span><span class="comment">; — 大括号右边部分Right curly brace</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试常用命令--1</title>
      <link href="/2022/07/26/%E5%B9%B3%E5%8F%B0-Linux/%E6%B5%8B%E8%AF%95%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/26/%E5%B9%B3%E5%8F%B0-Linux/%E6%B5%8B%E8%AF%95%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>记录一下测试时常用的命令</p><span id="more"></span><h3 id="1-docker常用命令"><a class="header-anchor" href="#1-docker常用命令">¶</a>1.docker常用命令</h3><h4 id="测试中用到的docker命令："><a class="header-anchor" href="#测试中用到的docker命令：">¶</a>测试中用到的docker命令：####</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">service docker start  <span class="comment">#开启docker</span></span><br><span class="line">docker ps  <span class="comment">#查看docker正在运行的容器</span></span><br><span class="line">Docker start 容器ID <span class="comment">#启动容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#docker访问外部网络，上位机连接前要检查</span></span><br><span class="line">sysctl net.ipv4.ip_forward </span><br><span class="line"><span class="comment">#如果为 0，说明没有开启转发，则需要手动打开</span></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><h4 id="docker常用命令大全："><a class="header-anchor" href="#docker常用命令大全：">¶</a>docker常用命令大全：####</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#info</span></span><br><span class="line">docker info       <span class="comment">#显示docker的系统信息，包括镜像和容器的数量</span></span><br><span class="line">docker version    <span class="comment">#显示docker的版本信息。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#镜像命令</span></span><br><span class="line">docker images <span class="comment">#查看所有本地主机上的镜像 可以使用docker image ls代替</span></span><br><span class="line">docker search <span class="comment">#搜索镜像</span></span><br><span class="line">docker pull <span class="comment">#下载镜像 docker image pull</span></span><br><span class="line">docker rmi <span class="comment">#删除镜像 docker image rm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#容器命令</span></span><br><span class="line">docker run 镜像<span class="built_in">id</span> <span class="comment">#新建容器并启动</span></span><br><span class="line">docker ps 列出所有运行的容器 docker container list</span><br><span class="line">docker <span class="built_in">rm</span> 容器<span class="built_in">id</span> <span class="comment">#删除指定容器</span></span><br><span class="line"><span class="comment">#删除所有容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -aq)   <span class="comment">#删除所有的容器</span></span><br><span class="line">docker ps -a -q|xargs docker <span class="built_in">rm</span>  <span class="comment">#删除所有的容器</span></span><br><span class="line"><span class="comment">#启动和停止容器</span></span><br><span class="line">docker start 容器<span class="built_in">id</span><span class="comment">#启动容器</span></span><br><span class="line">docker restart 容器<span class="built_in">id</span><span class="comment">#重启容器</span></span><br><span class="line">docker stop 容器<span class="built_in">id</span><span class="comment">#停止当前正在运行的容器</span></span><br><span class="line">docker <span class="built_in">kill</span> 容器<span class="built_in">id</span><span class="comment">#强制停止当前容器</span></span><br><span class="line"><span class="comment">#退出容器</span></span><br><span class="line"><span class="built_in">exit</span> <span class="comment">#容器直接退出</span></span><br><span class="line">ctrl +P +Q  <span class="comment">#容器不停止退出 ---注意：这个很有用的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#其他常用命令</span></span><br><span class="line">docker <span class="built_in">exec</span><span class="comment">#在运行的容器中执行命令</span></span><br><span class="line">docker <span class="built_in">export</span><span class="comment">#将文件系统作为一个tar归档文件导出到STDOUT</span></span><br><span class="line">docker import<span class="comment">#从归档文件中创建镜像</span></span><br><span class="line">docker <span class="built_in">kill</span><span class="comment">#杀掉一个运行中的容器</span></span><br><span class="line">docker save<span class="comment">#将指定镜像保存成 tar 归档文件</span></span><br><span class="line">docker load<span class="comment">#导入使用 docker save 命令导出的镜像</span></span><br><span class="line"></span><br><span class="line">docker run -d 镜像名  <span class="comment">#后台启动命令</span></span><br><span class="line">docker logs <span class="comment">#查看日志</span></span><br><span class="line">docker top 容器<span class="built_in">id</span> <span class="comment">#查看容器中进程信息ps</span></span><br><span class="line">docker inspect 容器<span class="built_in">id</span>  <span class="comment">#查看镜像的元数据</span></span><br><span class="line">docker attach <span class="comment"># 进入容器正在执行的终端</span></span><br><span class="line">docker <span class="built_in">cp</span> 容器<span class="built_in">id</span>:容器内路径  主机目的路径<span class="comment">#从容器内拷贝到主机上</span></span><br></pre></td></tr></table></figure><h3 id="2-关于进程、端口命令"><a class="header-anchor" href="#2-关于进程、端口命令">¶</a>2.关于进程、端口命令</h3><h4 id="僵尸进程"><a class="header-anchor" href="#僵尸进程">¶</a>僵尸进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">top 查找僵尸进程</span><br><span class="line">ps -A -ostat,ppid,pid,cmd |grep -e <span class="string">&#x27;^[Zz]&#x27;</span> 定位僵尸进程</span><br><span class="line">Kill -HUP 父<span class="built_in">id</span>（可能会杀掉app.py）</span><br><span class="line">netstat</span><br></pre></td></tr></table></figure><h4 id="netstat常用命令"><a class="header-anchor" href="#netstat常用命令">¶</a>netstat常用命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">netstat -a <span class="comment">#列出所有端口 </span></span><br><span class="line">netstat -at <span class="comment">#列出所有 tcp 端口 </span></span><br><span class="line">netstat -au <span class="comment">#列出所有 udp 端口 </span></span><br><span class="line"></span><br><span class="line">netstat -anp | grep 进程号 <span class="comment">#查询进程号所占用的端口</span></span><br><span class="line"></span><br><span class="line">netstat -tunlp | grep 端口号 <span class="comment">#查看端口对应的进程，用于排查端口号是否被占用</span></span><br><span class="line"></span><br><span class="line">netstat -anp | grep 端口号 <span class="comment">#查看端口的使用情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#列出所有处于监听状态的 Sockets</span></span><br><span class="line">netstat -l <span class="comment">#只显示监听端口</span></span><br><span class="line">netstat -lt <span class="comment">#只列出所有监听 tcp 端口 </span></span><br><span class="line">netstat -lu <span class="comment">#只列出所有监听 udp 端口 </span></span><br><span class="line">netstat -lx <span class="comment">#只列出所有监听 UNIX 端口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">netstat -s <span class="comment">#显示所有端口的统计信息 </span></span><br><span class="line">netstat -st 或 -su <span class="comment">#显示 TCP 或 UDP 端口的统计信息</span></span><br><span class="line"></span><br><span class="line">netstat -pt <span class="comment">#显示pid和进程</span></span><br></pre></td></tr></table></figure><h3 id="3-VNC"><a class="header-anchor" href="#3-VNC">¶</a>3.VNC</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动VNC</span></span><br><span class="line">vncserver :1</span><br><span class="line">vncserver :2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#停止vncserver</span></span><br><span class="line">vncserver -<span class="built_in">kill</span> :1</span><br><span class="line">vncserver -<span class="built_in">kill</span> :2</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启服务</span></span><br><span class="line">service vncserver restart</span><br></pre></td></tr></table></figure><h3 id="4-抓包"><a class="header-anchor" href="#4-抓包">¶</a>4.抓包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启中间人</span></span><br><span class="line">ettercap -i eth0 -T -q -M ARP:remote  //ip1/ /ip2//</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出可以抓包的网络接口：</span></span><br><span class="line">sudo tcpdump -D</span><br><span class="line"></span><br><span class="line"><span class="comment">#tcpdump抓包</span></span><br><span class="line"><span class="comment">#抓取所有的经过eth0网卡的网络包，并存到result.cap 文件中</span></span><br><span class="line">tcpdump -i eth0 -w result.cap</span><br><span class="line"></span><br><span class="line"><span class="comment">#抓取源地址是192.168.1.100的包，并将结果保存到 result.cap 文件中</span></span><br><span class="line">tcpdump src host 192.168.1.100 and dest host 192.168.1.100 -w result.cap</span><br><span class="line"></span><br><span class="line"><span class="comment">#抓取源ip是192.168.1.100且目的端口是22，或源ip是192.168.1.102且目的端口是80的数据包</span></span><br><span class="line">tcpdump -i eth0 -vnn ( src host 192.168.1.100 and dst port 22 ) or ( src host 192.168.1.102 and dst port 80 )</span><br><span class="line"></span><br><span class="line"><span class="comment">#把抓取的数据包记录存到/tmp/result文件中，当抓取100个数据包后就退出程序</span></span><br><span class="line">tcpdump –i eth0 -vnn -w /tmp/result -c 100</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果想要获取主机192.168.1.100除了和主机192.168.1.101之外所有主机通信的ip包</span></span><br><span class="line">tcpdump ip host 192.168.1.100 and ! 192.168.1.101</span><br></pre></td></tr></table></figure><h3 id="5-扩容"><a class="header-anchor" href="#5-扩容">¶</a>5.扩容</h3><p>新建虚拟机时分配的磁盘空间不够大，导致用了一段时间会显示根目录空间不足;<br>以ubuntu 20.04为例，扩充磁盘空间<br>关闭虚拟机，编辑虚拟机设置，扩展硬盘；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h<span class="comment">#查看系统容量相关的数据</span></span><br><span class="line">sudo apt-get install gparted</span><br><span class="line">sudo gparted</span><br></pre></td></tr></table></figure><p>调整大小，并应用全部;</p>]]></content>
      
      
      <categories>
          
          <category> 平台-Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工控安全事件整理</title>
      <link href="/2022/07/26/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E6%95%B4%E7%90%86/"/>
      <url>/2022/07/26/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>终于来啦，杰哥的第二篇博客</p><span id="more"></span><h1>WORK</h1><p>整理一下目前收集的典型工控安全事件</p><h2 id="1-震网事件"><a class="header-anchor" href="#1-震网事件">¶</a>1.震网事件</h2><h3 id="事件"><a class="header-anchor" href="#事件">¶</a>事件 :</h3><p>2010年9月24日，伊朗核设施爆出Stuxnet病毒（“震网病毒”）攻击，导致其核设施不能正常运行。</p><h3 id="传播介质"><a class="header-anchor" href="#传播介质">¶</a>传播介质 :</h3><p>u盘</p><h3 id="攻击对象"><a class="header-anchor" href="#攻击对象">¶</a>攻击对象 :</h3><p>国家重要基础设施</p><h3 id="漏洞利用-："><a class="header-anchor" href="#漏洞利用-：">¶</a>漏洞利用 ：</h3><p>MS10-046、MS10-061、MS08-067、MS10-073、MS10-092<br>Stuxnet首先是感染外部主机，然后感染u盘，利用Link文件漏洞（MS10-046）传播到内网。<br>在内网中，通过快捷方式文件解析漏洞、RPC远程执行漏洞（MS08-067)、打印机后台程序服务漏洞（MS10-061），实现联网主机的传播（横向渗透），到达装有WIN CC的工作站。<br>当被感染的工作站连接到PLC，Stuxnet部署恶意代码，向PLC发送特定指令。<br>MS10-073、MS10-092用于提权。</p><h3 id="攻击过程-："><a class="header-anchor" href="#攻击过程-：">¶</a>攻击过程 ：</h3><p>Stuxnet蠕虫利用多个零日漏洞和U盘等移动设备在工业互联网中传播，最终目的是到达WIN CC主机。攻击者利用WIN CC存在的硬编码漏洞，窃取数据库信息，保存密码；利用项目文件加载DLL文件出错，窃取正常的生产数据。通过对得到的生产数据进行深入分析，可以构造恶意DLL文件，然后攻击者操纵固件替换恶意DLL，实现恶意操作。震网事件中，攻击者修改了数据库中的PID算法相关参数，导致离心机转速发生变化。为了防止安全操作员得到警报以及系统做出响应，攻击者可能采用重放攻击重放抓取的正常流量；或者修改报警设置，例如将内存代码修改为固定值或篡改汇编级指令代码。</p><h2 id="2-乌克兰电网事件"><a class="header-anchor" href="#2-乌克兰电网事件">¶</a>2.乌克兰电网事件</h2><h3 id="事件-v2"><a class="header-anchor" href="#事件-v2">¶</a>事件 :</h3><p>2015年12月23日，乌克兰电网遭遇突发停电事故。本次停电事故由7个变电站开关动作引起，导致80000个用户停电，停电时间为3到6小时不等。这次停电不是因为电力短缺，而是遭到了黑客攻击。</p><h3 id="传播介质-v2"><a class="header-anchor" href="#传播介质-v2">¶</a>传播介质 :</h3><p>恶意组件BlackEnergy（该恶意软件最早可追溯到2007年，由俄罗斯地下黑客组织开发并广泛使用，包括用来“刺探”全球各国的电力公司。）</p><h3 id="攻击对象-v2"><a class="header-anchor" href="#攻击对象-v2">¶</a>攻击对象 :</h3><p>乌克兰电力公司</p><h3 id="漏洞利用-：-v2"><a class="header-anchor" href="#漏洞利用-：-v2">¶</a>漏洞利用 ：</h3><p>CVE-2014-4114(OLE包管理INF 任意代码执行漏洞)<br><strong>安天工作室分析的攻击流程</strong><br>Office类型的漏洞利用(CVE-2014-4114)–&gt;邮件–&gt;下载恶意组件BlackEnergy侵入员工电力办公系统–&gt;BlackEnergy继续下载恶意组件(KillDisk)–&gt;擦除电脑数据破坏HMI软件监视管理系统<br><img src="/../pic/blackenergy%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B.jpg" alt="img"></p><h2 id="3-FLAME侵袭中东地区事件"><a class="header-anchor" href="#3-FLAME侵袭中东地区事件">¶</a>3.FLAME侵袭中东地区事件</h2><p>Flame ( Worm.Win32.Flame ，又称 Flamer 或 sKyWlper 、Skywiper 等），中文名“火焰病毒”、“超级火焰病毒”。Flame 被包括世界电信联盟等官方以及卡巴斯基等国际权威厂商认定为迄今为止最复杂、最危险、最致命的病毒威胁。</p><h3 id="事件-v3"><a class="header-anchor" href="#事件-v3">¶</a>事件:</h3><p>2012年5月，俄罗斯安全专家发现一种威力强大的电脑病毒火焰(Flame)在中东地区大范围传播。卡巴斯基称，Flame实际上是一个间谍工具包。至少过去两年中，Flame病毒已感染了伊朗、黎巴嫩、叙利亚、苏丹以及其他中东和北非国家的相应目标计算机系统。</p><h3 id="传播"><a class="header-anchor" href="#传播">¶</a>传播 :</h3><p>该病毒可以通过USB存储器以及网络复制和传播，并能接受来自世界各地多个服务器的指令。</p><h3 id="攻击对象-v3"><a class="header-anchor" href="#攻击对象-v3">¶</a>攻击对象 :</h3><p>个人计算机、国家机关甚至教育机构</p><h3 id="病毒危害-："><a class="header-anchor" href="#病毒危害-：">¶</a>病毒危害 ：</h3><p>一旦计算机被感染，Flame 可以激活其麦克风和摄像头，监控用户的键盘敲击，从保存的图像中提取地理定位数据，对正在运行的计算机进行屏幕截图，甚至通过蓝牙无线技术发送和接收命令和数据。</p><h3 id="关联病毒-："><a class="header-anchor" href="#关联病毒-：">¶</a>关联病毒 ：</h3><p>震网（Stuxnet)病毒、毒区(DuQu)病毒；“震网”病毒攻击的是伊朗核设施，“毒区”病毒攻击的是伊朗工业控制系统数据，而“火焰”病毒攻击的则是伊朗石油部门的商业情报。</p><h3 id="漏洞利用-：-v3"><a class="header-anchor" href="#漏洞利用-：-v3">¶</a>漏洞利用 ：</h3><p>MS10-046、MS10-061<br><strong>迈克菲绘制的的代码关系图</strong><br><img src="/../pic/flame%E4%BB%A3%E7%A0%81%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" alt="img"></p><p><strong>FLAME源码中各模块系列的代号及可能的用途</strong><br><img src="/../pic/FLAME%E7%BB%84%E4%BB%B6%E7%94%A8%E9%80%94%E5%9B%BE.png" alt="img"></p><p>工业互联网中不一定需要通过漏洞才能达到恶意目的，有的时候攻击者可以通过系统中的一系列正常操作达到恶意的目的。</p><h2 id="4-IRONGATE"><a class="header-anchor" href="#4-IRONGATE">¶</a>4.IRONGATE</h2><h3 id="事件-v4"><a class="header-anchor" href="#事件-v4">¶</a>事件 :</h3><p>恶意软件IRONGATE中使用了某些Stuxnet功能，只针对西门子公司生产的ICS/SCADA设备。</p><h3 id="攻击对象-v4"><a class="header-anchor" href="#攻击对象-v4">¶</a>攻击对象 :</h3><p>西门子ICS/SCADA系统</p><h3 id="攻击过程-：-v2"><a class="header-anchor" href="#攻击过程-：-v2">¶</a>攻击过程 ：</h3><p>恶意软件IRONGATE首先检测环境，如果没有发现虚拟化的环境则散播病毒程序，然后对目标机器实施中间人攻击以达到恶意操作。IRONGATE使用恶意DLL替换正常DLL，恶意DLL充当PLC与监控系统（SCADA）之间的中间人。恶意DLL记录并替换PLC到用户界面(HMI)的流量，再将构造的恶意数据发回PLC，导致操作过程不受管理员控制。</p><h2 id="5-PLC-Blaster"><a class="header-anchor" href="#5-PLC-Blaster">¶</a>5.PLC-Blaster</h2><h3 id="事件-v5"><a class="header-anchor" href="#事件-v5">¶</a>事件 :</h3><p>PLC-Blaster蠕虫实现了对S7 1200 PLC控制器程序的篡改攻击。</p><h3 id="传播介质-v3"><a class="header-anchor" href="#传播介质-v3">¶</a>传播介质 :</h3><p>TIA门户、移动设备</p><h3 id="攻击对象-v5"><a class="header-anchor" href="#攻击对象-v5">¶</a>攻击对象 :</h3><p>S7 1200 PLC</p><h3 id="攻击过程-：-v3"><a class="header-anchor" href="#攻击过程-：-v3">¶</a>攻击过程 ：</h3><p>PLC-Blaster可能通过U盘等移动设备或者在已感染的主机上扫描可能目标后，蠕虫仿冒TIA门户，并在感染阶段执行西门子专有协议，感染目标主机。感染时，PLC-Blaster将自身代码复制到目标PLC，篡改PLC控制逻辑。目标主机被感染后，PLC-Blaster会再次开始扫描，进行新一轮感染。</p><p>攻击者可以在不修改PLC逻辑指令或者固件的情况下，直接操纵物理过程。</p><h2 id="6-PLC-ROOTKIT"><a class="header-anchor" href="#6-PLC-ROOTKIT">¶</a>6.PLC ROOTKIT</h2><h3 id="事件-v6"><a class="header-anchor" href="#事件-v6">¶</a>事件:</h3><p>研究人员设计出新的恶意软件攻击方式，针对可编程逻辑控制器(PLC)，利用的是微处理器中的架构缺陷，可规避现有检测机制。</p><h3 id="攻击对象-v6"><a class="header-anchor" href="#攻击对象-v6">¶</a>攻击对象 :</h3><p>PLC、专用控制器</p><h3 id="攻击过程-：-v4"><a class="header-anchor" href="#攻击过程-：-v4">¶</a>攻击过程 ：</h3><p>PLC ROOTKIT在PLC操作系统不知道的情形下用恶意代码切换I/O引脚配置，从输出改成输入或反之。并且由于嵌入式设备(如PLC)所用片上系统(SoC)中，并没有用于引脚配置的硬件中断，因而试图向重配置成输入的引脚进行写入操作时，系统将不会收到任何报错。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
