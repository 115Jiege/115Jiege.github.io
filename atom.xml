<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiege</title>
  
  
  <link href="https://115jiege.github.io/atom.xml" rel="self"/>
  
  <link href="https://115jiege.github.io/"/>
  <updated>2023-03-15T02:10:20.604Z</updated>
  <id>https://115jiege.github.io/</id>
  
  <author>
    <name>Jiege</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>qt开发--实战1</title>
    <link href="https://115jiege.github.io/2023/03/13/%E7%A0%94%E5%8F%91/qt%E5%BC%80%E5%8F%91/qt%E5%BC%80%E5%8F%91--%E5%AE%9E%E6%88%981/"/>
    <id>https://115jiege.github.io/2023/03/13/%E7%A0%94%E5%8F%91/qt%E5%BC%80%E5%8F%91/qt%E5%BC%80%E5%8F%91--%E5%AE%9E%E6%88%981/</id>
    <published>2023-03-13T03:03:05.000Z</published>
    <updated>2023-03-15T02:10:20.604Z</updated>
    
    <content type="html"><![CDATA[<h1>未完</h1><h3 id="1-初级目标"><a class="header-anchor" href="#1-初级目标">¶</a>1.初级目标</h3><p>实现一下简单的qt开发，实现目标：<br>窗口中设置两个按钮(start,stop);<br>点击start按钮，提示连接成功或连接失败(及原因);<br>点击stop按钮，显示连接已断开。</p><h3 id="2-初步搭建"><a class="header-anchor" href="#2-初步搭建">¶</a>2.初步搭建</h3><h4 id="2-1-调用动态链接库"><a class="header-anchor" href="#2-1-调用动态链接库">¶</a>2.1 调用动态链接库</h4><p>1)新建QT Widgets Application工程(myWidget)，选择QWidget类;</p><p>2)引入工程文件(en)动态链接库:<br>将工程项目编译成动态链接库;(编写makefile,CFLAGS添加-fPIC -shared，连接时添加 -shared)<br>使用宏编译，对于多个宏，编译的时候可以选择:<br>“make p1=1<br>make p2=1”<br>myWidget工程右键-&gt;添加库-&gt;外部库-&gt;选择库文件-&gt;添加;</p><p>3)修改myWidget.pro文件:<br>添加qt组件:“QT += concurrent”;<br>添加宏开关:“DEFINES += p1”;<br>添加外部调用路径:&quot;INCLUDEPATH += /root/qt/en/include &quot;;</p><h4 id="2-2-框架设计"><a class="header-anchor" href="#2-2-框架设计">¶</a>2.2 框架设计</h4><p>1)添加按钮:<br>双击myWidget.ui文件，添加两个pushButton，修改类名为startButton、stopButton，修改按钮text为ustart、stop;<br>(此时需要先编译一次，生成build_myWidget_XXX_debug文件夹，包含ui生成的ui_myWidget.h头文件)</p><p>2)添加槽声明:<br>myWidget.h</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">conn</span>()</span>;          <span class="comment">//startButton连接函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disconn</span>()</span>;       <span class="comment">//startButton连接函数</span></span><br></pre></td></tr></table></figure><p>myWidget.cpp</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">myWidget::<span class="built_in">myWidget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(new Ui::myWidget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(this);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;startButton,&amp;QPushButton::clicked,this,&amp;myWidget::conn);     </span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;stopButton,&amp;QPushButton::clicked,this,&amp;myWidget::disconn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myWidget::<span class="built_in">conn</span>()    //槽函数定义</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">start</span>(sn_verify_pk,uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myWidget::<span class="built_in">disconn</span>()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">stop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3)处理函数输入:<br>add New-&gt;c class 添加c++类;<br>使用宏设置输入<br>stdafx.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SN_VERIFY_PK            <span class="string">&quot;04123456789XXXX&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SN_VERIFY_PK            <span class="string">&quot;123456789&quot;</span></span></span><br></pre></td></tr></table></figure><pre><code> 从函数中获取作为输入   int get_uuid(const char *cmd, int buf_size, char *result);</code></pre><p>4)设置连接状态（已连接、未连接）<br>添加bool型指针m_isConnected，监控连接状况;</p><p>myWidget.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::myWidget *ui;</span><br><span class="line">    std::atomic_bool m_isConnected;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showlabel</span><span class="params">(<span class="type">const</span> QString&amp; msg)</span></span>;       #声明label并显示输入字符串</span><br></pre></td></tr></table></figure><p>myWidget.cpp</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">myWidget::myWidget(QWidget *parent)</span><br><span class="line">    : QWidget(parent)</span><br><span class="line">    , ui(<span class="keyword">new</span> Ui::myWidget)</span><br><span class="line">    , m_isConnected(<span class="keyword">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line">    connect(ui-&gt;startButton,&amp;QPushButton::clicked,this,&amp;myWidget::conn);</span><br><span class="line"></span><br><span class="line">    connect(ui-&gt;stopButton,&amp;QPushButton::clicked,this,&amp;myWidget::disconn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myWidget::conn()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_isConnected)</span><br><span class="line">        &#123;</span><br><span class="line">            showlabel(QStringLiteral(<span class="string">&quot;请先断开连接！&quot;</span>));  #start之前判断是否已连接</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   start(sn_verify_pk,uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myWidget::disconn()</span><br><span class="line">&#123;</span><br><span class="line">   stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myWidget::showlabel(<span class="keyword">const</span> QString&amp; msg)</span><br><span class="line">&#123;</span><br><span class="line">    QLabel *label = <span class="keyword">new</span> QLabel();</span><br><span class="line">    label-&gt;resize(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">    label-&gt;setText(msg);</span><br><span class="line">    label -&gt;setAlignment(Qt::AlignCenter);</span><br><span class="line">    label-&gt;show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5)监控程序运行状态<br>添加自定义状态监控指针:<br>m_startResultwatcher //监控start()程序运行状态<br>m_stopResultwatcher  //监控stop()程序运行状态</p><p>myWidget.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_Started</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_Stopped</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showlabel</span><span class="params">(<span class="type">const</span> QString&amp; msg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::myWidget *ui;</span><br><span class="line">    std::atomic_bool m_isConnected;</span><br><span class="line">    QFutureWatcher&lt;<span class="type">en_state_t</span>&gt;* m_startResultwatcher;   <span class="comment">//start()函数返回en_state_t型指针</span></span><br><span class="line">    QFutureWatcher&lt;<span class="type">void</span>&gt;* m_stopResultwatcher;   <span class="comment">//stop()返回void</span></span><br></pre></td></tr></table></figure><p>myWidget.cpp</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;ENstate_t, QString&gt; g_errmsg</span><br><span class="line">&#123;</span><br><span class="line">    &#123; NO_RESPONSE, <span class="built_in">QStringLiteral</span>(<span class="string">&quot;未响应......&quot;</span>) &#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myWidget::<span class="built_in">myWidget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::myWidget)</span><br><span class="line">    , <span class="built_in">m_isConnected</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">m_startResultwatcher = <span class="keyword">new</span> <span class="built_in">QFutureWatcher</span>&lt;<span class="type">en_state_t</span>&gt;(<span class="keyword">this</span>);  <span class="comment">//监控start()</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;startButton,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;myWidget::conn);</span><br><span class="line"><span class="built_in">connect</span>(m_startResultwatcher, &amp;QFutureWatcher&lt;<span class="type">int</span>&gt;::finished, <span class="keyword">this</span>, &amp;myWidget::on_Started);   <span class="comment">//返回start()结果给on_Started函数</span></span><br><span class="line"></span><br><span class="line">m_stopResultwatcher = <span class="keyword">new</span> <span class="built_in">QFutureWatcher</span>&lt;<span class="type">void</span>&gt;(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;stopButton,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;myWidget::disconn);</span><br><span class="line">    <span class="built_in">connect</span>(m_stopResultwatcher, &amp;QFutureWatcher&lt;QString&gt;::finished, <span class="keyword">this</span>, &amp;myWidget::on_Stopped);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myWidget::conn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_isConnected)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">showlabel</span>(<span class="built_in">QStringLiteral</span>(<span class="string">&quot;请先断开连接！&quot;</span>));  <span class="meta">#start之前判断是否已连接</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     QFuture&lt;<span class="type">vpn_state_t</span>&gt; result = QtConcurrent::<span class="built_in">run</span>([=]()-&gt;<span class="type">vpn_state_t</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">start</span>(sn_verify_pk,uuid);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">        m_startResultwatcher-&gt;<span class="built_in">setFuture</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myWidget::disconn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;disconn called!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_isConnected) &#123;</span><br><span class="line"></span><br><span class="line">            QFuture&lt;<span class="type">void</span>&gt; result = QtConcurrent::<span class="built_in">run</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">                <span class="built_in">stop</span>();</span><br><span class="line">                &#125;);</span><br><span class="line">            m_stopResultwatcher-&gt;<span class="built_in">setFuture</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myWidget::on_Started</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">_state_t</span> result = m_startResultwatcher-&gt;<span class="built_in">future</span>().<span class="built_in">result</span>();</span><br><span class="line">        <span class="keyword">if</span> (result != OK) &#123;</span><br><span class="line">            <span class="built_in">qCritical</span>() &lt;&lt; <span class="string">&quot;start__service failed, result=&quot;</span> &lt;&lt; result;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g_errmsg.<span class="built_in">find</span>(result) != g_errmsg.<span class="built_in">end</span>())</span><br><span class="line">                <span class="built_in">showlabel</span>(g_errmsg[result]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">showlabel</span>(<span class="built_in">QStringLiteral</span>(<span class="string">&quot;启动失败，返回的错误码为：%1&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            m_isConnected = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">showlabel</span>(<span class="built_in">QStringLiteral</span>(<span class="string">&quot;已连接&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;on_Started executed.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myWidget::on_Stopped</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_isConnected = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;on_Stopped executed.&quot;</span>;</span><br><span class="line"><span class="built_in">showlabel</span>(<span class="built_in">QStringLiteral</span>(<span class="string">&quot;已断开。&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>okay，本次就是初步搭建出工程，编译运行后，点击start按钮:start启动成功，弹出窗口显示&quot;已连接！“;连接失败，显示失败原因;<br>点击stop按钮:stop启动成功，弹出窗口显示&quot;已断开”;断开失败，qdebug显示失败原因;<br>下一章研究一下按钮功能的完善，学习一下按钮的禁用以及颜色的改变。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;未完&lt;/h1&gt;
&lt;h3 id=&quot;1-初级目标&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#1-初级目标&quot;&gt;¶&lt;/a&gt;1.初级目标&lt;/h3&gt;
&lt;p&gt;实现一下简单的qt开发，实现目标：&lt;br&gt;
窗口中设置两个按钮(start,stop);&lt;br&gt;
点击s</summary>
      
    
    
    
    <category term="研发" scheme="https://115jiege.github.io/categories/%E7%A0%94%E5%8F%91/"/>
    
    
    <category term="qt开发" scheme="https://115jiege.github.io/tags/qt%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>qt开发-4</title>
    <link href="https://115jiege.github.io/2023/03/07/%E7%A0%94%E5%8F%91/qt%E5%BC%80%E5%8F%91/qt%E5%BC%80%E5%8F%91-4/"/>
    <id>https://115jiege.github.io/2023/03/07/%E7%A0%94%E5%8F%91/qt%E5%BC%80%E5%8F%91/qt%E5%BC%80%E5%8F%91-4/</id>
    <published>2023-03-07T00:53:53.000Z</published>
    <updated>2023-03-13T03:15:32.997Z</updated>
    
    <content type="html"><![CDATA[<p>本节学习Qt中的进程,Qt的QProcess类用来启动一个外部程序并与其通信。</p><span id="more"></span><h3 id="1-进程的运行"><a class="header-anchor" href="#1-进程的运行">¶</a>1.进程的运行</h3><h4 id="1-1进程的运行过程"><a class="header-anchor" href="#1-1进程的运行过程">¶</a>1.1进程的运行过程</h4><p>1)使用start()函数启动一个进程，参数是程序名称和使用的命令行参数;<br>2)执行完start()函数后，OProcess进入Starting状态;程序已经运行后，OProcess进入Running状态并发射started()信号；<br>3)进程退出后，QProcess重新进入NoTRunning状态(初始状态)并发射finished信号。发射的finished信号提供了程序的推出代码和退出状态，使用exitCode()和exitStatus()获取。<br>4)任何时间发生了错误，QProcess都会发射error()信号，调用errot()查看错误类型和上次发生的错误,使用staus()查看当前进程的状态。</p><p>QProcess允许将一个进程视为一个顺序I/O设备，允许读写进程。调用write()写入输入，调用read()、readLine()、getChar()等读取输出。<br><em>QProcess继承自QIODevice，可以作为QXmlReader的数据源，或者为QNetworkAccessManager产生用于上传的数据。</em></p><h4 id="1-2-示例"><a class="header-anchor" href="#1-2-示例">¶</a>1.2 示例</h4><p>例：源码 src/19/19-1/myprocess<br>//启动进程<br>mainwindow.h中添加私有对象QProcess myprocess;<br>在按钮的单击信号槽调用进程启动函数;</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void MainWindow::on_pushButton_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    myProcess.start(<span class="string">&quot;netstat -ntlp&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line">   </span><br><span class="line">   process.start()的使用</span><br><span class="line">   </span><br><span class="line">|<span class="string"> Tittle1 </span>|<span class="string"> Tittle2 </span>|<span class="string"> Tittle3 </span>|</span><br><span class="line">|<span class="string"> :------ </span>|<span class="string"> :-----: </span>|<span class="string"> ------: </span>|</span><br><span class="line">|<span class="string"> Content </span>|<span class="string"> Content </span>|<span class="string"> Content </span>|</span><br><span class="line">|<span class="string"> Content </span>|<span class="string"> Content </span>|<span class="string"> Content </span>|</span><br><span class="line">   //关联QProcess信号</span><br><span class="line">   mainwindow.h添加私有槽说明;</span><br></pre></td></tr></table></figure><pre><code>void showResult();void showState(QProcess::ProcessState);void showError();void showFinished(int,QProcess::ExitStatus);</code></pre><pre><code>   mainwindow.cpp添加信号和槽的关联;   </code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本节学习Qt中的进程,Qt的QProcess类用来启动一个外部程序并与其通信。&lt;/p&gt;</summary>
    
    
    
    <category term="研发" scheme="https://115jiege.github.io/categories/%E7%A0%94%E5%8F%91/"/>
    
    
    <category term="qt开发" scheme="https://115jiege.github.io/tags/qt%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>qt开发-3</title>
    <link href="https://115jiege.github.io/2023/03/06/%E7%A0%94%E5%8F%91/qt%E5%BC%80%E5%8F%91/qt%E5%BC%80%E5%8F%91-3/"/>
    <id>https://115jiege.github.io/2023/03/06/%E7%A0%94%E5%8F%91/qt%E5%BC%80%E5%8F%91/qt%E5%BC%80%E5%8F%91-3/</id>
    <published>2023-03-06T01:20:24.000Z</published>
    <updated>2023-03-13T03:15:27.736Z</updated>
    
    <content type="html"><![CDATA[<p>上一节学习了qt进行事件传递的过程，这一节看一下事件过滤器获取事件的顺序以及鼠标和滚轮事件。</p><span id="more"></span><h3 id="1-事件过滤器"><a class="header-anchor" href="#1-事件过滤器">¶</a>1.事件过滤器</h3><p>例：源码 src/06/6-2/myevent<br>mylineedit.cpp定义函数,MyLineEdit的evebt()函数中使用了QEvent的type()函数获取事件类型，如果是键盘按下事件QEvent::KeyPress则输出信息。<br>（event()函数返回bool型操作结果）</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool MyLineEdit::<span class="keyword">event</span>(QEvent *<span class="keyword">event</span>)  <span class="comment">// 事件</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="keyword">event</span>-&gt;<span class="keyword">type</span>() == QEvent::KeyPress)</span><br><span class="line">      qDebug() &lt;&lt; tr(<span class="string">&quot;MyLineEdit的event()函数&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> QLineEdit::<span class="keyword">event</span>(<span class="keyword">event</span>);   <span class="comment">// 执行QLineEdit类event()函数的默认操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>widget.cpp添加事件过滤器函数定义</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> Widget::event<span class="constructor">Filter(QObject <span class="operator">*</span><span class="params">obj</span>, QEvent <span class="operator">*</span><span class="params">event</span>)</span> <span class="comment">// 事件过滤器</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(obj<span class="operator"> == </span>lineEdit)&#123;           <span class="comment">// 如果是lineEdit部件上的事件</span></span><br><span class="line">      <span class="keyword">if</span>(event-&gt;<span class="keyword">type</span><span class="literal">()</span><span class="operator"> == </span>QEvent::KeyPress)</span><br><span class="line">         q<span class="constructor">Debug()</span> &lt;&lt; tr(<span class="string">&quot;Widget的事件过滤器&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   return QWidget::event<span class="constructor">Filter(<span class="params">obj</span>, <span class="params">event</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在事件过滤器中，先判断事件的对象是不是lineEdit，是则判断事件类型，最后返回QWidget默认的事件过滤器的执行结果。<br>运行结果:“Widget的事件过滤器” “MyLineEdit的event()函数” “MyLineEdit键盘按下事件” “Widget键盘按下事件”;</p><p>事件的传递顺序:<br>（Widget窗口启动，声明MyLineEdit类对象lineEdit，移动位置到坐标(100,100),在Widget上为lineEdit安装事件过滤器)<br>事件进入事件过滤器(Widget部件)，判断事件的对象是不是lineEdit，是则判断事件类型；判断是否为键盘按下事件，返回事件过滤器执行结果；<br>进入焦点部件(lineEdit部件)的event(),获取事件类型，如果是键盘按下事件QEvent::KeyPress则输出信息，返回event操作结果;<br>进入焦点部件的事件处理函数(keyPressEvent)，如果焦点部件忽略了该事件(“event-&gt;ignore();”)，则执行父部件的事件处理函数。</p><h3 id="2-鼠标事件和滚轮事件"><a class="header-anchor" href="#2-鼠标事件和滚轮事件">¶</a>2.鼠标事件和滚轮事件</h3><h4 id="2-1鼠标事件"><a class="header-anchor" href="#2-1鼠标事件">¶</a>2.1鼠标事件</h4><p>QMouseEvent类用来表示一个鼠标事件，QWheelEvent类用来表示鼠标滚轮事件。<br>例：源码 src/06/6-3/myevent</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QCursor <span class="attribute">cursor</span>;                 <span class="comment">// 创建光标对象</span></span><br><span class="line"><span class="attribute">cursor</span><span class="selector-class">.setShape</span>(Qt::OpenHandCursor); <span class="comment">// 设置光标形状</span></span><br><span class="line"><span class="built_in">setCursor</span>(cursor);               <span class="comment">// 使用光标</span></span><br></pre></td></tr></table></figure><p>鼠标指针进入窗口后改为小手形状;</p><p>1)鼠标按压事件</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void Widget::mouse<span class="constructor">PressEvent(QMouseEvent <span class="operator">*</span><span class="params">event</span>)</span> <span class="comment">// 鼠标按下事件</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(event-&gt;button<span class="literal">()</span><span class="operator"> == </span>Qt::LeftButton)&#123;      <span class="comment">// 如果是鼠标左键按下</span></span><br><span class="line">      QCursor cursor;</span><br><span class="line">      cursor.set<span class="constructor">Shape(Qt::PointingHandCursor)</span>;</span><br><span class="line">      QApplication::set<span class="constructor">OverrideCursor(<span class="params">cursor</span>)</span>; <span class="comment">// 使鼠标指针暂时改变形状</span></span><br><span class="line">      offset = event-&gt;global<span class="constructor">Pos()</span> - pos<span class="literal">()</span>;   <span class="comment">//获取指针位置(x1,y1)和窗口位置(a1,b1)的差值</span></span><br><span class="line">      <span class="comment">//offset = event-&gt;pos();</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(event-&gt;button<span class="literal">()</span><span class="operator"> == </span>Qt::RightButton)&#123; <span class="comment">// 如果是鼠标右键按下</span></span><br><span class="line">      QCursor cursor(<span class="constructor">QPixmap(<span class="string">&quot;../mymouseevent/logo.png&quot;</span>)</span>);</span><br><span class="line">      QApplication::set<span class="constructor">OverrideCursor(<span class="params">cursor</span>)</span>;<span class="comment">// 使用自定义的图片作为鼠标指针</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用globalPos()函数获取鼠标指针位置(在桌面上的位置)，还可以使用QMouseEvent类的pos()函数获取鼠标指针在窗口中的位置;<br>(“offset = event-&gt;pos();”)</p><p>2)鼠标释放事件</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Widget::mouse<span class="constructor">ReleaseEvent(QMouseEvent <span class="operator">*</span><span class="params">event</span>)</span> <span class="comment">// 鼠标释放事件</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="constructor">Q_UNUSED(<span class="params">event</span>)</span>;</span><br><span class="line">   QApplication::restore<span class="constructor">OverrideCursor()</span>;       <span class="comment">// 恢复鼠标指针形状</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了restoreOverrideCursor()函数恢复鼠标形状，restoreOverrideCursor()函数要和setOverrideCursor()函数配合使用，不然event的参数没有使用到，编译时会出现警告。<br>使用<code>Q_UNUSED(event);</code>语句可以防止警告。</p><p>3)鼠标移动事件</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Widget::mouseMoveEvent(QMouseEvent *<span class="keyword">event</span>) <span class="comment">// 鼠标移动事件</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="keyword">event</span>-&gt;buttons() &amp; Qt::LeftButton)&#123;     <span class="comment">// 这里必须使用buttons()</span></span><br><span class="line">      QPoint temp;</span><br><span class="line">      temp = <span class="keyword">event</span>-&gt;globalPos() - offset;</span><br><span class="line">      <span class="keyword">move</span>(temp);<span class="comment">// 使用鼠标指针当前的位置(x2,y2)减去差值，就得到了窗口应该移动的位置(x2-x1+a1,y2-y1+b1)</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鼠标移动时会检测所有按下的键，此时QMouseEvent的button()函数无法获取被按下的按键；<br>所以使用buttons()函数获取所有按下的键，并与 Qt::LeftButton进行按位与的方法，判断目前鼠标的联合状态中是否包含了鼠标左键。</p><p>如果想不按鼠标按键，也可以获取鼠标移动事件，可以添加代码<code>setMouseTracking(true);</code><br>需要注意：<br>单独一个widgt如果mouseMove不执行需要设置setMouseTracking(true);<br>如果有子窗口，需要子窗口也设置setMouseTracking(true),否则子窗口区域捕获不到鼠标移动;<br>子窗口重写了mouseMoveEvent，需要在函数结尾调用父类的mosueMoveEvent，不然会在子窗口被截获;<br>对于一些特殊的窗口本身就带好几层窗口，需要把每一层都设置setMouseTracking(true);</p><p>4)鼠标双击事件</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> Widget<span class="type">::mouseDoubleClickEvent</span>(QMouseEvent *event) <span class="comment">// 鼠标双击事件</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(event-&gt;button() == Qt<span class="type">::LeftButton</span>)&#123;          <span class="comment">// 如果是鼠标左键按下</span></span><br><span class="line">      <span class="keyword">if</span>(windowState() != Qt<span class="type">::WindowFullScreen</span>)     <span class="comment">// 如果现在不是全屏</span></span><br><span class="line">         setWindowState(Qt<span class="type">::WindowFullScreen</span>);     <span class="comment">// 将窗口设置为全屏</span></span><br><span class="line">      <span class="keyword">else</span> setWindowState(Qt<span class="type">::WindowNoState</span>);      <span class="comment">// 否则恢复以前的大小</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5)鼠标滚轮事件</p><pre><code>void Widget::wheelEvent(QWheelEvent *event)   // 滚轮事件&#123;   if(event-&gt;delta() &gt; 0)&#123;               // 当滚轮远离使用者时      ui-&gt;textEdit-&gt;zoomIn();            // 进行放大   &#125;else&#123;                            // 当滚轮向使用者方向旋转时      ui-&gt;textEdit-&gt;zoomOut();            // 进行缩小   &#125;&#125;</code></pre><p>使用QWheelEvent类delta()函数获取滚轮的距离，每当滚轮旋转一下，默认是15°。当滚轮向使用者方向旋转时，返回正值；当滚轮远离使用者时，返回负值。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节学习了qt进行事件传递的过程，这一节看一下事件过滤器获取事件的顺序以及鼠标和滚轮事件。&lt;/p&gt;</summary>
    
    
    
    <category term="研发" scheme="https://115jiege.github.io/categories/%E7%A0%94%E5%8F%91/"/>
    
    
    <category term="qt开发" scheme="https://115jiege.github.io/tags/qt%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>qt开发-2</title>
    <link href="https://115jiege.github.io/2023/03/03/%E7%A0%94%E5%8F%91/qt%E5%BC%80%E5%8F%91/qt%E5%BC%80%E5%8F%91-2/"/>
    <id>https://115jiege.github.io/2023/03/03/%E7%A0%94%E5%8F%91/qt%E5%BC%80%E5%8F%91/qt%E5%BC%80%E5%8F%91-2/</id>
    <published>2023-03-03T05:23:55.000Z</published>
    <updated>2023-03-14T00:24:57.938Z</updated>
    
    <content type="html"><![CDATA[<p>继续学习qt开发，想做点花里胡哨的~~</p><span id="more"></span><h3 id="1-自定义C-类"><a class="header-anchor" href="#1-自定义C-类">¶</a>1.自定义C++类</h3><p>1)新建项目;<br>2)添加文件(C++ class);<br>3)main.cpp中引用HelloDialog类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hellodialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">QApplication <span class="title">a</span><span class="params">(argc,argv)</span></span>;</span><br><span class="line">   HelloDialog w;</span><br><span class="line">   w.<span class="built_in">show</span>();</span><br><span class="line">   <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4)添加ui文件;<br>5)修改C<ins>头文件，在新建的C</ins>类中使用ui文件;<br>头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELLODIALOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELLODIALOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDialog&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloDialog</span>;   <span class="comment">/*声明HelloDialog类，这个类是在之前ui生成的头文件中提到的*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloDialog</span> : <span class="keyword">public</span> QDialog   <span class="comment">/*新定义的继承于QDalog的类*/</span></span><br><span class="line">&#123;</span><br><span class="line">   Q_OBJECT   <span class="comment">/*定义可扩展c++功能的宏*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:         </span><br><span class="line">   <span class="function"><span class="keyword">explicit</span> <span class="title">HelloDialog</span><span class="params">(QWidget * parent = <span class="number">0</span>)</span></span>;      <span class="comment">/*显式构造函数，参数用于指定父窗口，默认没有父窗口*/</span></span><br><span class="line">   ~<span class="built_in">HelloDialog</span>();      <span class="comment">/*析构函数*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   Ui::HelloDialog * ui;   <span class="comment">/*定义HelloDialog类对象的指针*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HELLODIALOG_H</span></span></span><br></pre></td></tr></table></figure><p>源码文件</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">include</span> <span class="string">&quot;hellodialog.h&quot;</span></span><br><span class="line">#<span class="keyword">include</span> <span class="string">&quot;ui_hellodialog.h&quot;</span></span><br><span class="line"></span><br><span class="line">HelloDialog::<span class="constructor">HelloDialog(QWidget <span class="operator">*</span> <span class="params">parent</span>)</span>:</span><br><span class="line">&#123;</span><br><span class="line">   <span class="constructor">QDialog(<span class="params">parent</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   ui = <span class="keyword">new</span> Ui::HelloDialog;   <span class="comment">/*创建新对象*/</span></span><br><span class="line">   ui-&gt;setup<span class="constructor">Ui(<span class="params">this</span>)</span>;   <span class="comment">/*表示现在这个类所代表的对话框创建页面*/</span></span><br><span class="line">&#125;</span><br><span class="line">HelloDialog::~<span class="constructor">HelloDialog()</span></span><br><span class="line">&#123;</span><br><span class="line">   delete ui;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-窗口、子部件、窗口类型"><a class="header-anchor" href="#2-窗口、子部件、窗口类型">¶</a>2.窗口、子部件、窗口类型</h3><h4 id="2-1窗口及子部件"><a class="header-anchor" href="#2-1窗口及子部件">¶</a>2.1窗口及子部件</h4><p>窗口部件(Widget)是Qt中设计用户页面的主要元素。</p><p>例：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;QtWidgets&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc,<span class="built_in">char</span> *argv<span class="literal">[]</span>)</span><br><span class="line">&#123;</span><br><span class="line">   QApplication a(argc,argv);</span><br><span class="line">   QWidget<span class="operator"> * </span>widget = <span class="keyword">new</span> <span class="constructor">QWidget()</span>;    <span class="comment">/*默认参数是零，所以是窗口*/</span></span><br><span class="line">   widget-&gt;set<span class="constructor">WindowTitle(QObject::<span class="params">tr</span>(<span class="string">&quot;I am widget.&quot;</span>)</span>);</span><br><span class="line"></span><br><span class="line">   QLabel<span class="operator"> * </span>label = <span class="keyword">new</span> <span class="constructor">QLabel()</span>;      <span class="comment">/*同上，是窗口*/</span></span><br><span class="line">   label-&gt;set<span class="constructor">WindowTitle(QObject::<span class="params">tr</span>(<span class="string">&quot;I am label.&quot;</span>)</span>);</span><br><span class="line">   label-&gt;set<span class="constructor">Text(QObject::<span class="params">tr</span>(<span class="string">&quot;label:I am a window.&quot;</span>)</span>);</span><br><span class="line">   label-&gt;resize(<span class="number">200</span>，<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">   QLabel<span class="operator"> * </span>label2 = <span class="keyword">new</span> <span class="constructor">QLabel(<span class="params">widget</span>)</span>;   <span class="comment">/*创建QLable类对象，指定父窗口是widget*/</span></span><br><span class="line">   label2-&gt;set<span class="constructor">Text(QObject::<span class="params">tr</span>(<span class="string">&quot;label2:I am not a window,just a child of widget.&quot;</span>)</span>);</span><br><span class="line">   label2-&gt;resize(<span class="number">300</span>,<span class="number">100</span>);</span><br><span class="line">   <span class="comment">//label2-&gt;move(150,50);  /*移动label2的位置，导致widget父窗口尺寸 += label2尺寸*/</span></span><br><span class="line"></span><br><span class="line">   label-&gt;show<span class="literal">()</span>;</span><br><span class="line">   widget-&gt;show<span class="literal">()</span>;</span><br><span class="line">   <span class="built_in">int</span> ret = a.exec<span class="literal">()</span>;</span><br><span class="line">   delete label;</span><br><span class="line">   delete widget;</span><br><span class="line">   return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2窗口分类"><a class="header-anchor" href="#2-2窗口分类">¶</a>2.2窗口分类</h4><p>窗口一般有标题栏和边框，但是这不是必须的。<br>QWidget的构造函数有两个参数:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QWidget * parent =<span class="number">0</span>;   <span class="regexp">/*默认值parent值为零，表示没有父窗口*/</span></span><br><span class="line">Qt::WiwdowFlags f =<span class="number">0</span>;   <span class="regexp">/*参数f是窗口类型的枚举值或组合*/</span></span><br></pre></td></tr></table></figure><h4 id="2-3-多窗口切换"><a class="header-anchor" href="#2-3-多窗口切换">¶</a>2.3 多窗口切换</h4><p>1)信号和槽<br>信号和槽都是函数。<br>例：src/03/3-4<br>目标：单击按钮弹出对话框。<br>ui界面添加Push Button(start、stop)，修改窗口类属性名;<br>头文件添加槽声明:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">showconn</span>()</span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">showdisconn</span>()</span>;</span><br></pre></td></tr></table></figure><p>cpp添加槽的实现:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QLabel *<span class="built_in">label</span> = <span class="built_in">new</span> QLabel();</span><br><span class="line"><span class="built_in">label</span>-&gt;setText(QObject::<span class="built_in">tr</span>(<span class="string">&quot;Connect.&quot;</span>));</span><br><span class="line"><span class="built_in">label</span>-&gt;resize(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line"><span class="built_in">label</span>-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure><p>更改窗口构造函数:<br>“connect(ui-&gt;startButton, &amp;QPushButton::clicked,this, &amp;MyWidget::showconn);”<br>使用connect()函数将单击信号clicked()与新建的槽进行关联,参数(发射信号的对象，发射的信号，接收信号的对象，要执行的槽);</p><p>2)自定义对话框<br>待续~</p><h3 id="3-qt中的事件"><a class="header-anchor" href="#3-qt中的事件">¶</a>3.qt中的事件</h3><p>Qt中使用一个对象来表示一个事件，继承自QEvent类。事件与信号不同，例：点击按钮会产生鼠标事件QMouseEvent，而因为按钮被按下了，所以会发射clicked单击信号。<br>这里一般只关心按钮的clicked信号，但是如果要考虑点击按钮使它产生别的东西，就要担心鼠标事件了。在Qt中，任何QObject子类实例都可以接受和处理事件。</p><h4 id="3-1事件的处理"><a class="header-anchor" href="#3-1事件的处理">¶</a>3.1事件的处理</h4><p>一个事件有一个特定的QEvent子类来表示，但是有事一个事件又包含多个事件类型，比如鼠标事件可以分为：鼠标单击、鼠标双击、鼠标移动等操作。<br>这些事件类型可以用QEvent::Type来表示，而对于事件的处理有五种方法：<br>1)重新实现不见的paintEvent()、mousePressEvent()等事件处理函数，只能用于处理特定部件的特定事件;<br>2)重新实现notify()函数，一次只能处理一个事件;<br>3)向QApplication对象上安装事件过滤器，功能和notify相同，并可以同时处理多个事件;<br>4)重新实现event()函数。QObject类的event()函数可以在事件达到默认的事件处理函数之前获得该事件;<br>5)在对象上安装事件过滤器;<br>实际编程中常用1)、5)。</p><h4 id="3-2事件的传递"><a class="header-anchor" href="#3-2事件的传递">¶</a>3.2事件的传递</h4><p>每个main()函数最后都会调用QApplication类的exec()函数，这使得Qt应用程序进入事件循环，可以接收到运行时发生的各种事件。<br>一但事件发生，Qt会构建一个QEvent子类的对象并传递给相应的QObject对象或其子对象。</p><p>例：<a href="https://www.yafeilinux.com/">源码</a> src/06/6-1/myevent</p><p>//自定义一个继承自QLineEdit的MyLineEdit类，添加事件处理函数定义</p><p>mylineedit.h</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">MyLineEdit</span> : <span class="symbol">public</span> <span class="symbol">QLineEdit</span></span><br><span class="line">&#123;</span><br><span class="line">   Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">explicit</span> MyLineEdit(QWidget *parent = <span class="number">0</span>);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="built_in">void</span> keyPressEvent(QKeyEvent *event);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>mylineedit.cpp</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyLineEdit::<span class="constructor">MyLineEdit(QWidget <span class="operator">*</span><span class="params">parent</span>)</span> :</span><br><span class="line">   <span class="constructor">QLineEdit(<span class="params">parent</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MyLineEdit::key<span class="constructor">PressEvent(QKeyEvent <span class="operator">*</span><span class="params">event</span>)</span> <span class="comment">// 键盘按下事件</span></span><br><span class="line">&#123;</span><br><span class="line">   q<span class="constructor">Debug()</span> &lt;&lt; tr(<span class="string">&quot;MyLineEdit键盘按下事件&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//在Widget界面添加一个MyLineEdit部件，实现MyLineEdit类的键盘按下事件处理函数和Widget类的键盘按下事件处理函数</p><p>widget.h</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLineEdit</span>;      <span class="comment">//MyLineEdit类前置声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">   ···</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   ···</span><br><span class="line">   MyLineEdit *lineEdit;      <span class="comment">//对象指针</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="keyword">void</span> keyPressEvent(QKeyEvent *event);      <span class="comment">//函数声明</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>widget.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylineedit.h&quot;</span>      <span class="comment">//添加头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QKeyEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent) :</span><br><span class="line">   <span class="built_in">QWidget</span>(parent),</span><br><span class="line">   <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">   ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">   lineEdit = <span class="keyword">new</span> <span class="built_in">MyLineEdit</span>(<span class="keyword">this</span>);   <span class="comment">//Widget类构造函数中添加代码</span></span><br><span class="line">   lineEdit-&gt;<span class="built_in">move</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::keyPressEvent</span><span class="params">(QKeyEvent *event)</span>   <span class="comment">//添加事件处理函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">tr</span>(<span class="string">&quot;Widget键盘按下事件&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行程序只显示&quot;MyLineEdit键盘按下事件&quot;，在mylineedit.cpp中添加:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QLineEdit::<span class="built_in">keyPressEvent</span>(event);        <span class="comment">// 执行QLineEdit类的默认事件处理</span></span><br><span class="line">event-&gt;<span class="built_in">ignore</span>();                    <span class="comment">// 忽略该事件</span></span><br></pre></td></tr></table></figure><p>运行程序显示&quot;MyLineEdit键盘按下事件&quot;,“Widget键盘按下事件”。这表明事件是先传递给指定窗口部件(MyLineEdit)，如果该部件忽略该事件，则会传递给其父部件(Widget)。<br>重新实现事件处理函数时，一般要调用父类(QLineEdit)的相应事件处理函数来实现默认操作。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;继续学习qt开发，想做点花里胡哨的~~&lt;/p&gt;</summary>
    
    
    
    <category term="研发" scheme="https://115jiege.github.io/categories/%E7%A0%94%E5%8F%91/"/>
    
    
    <category term="qt开发" scheme="https://115jiege.github.io/tags/qt%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>qt开发-1</title>
    <link href="https://115jiege.github.io/2023/03/01/%E7%A0%94%E5%8F%91/qt%E5%BC%80%E5%8F%91/qt%E5%BC%80%E5%8F%91-1/"/>
    <id>https://115jiege.github.io/2023/03/01/%E7%A0%94%E5%8F%91/qt%E5%BC%80%E5%8F%91/qt%E5%BC%80%E5%8F%91-1/</id>
    <published>2023-03-01T07:05:40.000Z</published>
    <updated>2023-03-13T03:15:18.802Z</updated>
    
    <content type="html"><![CDATA[<p>Qt是一个完整的开发框架，其工具旨在简化桌面，嵌入式和移动平台的应用程序和用户界面的创建。</p><span id="more"></span><h3 id="1-项目环境："><a class="header-anchor" href="#1-项目环境：">¶</a>1.项目环境：</h3><p>linux平台：ubuntu20.04 Qt5<br>apt-get安装，参考文章(<a href="https://blog.csdn.net/weixin_48560325/article/details/124373125">https://blog.csdn.net/weixin_48560325/article/details/124373125</a>)</p><p>android平台：android studio(待开发)</p><h3 id="2-Qt开发–hello-world"><a class="header-anchor" href="#2-Qt开发–hello-world">¶</a>2.Qt开发–hello world</h3><h4 id="2-1-使用示例程序"><a class="header-anchor" href="#2-1-使用示例程序">¶</a>2.1 使用示例程序</h4><p>1)使用Qt新建一个hello world程序，使得应用程序可以显示&quot;hello world&quot;字符串。</p><p>2)打开QtCreator新建项目:文件-&gt;新建文件或项目(或者 Ctrl + N);<br>选择Application-&gt;Qt Wigests Application,填写项目信息，基类选择QDialog(Details-&gt;基类);<br>建立完成后QtCreator会直接打开项目文件，打开helloworld.ui进行设计;<br>Filter中搜索Label，左键拖入中间的主设计区，双击输入&quot;Hello World&quot;。</p><p>3)使用快捷键 Ctrl + R 或者点击左下角运行程序，此时项目路径下多了一个build-XXX-unknown-Debug文件夹;<br>内有cpp源文件，生成的.o中间文件，以及可执行程序。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Windows平台：</span><br><span class="line">   生成.exe文件,运行需要把安装路径下的Qt5Cored.dll等文件复制到<span class="keyword">Debug</span>文件中，或者直接添加环境变量;</span><br><span class="line">   发布:使用QtCreator进行<span class="keyword">release</span>版本的编译(构建-&gt;打开构建套件选择器-&gt;选择构建目标为<span class="keyword">release</span>);</span><br></pre></td></tr></table></figure><h4 id="2-2-Qt-Creator纯代码并编写程序"><a class="header-anchor" href="#2-2-Qt-Creator纯代码并编写程序">¶</a>2.2 Qt Creator纯代码并编写程序</h4><p>1)新建空项目(其他项目-&gt;empty qmake project)。</p><p>2)<a href="http://xn--XXX-t29h961e.pro">编辑XXX.pro</a>:添加&quot;greaterThan (QT_MAJOR_VERSION, 4): QT += widgets&quot;。<br>(linux平台&quot;greaterThan(QT_MAJOR_VERSION, 4): QT + = widgets&quot;会报&quot;Assignment needs exactly one word on the left hand side.&quot;)</p><p>3)项目添加main.cpp源文件,右键-&gt;add new-&gt;c++ source;<br>编辑main.cpp:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc,argv)</span></span>;     <span class="comment">//每个Qt Wigests程序都要有一个QApplication类对象，用于管理应用程序的资源;</span></span><br><span class="line">    QDialog w;                  <span class="comment">//实现一个对话框界面</span></span><br><span class="line">    w.<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">300</span>);            <span class="comment">//调整对话框尺寸(宽，高)</span></span><br><span class="line">    <span class="function">QLabel <span class="title">label</span><span class="params">(&amp;w)</span></span>;            <span class="comment">//以QDialog对象为参数，新建QLabel对象；表示对话框是其父窗口。</span></span><br><span class="line">    label.<span class="built_in">setText</span>(<span class="string">&quot;Hello world!&quot;</span>);   <span class="comment">//设置标签要显示的字符串</span></span><br><span class="line">    label.<span class="built_in">move</span>(<span class="number">150</span>, <span class="number">120</span>);         <span class="comment">//调整标签位置</span></span><br><span class="line">    w.<span class="built_in">show</span>();                  <span class="comment">//显示对话框</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();            <span class="comment">//使QApplication对象进入事件循环，程序运行是可以接受产生的事件(单击，键盘按下等)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>快速查看帮助</strong>：<br>将鼠标指针放到类名或者函数上，按F1可以在编辑器右边快速打开帮助文档。</p><p>除了使用Qt Creator编译程序外，还可以使用其他编辑器(ed:Windows 记事本)编写源码，然后打开Qt5.X for Desktop使用命令行编译.</p><h4 id="2-3-使用-ui文件"><a class="header-anchor" href="#2-3-使用-ui文件">¶</a>2.3 使用.ui文件</h4><p>1)同上，在项目文件中添加.ui文件(add new-&gt;Qt-&gt;Qt Designer Form-&gt;Diagog without buttons);</p><p>2)双击.ui文件进入设计模式，在.ui文件中添加Label标签，在属性栏geoetry中修改坐标(= label.move());<br>Ctrl + 2 回到编辑模式(XML文件);</p><p>3)Ctrl + Shift + B 或 左下方块构建工程(仅可在设计模式)。<br>构建成功后在debug文件中会生成一个ui的.h头文件;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">** Form generated from reading UI file &#x27;hellodialog.ui&#x27;</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** Created by: Qt User Interface Compiler version 5.12.8</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** WARNING! All changes made in this file will be lost when recompiling UI file!</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UI_HELLODIALOG_H   <span class="comment">/*防止对头文件的多重包含*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UI_HELLODIALOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtCore/QVariant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE      <span class="comment">/*Qt的命名空间的开始宏*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ui_HelloDialog</span>   <span class="comment">/*定义Ui_HelloDialog类，类名 = Ui_ + 对话框类对象名*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    QLabel *HelloLabel;   <span class="comment">/*定义QLabel类对象指针*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setupUi</span><span class="params">(QDialog *HelloDialog)</span>   <span class="comment">/*生成界面*/</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (HelloDialog-&gt;<span class="built_in">objectName</span>().<span class="built_in">isEmpty</span>())   <span class="comment">/*设置对话框对象名称*/</span></span><br><span class="line">            HelloDialog-&gt;<span class="built_in">setObjectName</span>(QString::<span class="built_in">fromUtf8</span>(<span class="string">&quot;HelloDialog&quot;</span>));</span><br><span class="line">        HelloDialog-&gt;<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">300</span>);   <span class="comment">/*设置窗口大小*/</span></span><br><span class="line">        HelloLabel = <span class="keyword">new</span> <span class="built_in">QLabel</span>(HelloDialog);   <span class="comment">/*设置标签名称、大小、位置*/</span></span><br><span class="line">        HelloLabel-&gt;<span class="built_in">setObjectName</span>(QString::<span class="built_in">fromUtf8</span>(<span class="string">&quot;HelloLabel&quot;</span>));</span><br><span class="line">        HelloLabel-&gt;<span class="built_in">setGeometry</span>(<span class="built_in">QRect</span>(<span class="number">150</span>, <span class="number">120</span>, <span class="number">100</span>, <span class="number">25</span>));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">retranslateUi</span>(HelloDialog);   </span><br><span class="line"></span><br><span class="line">        QMetaObject::<span class="built_in">connectSlotsByName</span>(HelloDialog);   <span class="comment">/*使窗口中的部件实现按对象名进行信号和槽的关联*/</span></span><br><span class="line">    &#125; <span class="comment">// setupUi</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">retranslateUi</span><span class="params">(QDialog *HelloDialog)</span>   <span class="comment">/*对窗口中的字符串进行编码转换*/</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HelloDialog-&gt;<span class="built_in">setWindowTitle</span>(QApplication::<span class="built_in">translate</span>(<span class="string">&quot;HelloDialog&quot;</span>, <span class="string">&quot;Dialog&quot;</span>, <span class="literal">nullptr</span>));</span><br><span class="line">        HelloLabel-&gt;<span class="built_in">setText</span>(QApplication::<span class="built_in">translate</span>(<span class="string">&quot;HelloDialog&quot;</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="literal">nullptr</span>));</span><br><span class="line">    &#125; <span class="comment">// retranslateUi</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;   <span class="comment">/*定义命名空间*/</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">HelloDialog</span>: <span class="keyword">public</span> Ui_HelloDialog &#123;&#125;;<span class="comment">/*定义继承于Ui_HelloDialog类的HelloDialog类</span></span><br><span class="line"><span class="comment">&#125; // namespace Ui</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">QT_END_NAMESPACE      /*Qt的命名空间的结束宏*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// UI_HELLODIALOG_H</span></span></span><br></pre></td></tr></table></figure><p>4)在main.cpp中引用.ui文件:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ui_hellodialog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc,argv)</span></span>;</span><br><span class="line">    QDialog w;</span><br><span class="line">    Ui::HelloDialog ui;   <span class="comment">/*使用命名空间中的HelloDialog定义了一个ui对象</span></span><br><span class="line"><span class="comment">    ui.setupUi(&amp;w);      /*使用对话框作为参数，可以将设计好的界面应用到对象w所表示的对话框上*/</span></span><br><span class="line">    <span class="function">QLabel <span class="title">label</span><span class="params">(&amp;w)</span></span>;</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样这种方式也可以使用命令行编译ui文件和程序;</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Qt是一个完整的开发框架，其工具旨在简化桌面，嵌入式和移动平台的应用程序和用户界面的创建。&lt;/p&gt;</summary>
    
    
    
    <category term="研发" scheme="https://115jiege.github.io/categories/%E7%A0%94%E5%8F%91/"/>
    
    
    <category term="qt开发" scheme="https://115jiege.github.io/tags/qt%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Makefile编写</title>
    <link href="https://115jiege.github.io/2023/02/28/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/Makefile%E7%BC%96%E5%86%99/"/>
    <id>https://115jiege.github.io/2023/02/28/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/Makefile%E7%BC%96%E5%86%99/</id>
    <published>2023-02-28T01:00:45.000Z</published>
    <updated>2023-03-13T03:19:49.923Z</updated>
    
    <content type="html"><![CDATA[<p>Makefile是在Linux环境下 C/C++ 程序开发必须要掌握的一个工程管理文件。</p><span id="more"></span><p>在Linux下编写程序，因为早期没有成熟的IDE，一般都是使用不同的命令进行编译：将源文件分别使用编译器、汇编器、链接器编译成可执行文件，然后手动运行。<br>如图(…/…/pic/pic1.png)</p><h2 id="gcc编译参数"><a class="header-anchor" href="#gcc编译参数">¶</a>gcc编译参数</h2><p>1.使用GCC编译程序</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o <span class="selector-tag">a</span><span class="selector-class">.out</span> helloworld.c</span><br></pre></td></tr></table></figure><p>2.使用-E参数，只做预处理，不编译</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E helloworld.<span class="keyword">c</span></span><br></pre></td></tr></table></figure><p>3.制作汇编处理</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S -o helloworld.S helloworld.<span class="keyword">c</span></span><br></pre></td></tr></table></figure><h2 id="Makefile-编译"><a class="header-anchor" href="#Makefile-编译">¶</a>Makefile 编译</h2><p>例：编写</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-class">.out</span>: helloworld<span class="selector-class">.o</span></span><br><span class="line">    gcc -o <span class="selector-tag">a</span><span class="selector-class">.out</span> helloworld<span class="selector-class">.o</span></span><br><span class="line">helloworld<span class="selector-class">.o</span>: helloworld<span class="selector-class">.c</span></span><br><span class="line">    gcc -c -o helloworld<span class="selector-class">.o</span> helloworld<span class="selector-class">.c</span></span><br><span class="line">clean:</span><br><span class="line">    rm -f <span class="selector-tag">a</span><span class="selector-class">.out</span> helloworld.o</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Makefile是在Linux环境下 C/C++ 程序开发必须要掌握的一个工程管理文件。&lt;/p&gt;</summary>
    
    
    
    <category term="杂七杂八" scheme="https://115jiege.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>android-jni入门</title>
    <link href="https://115jiege.github.io/2023/02/24/%E7%A0%94%E5%8F%91/android%E5%BC%80%E5%8F%91/android-jni%E5%85%A5%E9%97%A8/"/>
    <id>https://115jiege.github.io/2023/02/24/%E7%A0%94%E5%8F%91/android%E5%BC%80%E5%8F%91/android-jni%E5%85%A5%E9%97%A8/</id>
    <published>2023-02-24T06:54:55.000Z</published>
    <updated>2023-03-13T03:17:03.794Z</updated>
    
    <content type="html"><![CDATA[<p>未完待续~</p><span id="more"></span><p>1.JNI<br>全名 Java Native Interface，是Java本地接口，JNI是Java调用Native 语言的一种特性，通过JNI可以使得Java与C/C<ins>机型交互。<br>简单点说就是JNI是Java中调用C/C</ins>的统称。<br>2.NDK<br>全名Native Develop Kit，官方说法：Android NDK 是一套允许您使用 C 和 C++ 等语言，以原生代码实现部分应用的工具集。<br>在开发某些类型的应用时，这有助于您重复使用以这些语言编写的代码库。</p><h3 id="Android-Studio-JNI开发入门"><a class="header-anchor" href="#Android-Studio-JNI开发入门">¶</a>Android Studio JNI开发入门</h3><p>1.File-&gt;New-&gt;New Project 新建native C++项目；<br>2.配置CMake、NDK环境：</p><p>Tools-&gt;SDK Manager-&gt;SDK Tools下载:NDK(Side by side)、CMake、Android Emulator、Android SDK Platform-Tools等；<br>打开File-&gt;Project Structure，配置SDK、NDK目录；<br>（notices:在SDK Manager中下载完NDK后，打开File-&gt;Project Structure-&gt;Android NDK location无法配置，无法选中修改；<br>可能是NDK是存在本地的，Android studio本身没有下载导致的。<br>尝试在local.properties 中手动添加本地ndk.dir路径。<br>成功解决）</p><p>3.实现在Android中调用c<ins>代码：<br>Android 中调用C/C</ins>库的步骤：<br>1）通过System.loadLibrary引入C代码库名；<br>2）在cpp目录下的natice-lib.cpp中编写C/C<ins>代码；<br>3）调用C/C</ins>文件中对应的实现方法；</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;未完待续~&lt;/p&gt;</summary>
    
    
    
    <category term="研发" scheme="https://115jiege.github.io/categories/%E7%A0%94%E5%8F%91/"/>
    
    
    <category term="android开发" scheme="https://115jiege.github.io/tags/android%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>linux使用中的积累</title>
    <link href="https://115jiege.github.io/2023/02/24/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/linux/linux%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E7%A7%AF%E7%B4%AF/"/>
    <id>https://115jiege.github.io/2023/02/24/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/linux/linux%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E7%A7%AF%E7%B4%AF/</id>
    <published>2023-02-24T06:34:10.000Z</published>
    <updated>2023-03-13T03:20:04.834Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下使用linux虚拟机时遇到的一些问题</p><span id="more"></span><p>1.linux文件的换行：<br>windows下编写的文件使用Windows(CRLF)编码，换行为/r/n;在linux下打开该文件（vi -b eg.txt)会显示行尾^M（linux下换行为/n)。解决方法:编码改为linux(LF)保存。<br>2.VS Code 扩展问题:<br>VS Code 远程连接linux虚拟机(ubuntu)，打开后显示“此扩展在此工作区中被禁用，因为其被定义为在远程扩展主机中运行。请在 ‘SSH: 192.168.12.128’ 中安装扩展以进行启用”。<br>解决方法：选择兼容的版本，点击在SSH:XXX中安装扩展。(ubuntu已联网）。</p><p>3.linux sokcet<br>select函数：<br>int select(int maxfdp, fd_set* readfds, fd_set* writefds, fd_set* errorfds, struct timeval* timeout);</p><p>4.临时修改DNS<br>vi /etc/resolv.conf<br>增加nameserver 8.8.8.8<br>保存<br>重启服务service network-manager restart</p><p>5.ubuntu20.04桌面假死及解决<br>ubuntu20.04虚拟机桌面假死，鼠标可以移动但点击无反应。<br>解决：<br>alt + crtl +F1(F1~F6)进入tty终端<br>输入账号和密码进行登录<br>ps -t tty7 #查找桌面进程<br>sudo pkill Xorg  #注销桌面重新登陆</p><p>ubuntu键盘无反应，无法进入ty终端，xshell远程连接，ps -t tty7显示无桌面进程。可能是由于ubuntu桌面被意外卸载，重装程序，重新登陆。<br>解决方法：<br>sudo apt-get install ubuntu-desktop<br>sudo pkill Xorg  #注销桌面重新登陆</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下使用linux虚拟机时遇到的一些问题&lt;/p&gt;</summary>
    
    
    
    <category term="杂七杂八" scheme="https://115jiege.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="linux" scheme="https://115jiege.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>android studio项目架构</title>
    <link href="https://115jiege.github.io/2023/02/24/%E7%A0%94%E5%8F%91/android%E5%BC%80%E5%8F%91/android-studio%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/"/>
    <id>https://115jiege.github.io/2023/02/24/%E7%A0%94%E5%8F%91/android%E5%BC%80%E5%8F%91/android-studio%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/</id>
    <published>2023-02-24T06:25:45.000Z</published>
    <updated>2023-03-13T03:17:15.538Z</updated>
    
    <content type="html"><![CDATA[<p>首先介绍一下Android studio生成的项目文件架构。</p><span id="more"></span><h2 id="简单项目架构"><a class="header-anchor" href="#简单项目架构">¶</a>简单项目架构</h2><p>Android 项目文件:<br>Gradle Script:显示项目的所有与构建相关的配置文件<br>manifests:包含 AndroidManifest.xml 文件（应用清单概览）<br>java:包含java源代码<br>res:包含所有非代码资源（eg:XML布局，img等）<br>项目架构：<br>Test1<br>│<br>└─app<br>│  ├─build#包含构建输出。<br>│  │<br>│  ├─libs#包含专用库。<br>│  │<br>│  └─src#包含相应模块在以下子目录中的所有代码和资源文件。<br>│      ├─androidTest#包含在 Android 设备上运行的插桩测试的代码。<br>│      │<br>│      ├─main#包含“主”源代码集文件：所有 build 变体共享的 Android 代码和资源（其他 build 变体的文件位于同级目录中，例如调试 build 类型的文件位于 src/debug/ 中）<br>│      │  │  AndroidManifest.xml#描述应用及其各个组件的性质。<br>│      │  │<br>│      │  ├─java#包含 Java 源代码。<br>│      │  │<br>│      │  ├─jni#包含使用 Java 原生接口 (JNI) 的原生代码。(主要封装位置）<br>│      │  │<br>│      │  ├─gen#包含 Android Studio 生成的 Java 文件。<br>│      │  │<br>│      │  ├─res#包含应用资源，例如可绘制对象文件、布局文件和界面字符串。<br>│      │  │<br>│      │  └─assets#包含应按原样编译为 .apk 文件的文件。<br>│      │<br>│      └─test#包含在主机 JVM 上运行的本地测试代码。<br>│<br>└─build.gradle（模块）#这定义了特定于模块的构建配置。<br>└─build.gradle（项目）  #这定义了适用于所有模块的构建配置。</p><h2 id="包含c、c-的Android项目"><a class="header-anchor" href="#包含c、c-的Android项目">¶</a>包含c、c++的Android项目</h2><p>向项目添加C、C<ins>代码:<br>将C、C</ins>代码放在项目模块的CPP目录中，java代码可以通过java原生接口(jni)调用原生库中的函数。<br>步骤:<br>1.下载 NDK 和构建工具;<br><a href="https://developer.android.google.cn/studio/projects/add-native-code?hl=zh-cn#download-ndk">https://developer.android.google.cn/studio/projects/add-native-code?hl=zh-cn#download-ndk</a><br>2.创建支持 C/C++ 的新项目<br><a href="https://developer.android.google.cn/studio/projects/add-native-code?hl=zh-cn#new-project">https://developer.android.google.cn/studio/projects/add-native-code?hl=zh-cn#new-project</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先介绍一下Android studio生成的项目文件架构。&lt;/p&gt;</summary>
    
    
    
    <category term="研发" scheme="https://115jiege.github.io/categories/%E7%A0%94%E5%8F%91/"/>
    
    
    <category term="android开发" scheme="https://115jiege.github.io/tags/android%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>使用VC+VS开发时编码的坑</title>
    <link href="https://115jiege.github.io/2023/02/23/%E7%A0%94%E5%8F%91/%E8%B8%A9%E5%9D%91/%E4%BD%BF%E7%94%A8VC-VS%E5%BC%80%E5%8F%91%E6%97%B6%E7%BC%96%E7%A0%81%E7%9A%84%E5%9D%91/"/>
    <id>https://115jiege.github.io/2023/02/23/%E7%A0%94%E5%8F%91/%E8%B8%A9%E5%9D%91/%E4%BD%BF%E7%94%A8VC-VS%E5%BC%80%E5%8F%91%E6%97%B6%E7%BC%96%E7%A0%81%E7%9A%84%E5%9D%91/</id>
    <published>2023-02-23T08:09:23.000Z</published>
    <updated>2023-02-24T06:21:12.257Z</updated>
    
    <content type="html"><![CDATA[<p>记录以下研发过程中编码带来的坑！</p>  <span id="more"></span><h2 id="VS-和-VC"><a class="header-anchor" href="#VS-和-VC">¶</a>VS 和 VC</h2><p>使用Visual Studio 2019开发，工程文件默认以ANSI(GB2312)编码方式保存。<br>使用Visual Studio Code打开源文件，默认以UTF-8编码方式打开，所以VS编写的文件如果以VC打开会有中文乱码；<br>此时如果在VC下保存，源文件编码格式会编程UTF-8。</p><h2 id="Winduws-和-Unix"><a class="header-anchor" href="#Winduws-和-Unix">¶</a>Winduws 和 Unix</h2><p>在Winows下文件默认以CRLF换行保存，而Unix例如Linux默认以LF换行解析文件。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> -A 文件  <span class="comment">#查看文件换行,在Linux平台编译CRLF格式的文件，会自动在行尾加^M</span></span><br></pre></td></tr></table></figure></p><h2 id="git的坑"><a class="header-anchor" href="#git的坑">¶</a>git的坑</h2><p>git commit上传项目会自动把文件以LF UTF-8的形式保存，如果在Windows上拉取项目就是CRLF换行，在Unix平台拉取就是LF换行。</p><pre><code><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf <span class="literal">false</span> <span class="comment">#可以使用命令像转换开关关闭</span></span><br></pre></td></tr></table></figure></code></pre><p>关闭换行转换后，上传项目，git会保存上传文件的格式，拉取时也一样。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录以下研发过程中编码带来的坑！&lt;/p&gt;</summary>
    
    
    
    <category term="研发" scheme="https://115jiege.github.io/categories/%E7%A0%94%E5%8F%91/"/>
    
    
    <category term="踩坑" scheme="https://115jiege.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>国密SM2签名</title>
    <link href="https://115jiege.github.io/2023/02/22/%E7%A0%94%E5%8F%91/c++/%E5%9B%BD%E5%AF%86SM2%E7%AD%BE%E5%90%8D/"/>
    <id>https://115jiege.github.io/2023/02/22/%E7%A0%94%E5%8F%91/c++/%E5%9B%BD%E5%AF%86SM2%E7%AD%BE%E5%90%8D/</id>
    <published>2023-02-22T08:50:10.000Z</published>
    <updated>2023-03-13T03:18:59.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="About-GMSSL"><a class="header-anchor" href="#About-GMSSL">¶</a>About GMSSL</h2><p>GmSSL是由由北京大学自主开发的国产商用密码开源库，实现了对国密算法、标准和安全通信协议的全面功能覆盖，支持包括移动端在内的主流操作系统和处理器，支持密码钥匙、密码卡等典型国产密码硬件，提供功能丰富的命令行工具及多种编译语言编程接口。</p><span id="more"></span><h2 id="SM2签名"><a class="header-anchor" href="#SM2签名">¶</a>SM2签名</h2><p>SM2签名算法实际上就是使用椭圆曲线密码算法进行数字签名和验证，以通信为例，服务器使用私钥签名，客户端使用公钥验签。</p><h3 id="椭圆曲线"><a class="header-anchor" href="#椭圆曲线">¶</a>椭圆曲线</h3><p>椭圆曲线公钥密码所基于的曲线性质如下：<br>——有限域上椭圆曲线在点加运算下构成有限交换群 ,且其阶与基域规模相近；<br>——类似于有限域乘法群中的乘幂运算 ,椭圆曲线多倍点运算构成一个单向函数；</p><p>根据椭圆曲线的性质，找到曲线基点G在素数域(GFp)或二元扩域（GF2m）的k倍点P(x,y)，即：<br><code>(x,y) = kG </code><br>则点P(x,y)为公钥，k为私钥。</p><h3 id="SM2签名算法"><a class="header-anchor" href="#SM2签名算法">¶</a>SM2签名算法</h3><p><a href="https://github.com/guanzhi/GmSSL.git">GMSSL官方项目地址</a><br>在使用GMSSL-v1 SM2签名算法的过程中，发现了一下问题：<br>1.函数SM2_do_sign()中约每100次生成含有padding的签名<br>2.程序源码存在内存泄露问题</p><p>因此，本项目对GMSSL-v1做出以下改进：<br>1.按照标准文档修改函数SM2_do_sign_ex()的逻辑，返回ECDSA_SIG结构签名</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct ECDSA_SIG_st &#123;</span><br><span class="line">    BIGNUM *r<span class="comment">;</span></span><br><span class="line">    BIGNUM *s<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>2.网络中一般以字节流的形式传输，因此新增结构体SM2_SIGNATURE_STRUCT</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">sm2_sig_structure</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> r_coordinate[<span class="number">32</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> s_coordinate[<span class="number">32</span>];</span><br><span class="line">&#125; SM2_SIGNATURE_STRUCT;</span><br></pre></td></tr></table></figure><p>3.解决随机生成含有padding的签名，修改函数SM2_do_sign()，内置BN_bn2binpad()<br>4.规范代码格式，增加可读性</p><p>官网中GMSSL-v2相比v1并没有对SM2签名、密钥交换、加解密做出改进；GMSSL-3.0.0稳定版本增加Windows+VS编译，去掉了perl的使用，但编译失败；GMSSL-3.1.0-dev版编译成功，但GMSSL-3.0以上的版本都独立于openssl，并且SM2签名、密钥交换相关仍在开发。<br>因此，本项目参考标准文档对稳定并使用广泛的GMSSL-V1进行开发改进，<a href="https://github.com/115Jiege/Gmssl.git">项目地址</a> 。</p><p>[参考文档](…/article/GMT 0003.2-2012 SM2椭圆曲线公钥密码算法第2部分：数字签名算法.pdf)</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;About-GMSSL&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#About-GMSSL&quot;&gt;¶&lt;/a&gt;About GMSSL&lt;/h2&gt;
&lt;p&gt;GmSSL是由由北京大学自主开发的国产商用密码开源库，实现了对国密算法、标准和安全通信协议的全面功能覆盖，支持包括移动端在内的主流操作系统和处理器，支持密码钥匙、密码卡等典型国产密码硬件，提供功能丰富的命令行工具及多种编译语言编程接口。&lt;/p&gt;</summary>
    
    
    
    <category term="研发" scheme="https://115jiege.github.io/categories/%E7%A0%94%E5%8F%91/"/>
    
    
    <category term="c++" scheme="https://115jiege.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客文章写作</title>
    <link href="https://115jiege.github.io/2022/09/23/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%86%99%E4%BD%9C/"/>
    <id>https://115jiege.github.io/2022/09/23/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%86%99%E4%BD%9C/</id>
    <published>2022-09-23T06:46:40.000Z</published>
    <updated>2023-03-13T03:19:55.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用命令"><a class="header-anchor" href="#常用命令">¶</a>常用命令</h2><p><strong>hexo 安装</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install hexo -g <span class="comment">#安装</span></span><br><span class="line"><span class="built_in">npm</span> update hexo -g <span class="comment">#升级</span></span><br><span class="line">hexo init <span class="comment">#初始化</span></span><br></pre></td></tr></table></figure><span id="more"></span><p><strong>服务器</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">server</span> <span class="meta">#Hexo 会监视文件变动并自动更新，您无须重启服务器。</span></span><br><span class="line">hexo <span class="keyword">server</span> -s <span class="meta">#静态模式</span></span><br><span class="line">hexo <span class="keyword">server</span> -p <span class="number">5000</span> <span class="meta">#更改端口</span></span><br><span class="line">hexo <span class="keyword">server</span> -i <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> <span class="meta">#自定义 IP</span></span><br><span class="line"></span><br><span class="line">hexo clean <span class="meta"># 清除缓存文件（db.json和已生成的静态文件，尤其是更换主题后） </span></span><br><span class="line"></span><br><span class="line">hexo g <span class="meta"># 生成静态文件</span></span><br><span class="line">hexo s <span class="meta"># 启动hexo  （上述两个指令需要在博客根目录下执行）</span></span><br><span class="line">hexo d  <span class="meta"># 部署到GitHub上（前提是已经添加SSH Key，设置好账户信息）</span></span><br></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;文章名&quot;</span>  <span class="meta">#新建文章</span></span><br><span class="line">hexo <span class="keyword">new</span>  page <span class="string">&quot;页面名&quot;</span> <span class="meta">#新建页面</span></span><br></pre></td></tr></table></figure><p><strong>ssl报错</strong><br>解决方案<br>在项目文件夹的命令行窗口执行下面代码，然后再git commit 或git clone<br>取消git本身的https代理，使用自己本机的代理，如果没有的话，其实默认还是用git的</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> Documents/blog</span><br><span class="line"><span class="string">//</span>取消http代理</span><br><span class="line">git config <span class="params">--global</span> <span class="params">--unset</span> http.proxy</span><br><span class="line"><span class="string">//</span>取消https代理 </span><br><span class="line">git config <span class="params">--global</span> <span class="params">--unset</span> https.proxy</span><br></pre></td></tr></table></figure><h2 id="写作介绍"><a class="header-anchor" href="#写作介绍">¶</a>写作介绍</h2><h2 id="1-字体介绍"><a class="header-anchor" href="#1-字体介绍">¶</a>1.字体介绍</h2><p><em>这是斜体</em> 或 <em>这也是斜体</em><br><strong>这是粗体</strong><br><em><strong>这是加粗斜体</strong></em><br><s>这是删除线</s></p><h2 id="2-分级标题"><a class="header-anchor" href="#2-分级标题">¶</a>2.分级标题</h2><h1>一级标题</h1><h2 id="二级标题"><a class="header-anchor" href="#二级标题">¶</a>二级标题</h2><h3 id="三级标题"><a class="header-anchor" href="#三级标题">¶</a>三级标题</h3><h4 id="四级标题"><a class="header-anchor" href="#四级标题">¶</a>四级标题</h4><h5 id="五级标题"><a class="header-anchor" href="#五级标题">¶</a>五级标题</h5><h6 id="六级标题"><a class="header-anchor" href="#六级标题">¶</a>六级标题</h6><h2 id="3-超链接"><a class="header-anchor" href="#3-超链接">¶</a>3.超链接</h2><p>写法：</p><p>行内形式：<a href="https://github.com/115Jiege/115Jiege.github.io.git">我的博客</a><br>参考形式：[我的博客][1]，有一个很好的平台-[简书][2]<br>[1]: <a href="https://github.com/115Jiege/115Jiege.github.io.git">https://github.com/115Jiege/115Jiege.github.io.git</a><br>[2]:<a href="http://www.baidu.com/">http://www.baidu.com/</a><br>自动链接：我的博客地址<a href="https://github.com/115Jiege/115Jiege.github.io">https://github.com/115Jiege/115Jiege.github.io</a></p><h2 id="4-列表"><a class="header-anchor" href="#4-列表">¶</a>4.列表</h2><p>无序列表：<br>写法：</p><ul><li>无序列表项1</li></ul><ul><li>无序列表项2</li></ul><ul><li>无序列表项3</li></ul><p>有序列表：<br>写法：<br>1.有序列表项1<br>2.有序列表项2<br>3.有序列表项3</p><h2 id="5-插入图片"><a class="header-anchor" href="#5-插入图片">¶</a>5.插入图片</h2><p>在 Hexo 中插入图片，首先需要将图片放在 source/img/ 文件夹下，然后如下方式进行插入：</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1535014836&amp;di=fafdb400041dc371b853cfb3fcc7b851&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fscdn.file1.gk99.com%2Fphoto%2F2015-09%2F2015-09-11%2F14419580206489.jpg" alt></p><h2 id="6-表格"><a class="header-anchor" href="#6-表格">¶</a>6.表格</h2><table><thead><tr><th>表头1</th><th style="text-align:left">表头2</th><th style="text-align:center">表头3</th><th style="text-align:right">表头4</th></tr></thead><tbody><tr><td>默认左对齐</td><td style="text-align:left">左对齐</td><td style="text-align:center">居中对其</td><td style="text-align:right">右对齐</td></tr><tr><td>默认左对齐</td><td style="text-align:left">左对齐</td><td style="text-align:center">居中对其</td><td style="text-align:right">右对齐</td></tr><tr><td>默认左对齐</td><td style="text-align:left">左对齐</td><td style="text-align:center">居中对其</td><td style="text-align:right">右对齐</td></tr></tbody></table><h2 id="7-代码"><a class="header-anchor" href="#7-代码">¶</a>7.代码</h2><p>'<code>无序  hexo new &quot;create a new blog&quot; '</code></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;create blog2&quot;</span><br><span class="line">hexo new &quot;create blog3&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;常用命令&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#常用命令&quot;&gt;¶&lt;/a&gt;常用命令&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;hexo 安装&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight coffeescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;npm&lt;/span&gt; install hexo -g &lt;span class=&quot;comment&quot;&gt;#安装&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;npm&lt;/span&gt; update hexo -g &lt;span class=&quot;comment&quot;&gt;#升级&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo init &lt;span class=&quot;comment&quot;&gt;#初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="杂七杂八" scheme="https://115jiege.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>测试常用命令--1</title>
    <link href="https://115jiege.github.io/2022/07/26/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/%E6%B5%8B%E8%AF%95%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://115jiege.github.io/2022/07/26/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/%E6%B5%8B%E8%AF%95%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-07-26T00:23:28.000Z</published>
    <updated>2023-03-13T03:19:43.013Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下测试时常用的命令</p><span id="more"></span><h3 id="1-docker常用命令"><a class="header-anchor" href="#1-docker常用命令">¶</a>1.docker常用命令</h3><h4 id="测试中用到的docker命令："><a class="header-anchor" href="#测试中用到的docker命令：">¶</a>测试中用到的docker命令：####</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">service docker <span class="built_in">start</span>  <span class="comment">#开启docker</span></span><br><span class="line">docker <span class="built_in">ps</span>  <span class="comment">#查看docker正在运行的容器</span></span><br><span class="line">Docker <span class="built_in">start</span> 容器ID <span class="comment">#启动容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#docker访问外部网络，上位机连接前要检查</span></span><br><span class="line">sysctl net.ipv4.ip_forward </span><br><span class="line"><span class="comment">#如果为 0，说明没有开启转发，则需要手动打开</span></span><br><span class="line">sysctl <span class="literal">-p</span></span><br></pre></td></tr></table></figure><h4 id="docker常用命令大全："><a class="header-anchor" href="#docker常用命令大全：">¶</a>docker常用命令大全：####</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#info</span></span><br><span class="line">docker info       <span class="comment">#显示docker的系统信息，包括镜像和容器的数量</span></span><br><span class="line">docker version    <span class="comment">#显示docker的版本信息。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#镜像命令</span></span><br><span class="line">docker images <span class="comment">#查看所有本地主机上的镜像 可以使用docker image ls代替</span></span><br><span class="line">docker search <span class="comment">#搜索镜像</span></span><br><span class="line">docker pull <span class="comment">#下载镜像 docker image pull</span></span><br><span class="line">docker rmi <span class="comment">#删除镜像 docker image rm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#容器命令</span></span><br><span class="line">docker run 镜像<span class="built_in">id</span> <span class="comment">#新建容器并启动</span></span><br><span class="line">docker ps 列出所有运行的容器 docker container list</span><br><span class="line">docker <span class="built_in">rm</span> 容器<span class="built_in">id</span> <span class="comment">#删除指定容器</span></span><br><span class="line"><span class="comment">#删除所有容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -aq)   <span class="comment">#删除所有的容器</span></span><br><span class="line">docker ps -a -q|xargs docker <span class="built_in">rm</span>  <span class="comment">#删除所有的容器</span></span><br><span class="line"><span class="comment">#启动和停止容器</span></span><br><span class="line">docker start 容器<span class="built_in">id</span><span class="comment">#启动容器</span></span><br><span class="line">docker restart 容器<span class="built_in">id</span><span class="comment">#重启容器</span></span><br><span class="line">docker stop 容器<span class="built_in">id</span><span class="comment">#停止当前正在运行的容器</span></span><br><span class="line">docker <span class="built_in">kill</span> 容器<span class="built_in">id</span><span class="comment">#强制停止当前容器</span></span><br><span class="line"><span class="comment">#退出容器</span></span><br><span class="line"><span class="built_in">exit</span> <span class="comment">#容器直接退出</span></span><br><span class="line">ctrl +P +Q  <span class="comment">#容器不停止退出 ---注意：这个很有用的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#其他常用命令</span></span><br><span class="line">docker <span class="built_in">exec</span><span class="comment">#在运行的容器中执行命令</span></span><br><span class="line">docker <span class="built_in">export</span><span class="comment">#将文件系统作为一个tar归档文件导出到STDOUT</span></span><br><span class="line">docker import<span class="comment">#从归档文件中创建镜像</span></span><br><span class="line">docker <span class="built_in">kill</span><span class="comment">#杀掉一个运行中的容器</span></span><br><span class="line">docker save<span class="comment">#将指定镜像保存成 tar 归档文件</span></span><br><span class="line">docker load<span class="comment">#导入使用 docker save 命令导出的镜像</span></span><br><span class="line"></span><br><span class="line">docker run -d 镜像名  <span class="comment">#后台启动命令</span></span><br><span class="line">docker logs <span class="comment">#查看日志</span></span><br><span class="line">docker top 容器<span class="built_in">id</span> <span class="comment">#查看容器中进程信息ps</span></span><br><span class="line">docker inspect 容器<span class="built_in">id</span>  <span class="comment">#查看镜像的元数据</span></span><br><span class="line">docker attach <span class="comment"># 进入容器正在执行的终端</span></span><br><span class="line">docker <span class="built_in">cp</span> 容器<span class="built_in">id</span>:容器内路径  主机目的路径<span class="comment">#从容器内拷贝到主机上</span></span><br></pre></td></tr></table></figure><h3 id="2-关于进程、端口命令"><a class="header-anchor" href="#2-关于进程、端口命令">¶</a>2.关于进程、端口命令</h3><h4 id="僵尸进程"><a class="header-anchor" href="#僵尸进程">¶</a>僵尸进程</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">top 查找僵尸进程</span><br><span class="line"><span class="keyword">ps</span> -A -ostat,ppid,pid,cmd |<span class="keyword">grep</span> -<span class="keyword">e</span> <span class="string">&#x27;^[Zz]&#x27;</span> 定位僵尸进程</span><br><span class="line">Kill -HUP 父id（可能会杀掉app.<span class="keyword">py</span>）</span><br><span class="line">netstat</span><br></pre></td></tr></table></figure><h4 id="netstat常用命令"><a class="header-anchor" href="#netstat常用命令">¶</a>netstat常用命令</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">netstat -a <span class="comment">#列出所有端口 </span></span><br><span class="line">netstat -at <span class="comment">#列出所有 tcp 端口 </span></span><br><span class="line">netstat -au <span class="comment">#列出所有 udp 端口 </span></span><br><span class="line"></span><br><span class="line">netstat -anp | <span class="keyword">grep</span> 进程号 <span class="comment">#查询进程号所占用的端口</span></span><br><span class="line"></span><br><span class="line">netstat -tunlp | <span class="keyword">grep</span> 端口号 <span class="comment">#查看端口对应的进程，用于排查端口号是否被占用</span></span><br><span class="line"></span><br><span class="line">netstat -anp | <span class="keyword">grep</span> 端口号 <span class="comment">#查看端口的使用情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#列出所有处于监听状态的 Sockets</span></span><br><span class="line">netstat -l <span class="comment">#只显示监听端口</span></span><br><span class="line">netstat -<span class="keyword">lt</span> <span class="comment">#只列出所有监听 tcp 端口 </span></span><br><span class="line">netstat -lu <span class="comment">#只列出所有监听 udp 端口 </span></span><br><span class="line">netstat -lx <span class="comment">#只列出所有监听 UNIX 端口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">netstat -s <span class="comment">#显示所有端口的统计信息 </span></span><br><span class="line">netstat -st 或 -su <span class="comment">#显示 TCP 或 UDP 端口的统计信息</span></span><br><span class="line"></span><br><span class="line">netstat -pt <span class="comment">#显示pid和进程</span></span><br></pre></td></tr></table></figure><h3 id="3-VNC"><a class="header-anchor" href="#3-VNC">¶</a>3.VNC</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动VNC</span></span><br><span class="line"><span class="attribute">vncserver</span> :<span class="number">1</span></span><br><span class="line"><span class="attribute">vncserver</span> :<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#停止vncserver</span></span><br><span class="line"><span class="attribute">vncserver</span> -kill :<span class="number">1</span></span><br><span class="line"><span class="attribute">vncserver</span> -kill :<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重启服务</span></span><br><span class="line"><span class="attribute">service</span> vncserver restart</span><br></pre></td></tr></table></figure><h3 id="4-抓包"><a class="header-anchor" href="#4-抓包">¶</a>4.抓包</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启中间人</span></span><br><span class="line"><span class="attribute">ettercap</span> -i eth0 -T -q -M ARP:remote  //ip1/ /ip2//</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出可以抓包的网络接口：</span></span><br><span class="line"><span class="attribute">sudo</span> tcpdump -D</span><br><span class="line"></span><br><span class="line"><span class="comment">#tcpdump抓包</span></span><br><span class="line"><span class="comment">#抓取所有的经过eth0网卡的网络包，并存到result.cap 文件中</span></span><br><span class="line"><span class="attribute">tcpdump</span> -i eth0 -w result.cap</span><br><span class="line"></span><br><span class="line"><span class="comment">#抓取源地址是192.168.1.100的包，并将结果保存到 result.cap 文件中</span></span><br><span class="line"><span class="attribute">tcpdump</span> src host <span class="number">192.168.1.100</span> and dest host <span class="number">192.168.1.100</span> -w result.cap</span><br><span class="line"></span><br><span class="line"><span class="comment">#抓取源ip是192.168.1.100且目的端口是22，或源ip是192.168.1.102且目的端口是80的数据包</span></span><br><span class="line"><span class="attribute">tcpdump</span> -i eth0 -vnn ( src host <span class="number">192.168.1.100</span> and dst port <span class="number">22</span> ) or ( src host <span class="number">192.168.1.102</span> and dst port <span class="number">80</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">#把抓取的数据包记录存到/tmp/result文件中，当抓取100个数据包后就退出程序</span></span><br><span class="line"><span class="attribute">tcpdump</span> –i eth0 -vnn -w /tmp/result -c <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果想要获取主机192.168.1.100除了和主机192.168.1.101之外所有主机通信的ip包</span></span><br><span class="line"><span class="attribute">tcpdump</span> ip host <span class="number">192.168.1.100</span> and ! <span class="number">192.168.1.101</span></span><br></pre></td></tr></table></figure><h3 id="5-扩容"><a class="header-anchor" href="#5-扩容">¶</a>5.扩容</h3><p>新建虚拟机时分配的磁盘空间不够大，导致用了一段时间会显示根目录空间不足;<br>以ubuntu 20.04为例，扩充磁盘空间<br>关闭虚拟机，编辑虚拟机设置，扩展硬盘；</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df -h<span class="comment">#查看系统容量相关的数据</span></span><br><span class="line">sudo apt-<span class="keyword">get</span> install gparted</span><br><span class="line">sudo gparted</span><br></pre></td></tr></table></figure><p>调整大小，并应用全部;</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下测试时常用的命令&lt;/p&gt;</summary>
    
    
    
    <category term="杂七杂八" scheme="https://115jiege.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>工控安全事件整理</title>
    <link href="https://115jiege.github.io/2022/07/26/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%B7%A5%E6%8E%A7%E4%BA%8B%E4%BB%B6/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E6%95%B4%E7%90%86/"/>
    <id>https://115jiege.github.io/2022/07/26/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%B7%A5%E6%8E%A7%E4%BA%8B%E4%BB%B6/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E6%95%B4%E7%90%86/</id>
    <published>2022-07-26T00:23:28.000Z</published>
    <updated>2023-03-13T03:21:21.943Z</updated>
    
    <content type="html"><![CDATA[<p>终于来啦，杰哥的第二篇博客</p><span id="more"></span><h1>WORK</h1><p>整理一下目前收集的典型工控安全事件</p><h2 id="1-震网事件"><a class="header-anchor" href="#1-震网事件">¶</a>1.震网事件</h2><h3 id="事件"><a class="header-anchor" href="#事件">¶</a>事件 :</h3><p>2010年9月24日，伊朗核设施爆出Stuxnet病毒（“震网病毒”）攻击，导致其核设施不能正常运行。</p><h3 id="传播介质"><a class="header-anchor" href="#传播介质">¶</a>传播介质 :</h3><p>u盘</p><h3 id="攻击对象"><a class="header-anchor" href="#攻击对象">¶</a>攻击对象 :</h3><p>国家重要基础设施</p><h3 id="漏洞利用-："><a class="header-anchor" href="#漏洞利用-：">¶</a>漏洞利用 ：</h3><p>MS10-046、MS10-061、MS08-067、MS10-073、MS10-092<br>Stuxnet首先是感染外部主机，然后感染u盘，利用Link文件漏洞（MS10-046）传播到内网。<br>在内网中，通过快捷方式文件解析漏洞、RPC远程执行漏洞（MS08-067)、打印机后台程序服务漏洞（MS10-061），实现联网主机的传播（横向渗透），到达装有WIN CC的工作站。<br>当被感染的工作站连接到PLC，Stuxnet部署恶意代码，向PLC发送特定指令。<br>MS10-073、MS10-092用于提权。</p><h3 id="攻击过程-："><a class="header-anchor" href="#攻击过程-：">¶</a>攻击过程 ：</h3><p>Stuxnet蠕虫利用多个零日漏洞和U盘等移动设备在工业互联网中传播，最终目的是到达WIN CC主机。攻击者利用WIN CC存在的硬编码漏洞，窃取数据库信息，保存密码；利用项目文件加载DLL文件出错，窃取正常的生产数据。通过对得到的生产数据进行深入分析，可以构造恶意DLL文件，然后攻击者操纵固件替换恶意DLL，实现恶意操作。震网事件中，攻击者修改了数据库中的PID算法相关参数，导致离心机转速发生变化。为了防止安全操作员得到警报以及系统做出响应，攻击者可能采用重放攻击重放抓取的正常流量；或者修改报警设置，例如将内存代码修改为固定值或篡改汇编级指令代码。</p><h2 id="2-乌克兰电网事件"><a class="header-anchor" href="#2-乌克兰电网事件">¶</a>2.乌克兰电网事件</h2><h3 id="事件-v2"><a class="header-anchor" href="#事件-v2">¶</a>事件 :</h3><p>2015年12月23日，乌克兰电网遭遇突发停电事故。本次停电事故由7个变电站开关动作引起，导致80000个用户停电，停电时间为3到6小时不等。这次停电不是因为电力短缺，而是遭到了黑客攻击。</p><h3 id="传播介质-v2"><a class="header-anchor" href="#传播介质-v2">¶</a>传播介质 :</h3><p>恶意组件BlackEnergy（该恶意软件最早可追溯到2007年，由俄罗斯地下黑客组织开发并广泛使用，包括用来“刺探”全球各国的电力公司。）</p><h3 id="攻击对象-v2"><a class="header-anchor" href="#攻击对象-v2">¶</a>攻击对象 :</h3><p>乌克兰电力公司</p><h3 id="漏洞利用-：-v2"><a class="header-anchor" href="#漏洞利用-：-v2">¶</a>漏洞利用 ：</h3><p>CVE-2014-4114(OLE包管理INF 任意代码执行漏洞)<br><strong>安天工作室分析的攻击流程</strong><br>Office类型的漏洞利用(CVE-2014-4114)–&gt;邮件–&gt;下载恶意组件BlackEnergy侵入员工电力办公系统–&gt;BlackEnergy继续下载恶意组件(KillDisk)–&gt;擦除电脑数据破坏HMI软件监视管理系统<br><img src="/../pic/blackenergy%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B.jpg" alt="img"></p><h2 id="3-FLAME侵袭中东地区事件"><a class="header-anchor" href="#3-FLAME侵袭中东地区事件">¶</a>3.FLAME侵袭中东地区事件</h2><p>Flame ( Worm.Win32.Flame ，又称 Flamer 或 sKyWlper 、Skywiper 等），中文名“火焰病毒”、“超级火焰病毒”。Flame 被包括世界电信联盟等官方以及卡巴斯基等国际权威厂商认定为迄今为止最复杂、最危险、最致命的病毒威胁。</p><h3 id="事件-v3"><a class="header-anchor" href="#事件-v3">¶</a>事件:</h3><p>2012年5月，俄罗斯安全专家发现一种威力强大的电脑病毒火焰(Flame)在中东地区大范围传播。卡巴斯基称，Flame实际上是一个间谍工具包。至少过去两年中，Flame病毒已感染了伊朗、黎巴嫩、叙利亚、苏丹以及其他中东和北非国家的相应目标计算机系统。</p><h3 id="传播"><a class="header-anchor" href="#传播">¶</a>传播 :</h3><p>该病毒可以通过USB存储器以及网络复制和传播，并能接受来自世界各地多个服务器的指令。</p><h3 id="攻击对象-v3"><a class="header-anchor" href="#攻击对象-v3">¶</a>攻击对象 :</h3><p>个人计算机、国家机关甚至教育机构</p><h3 id="病毒危害-："><a class="header-anchor" href="#病毒危害-：">¶</a>病毒危害 ：</h3><p>一旦计算机被感染，Flame 可以激活其麦克风和摄像头，监控用户的键盘敲击，从保存的图像中提取地理定位数据，对正在运行的计算机进行屏幕截图，甚至通过蓝牙无线技术发送和接收命令和数据。</p><h3 id="关联病毒-："><a class="header-anchor" href="#关联病毒-：">¶</a>关联病毒 ：</h3><p>震网（Stuxnet)病毒、毒区(DuQu)病毒；“震网”病毒攻击的是伊朗核设施，“毒区”病毒攻击的是伊朗工业控制系统数据，而“火焰”病毒攻击的则是伊朗石油部门的商业情报。</p><h3 id="漏洞利用-：-v3"><a class="header-anchor" href="#漏洞利用-：-v3">¶</a>漏洞利用 ：</h3><p>MS10-046、MS10-061<br><strong>迈克菲绘制的的代码关系图</strong><br><img src="/../pic/flame%E4%BB%A3%E7%A0%81%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" alt="img"></p><p><strong>FLAME源码中各模块系列的代号及可能的用途</strong><br><img src="/../pic/FLAME%E7%BB%84%E4%BB%B6%E7%94%A8%E9%80%94%E5%9B%BE.png" alt="img"></p><p>工业互联网中不一定需要通过漏洞才能达到恶意目的，有的时候攻击者可以通过系统中的一系列正常操作达到恶意的目的。</p><h2 id="4-IRONGATE"><a class="header-anchor" href="#4-IRONGATE">¶</a>4.IRONGATE</h2><h3 id="事件-v4"><a class="header-anchor" href="#事件-v4">¶</a>事件 :</h3><p>恶意软件IRONGATE中使用了某些Stuxnet功能，只针对西门子公司生产的ICS/SCADA设备。</p><h3 id="攻击对象-v4"><a class="header-anchor" href="#攻击对象-v4">¶</a>攻击对象 :</h3><p>西门子ICS/SCADA系统</p><h3 id="攻击过程-：-v2"><a class="header-anchor" href="#攻击过程-：-v2">¶</a>攻击过程 ：</h3><p>恶意软件IRONGATE首先检测环境，如果没有发现虚拟化的环境则散播病毒程序，然后对目标机器实施中间人攻击以达到恶意操作。IRONGATE使用恶意DLL替换正常DLL，恶意DLL充当PLC与监控系统（SCADA）之间的中间人。恶意DLL记录并替换PLC到用户界面(HMI)的流量，再将构造的恶意数据发回PLC，导致操作过程不受管理员控制。</p><h2 id="5-PLC-Blaster"><a class="header-anchor" href="#5-PLC-Blaster">¶</a>5.PLC-Blaster</h2><h3 id="事件-v5"><a class="header-anchor" href="#事件-v5">¶</a>事件 :</h3><p>PLC-Blaster蠕虫实现了对S7 1200 PLC控制器程序的篡改攻击。</p><h3 id="传播介质-v3"><a class="header-anchor" href="#传播介质-v3">¶</a>传播介质 :</h3><p>TIA门户、移动设备</p><h3 id="攻击对象-v5"><a class="header-anchor" href="#攻击对象-v5">¶</a>攻击对象 :</h3><p>S7 1200 PLC</p><h3 id="攻击过程-：-v3"><a class="header-anchor" href="#攻击过程-：-v3">¶</a>攻击过程 ：</h3><p>PLC-Blaster可能通过U盘等移动设备或者在已感染的主机上扫描可能目标后，蠕虫仿冒TIA门户，并在感染阶段执行西门子专有协议，感染目标主机。感染时，PLC-Blaster将自身代码复制到目标PLC，篡改PLC控制逻辑。目标主机被感染后，PLC-Blaster会再次开始扫描，进行新一轮感染。</p><p>攻击者可以在不修改PLC逻辑指令或者固件的情况下，直接操纵物理过程。</p><h2 id="6-PLC-ROOTKIT"><a class="header-anchor" href="#6-PLC-ROOTKIT">¶</a>6.PLC ROOTKIT</h2><h3 id="事件-v6"><a class="header-anchor" href="#事件-v6">¶</a>事件:</h3><p>研究人员设计出新的恶意软件攻击方式，针对可编程逻辑控制器(PLC)，利用的是微处理器中的架构缺陷，可规避现有检测机制。</p><h3 id="攻击对象-v6"><a class="header-anchor" href="#攻击对象-v6">¶</a>攻击对象 :</h3><p>PLC、专用控制器</p><h3 id="攻击过程-：-v4"><a class="header-anchor" href="#攻击过程-：-v4">¶</a>攻击过程 ：</h3><p>PLC ROOTKIT在PLC操作系统不知道的情形下用恶意代码切换I/O引脚配置，从输出改成输入或反之。并且由于嵌入式设备(如PLC)所用片上系统(SoC)中，并没有用于引脚配置的硬件中断，因而试图向重配置成输入的引脚进行写入操作时，系统将不会收到任何报错。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;终于来啦，杰哥的第二篇博客&lt;/p&gt;</summary>
    
    
    
    <category term="网络安全" scheme="https://115jiege.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="工控事件" scheme="https://115jiege.github.io/tags/%E5%B7%A5%E6%8E%A7%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>针对一种新型Modbus Dos攻击的讨论</title>
    <link href="https://115jiege.github.io/2022/07/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Modbus%20DOS%E6%94%BB%E5%87%BB/"/>
    <id>https://115jiege.github.io/2022/07/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Modbus%20DOS%E6%94%BB%E5%87%BB/</id>
    <published>2022-07-21T06:21:16.826Z</published>
    <updated>2023-03-13T03:21:11.028Z</updated>
    
    <content type="html"><![CDATA[<p>工作一个周，摸鱼一个周，摩尔庄园也玩腻了，在much哥哥的诱惑下开始建立自己的博客。平时就记录一些学习的新知识和生活上的小乐趣，yey!</p><span id="more"></span><h2 id="WORK"><a class="header-anchor" href="#WORK">¶</a>WORK</h2><h3 id="Modbus-学习情况"><a class="header-anchor" href="#Modbus-学习情况">¶</a>Modbus 学习情况</h3><p>Modbus协议广泛用于工控系统（ICS/SCADA）上，主要分为Modbus TCP、Modbus RTU、Modbus ASCⅡ。目前学习的是Modbus TCP。</p><h4 id="Modbus-TCP包结构"><a class="header-anchor" href="#Modbus-TCP包结构">¶</a>Modbus TCP包结构</h4><p><img src="/../pic/Modbus%20TCP%20structure.png" alt="img"></p><p>Modbus TCP包最大为260字节：其中，MBAP报头占7字节，PDU最大可占252字节。<br>MBAP报头：事务处理ID 2字节，协议ID 2字节，长度2字节<br>PDU：单位ID 1字节，功能码 1字节，数据部分最大252字节</p><h4 id="poster2022-Wheels-on-the-Modbus-Attacking-ModbusTCP-Communications"><a class="header-anchor" href="#poster2022-Wheels-on-the-Modbus-Attacking-ModbusTCP-Communications">¶</a>poster2022-Wheels on the Modbus - Attacking ModbusTCP Communications</h4><p>师兄发的poster</p><p><strong>1.关注点</strong><br>Modbus TCP协议及漏洞<br>攻击：Mimt、Dos、未授权的访问攻击<br><strong>2.演示工具</strong><br>Mobdus服务器仿真工具：Modbuspal<br>wireshark<br>scapy<br><strong>3.创新点</strong><br>利用包寄存器构造flood<br><strong>4.试验台</strong><br>实验试验台由西门子标志PLC、温度和湿度传感器组成。<br>温度和湿度的值被不断地读取和实时显示在HMI上。<br>这些传感器都是硬连接到西门子LogoPLC的，而PLC使用ModbusTCP将这些值实时通信到HMI。<br>温度值存储在保持寄存器中，而湿度值存储在输入寄存器中。<br>HMI分别使用Modbus函数代码0x03（读取保持寄存器）和0x04（读取输入寄存器）定期轮询西门子LogoPLC的温度和湿度值。<br><strong>度量标准</strong>：通讯时间<br>一个查询-响应-攻击循环大约7 ms，在循环之间大约100 ms（100 ms是用于编写和注入我们的恶意数据包到网络的时间段）<br><strong>5.手段</strong><br>修改MBAP标头的长度字段（长度+2）<br>PDU层中加2个附加字段（4字节）<br>注入<br><strong>6.实验结果</strong><br>现场洪水攻击有效地迫使PLC进入只听模式约7分钟，最终达到DoS场景</p><p><strong>小结论</strong><br>这篇论文中通过轮询两个寄存器来模拟HMI和PLC之间的通讯（一般两者间的ModbusTCP通信是连续循环的）；实验中修改PDU报头中的长度字段（长度字段占2字节，数值范围0-2^16）使长度数值＋2，就有可能使Modbus ADU超出最大260字节，但长度字段未超出数值范围，最终导致通信中断，实现Dos攻击。<br>这类针对设备的Dos攻击一般都是发包，效果极其明显；目前需要研究的是能否实现对单个寄存器写操作的DOS攻击（使用smod框架）……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;工作一个周，摸鱼一个周，摩尔庄园也玩腻了，在much哥哥的诱惑下开始建立自己的博客。平时就记录一些学习的新知识和生活上的小乐趣，yey!&lt;/p&gt;</summary>
    
    
    
    <category term="网络安全" scheme="https://115jiege.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
</feed>
