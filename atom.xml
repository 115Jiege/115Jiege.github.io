<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiege</title>
  
  
  <link href="https://115jiege.github.io/atom.xml" rel="self"/>
  
  <link href="https://115jiege.github.io/"/>
  <updated>2023-07-03T03:20:06.041Z</updated>
  <id>https://115jiege.github.io/</id>
  
  <author>
    <name>Jiege</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我一点也不生气</title>
    <link href="https://115jiege.github.io/2023/07/03/%E6%97%A5%E5%B8%B8/%E6%88%91%E4%B8%80%E7%82%B9%E4%B9%9F%E4%B8%8D%E7%94%9F%E6%B0%94/"/>
    <id>https://115jiege.github.io/2023/07/03/%E6%97%A5%E5%B8%B8/%E6%88%91%E4%B8%80%E7%82%B9%E4%B9%9F%E4%B8%8D%E7%94%9F%E6%B0%94/</id>
    <published>2023-07-03T02:59:01.042Z</published>
    <updated>2023-07-03T03:20:06.041Z</updated>
    
    <content type="html"><![CDATA[<p>最近好烦，背一背古文静心叭。</p><h3 id="滕王阁序"><a class="header-anchor" href="#滕王阁序">¶</a>滕王阁序</h3><p><strong>滕王阁序</strong></p><p>【唐】王勃</p><blockquote><p>豫章故郡，洪都新府。星分翼轸，地接衡庐。襟三江而带五湖，控蛮荆而引瓯越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰。台隍枕夷夏之交，宾主尽东南之美。都督阎公之雅望，棨戟遥临；宇文新州之懿范，襜帷暂驻。十旬休假，胜友如云；千里逢迎，高朋满座。腾蛟起凤，孟学士之词宗；紫电青霜，王将军之武库。家君作宰，路出名区；童子何知，躬逢胜饯。</p></blockquote><blockquote><p>时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿。临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。</p></blockquote><blockquote><p>披绣闼，俯雕甍，山原旷其盈视，川泽纡其骇瞩。闾阎扑地，钟鸣鼎食之家；舸舰弥津，青雀黄龙之舳。云销雨霁，彩彻区明。落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨，雁阵惊寒，声断衡阳之浦。</p></blockquote><blockquote><p>遥襟甫畅，逸兴遄飞。爽籁发而清风生，纤歌凝而白云遏。睢园绿竹，气凌彭泽之樽；邺水朱华，光照临川之笔。四美具，二难并。穷睇眄于中天，极娱游于暇日。天高地迥，觉宇宙之无穷；兴尽悲来，识盈虚之有数。望长安于日下，目吴会于云间。地势极而南溟深，天柱高而北辰远。关山难越，谁悲失路之人；萍水相逢，尽是他乡之客。怀帝阍而不见，奉宣室以何年？</p></blockquote><blockquote><p>嗟乎！时运不齐，命途多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！</p></blockquote><blockquote><p>勃，三尺微命，一介书生。无路请缨，等终军之弱冠；有怀投笔，慕宗悫之长风。舍簪笏于百龄，奉晨昏于万里。非谢家之宝树，接孟氏之芳邻。他日趋庭，叨陪鲤对；今兹捧袂，喜托龙门。杨意不逢，抚凌云而自惜；钟期既遇，奏流水以何惭？</p></blockquote><blockquote><p>呜呼！胜地不常，盛筵难再；兰亭已矣，梓泽丘墟。临别赠言，幸承恩于伟饯；登高作赋，是所望于群公。敢竭鄙怀，恭疏短引；一言均赋，四韵俱成。请洒潘江，各倾陆海云尔：</p></blockquote><blockquote><p>滕王高阁临江渚，佩玉鸣鸾罢歌舞。<br>　　画栋朝飞南浦云，珠帘暮卷西山雨。<br>　　闲云潭影日悠悠，物换星移几度秋。<br>　　阁中帝子今何在？槛外长江空自流。</p></blockquote><h3 id="岳阳楼记"><a class="header-anchor" href="#岳阳楼记">¶</a>岳阳楼记</h3><p><strong>岳阳楼记</strong></p><p>【宋】范仲淹</p><blockquote><p>庆历四年春，滕子京谪守巴陵郡。越明年，政通人和，百废具兴，乃重修岳阳楼，增其旧制，刻唐贤今人诗赋于其上，属予作文以记之。</p></blockquote><blockquote><p>予观夫巴陵胜状，在洞庭一湖。衔远山，吞长江，浩浩汤汤，横无际涯，朝晖夕阴，气象万千，此则岳阳楼之大观也，前人之述备矣。然则北通巫峡，南极潇湘，迁客骚人，多会于此，览物之情，得无异乎？</p></blockquote><blockquote><p>若夫淫雨霏霏，连月不开，阴风怒号，浊浪排空，日星隐曜，山岳潜形，商旅不行，樯倾楫摧，薄暮冥冥，虎啸猿啼。登斯楼也，则有去国怀乡，忧谗畏讥，满目萧然，感极而悲者矣。</p></blockquote><blockquote><p>至若春和景明，波澜不惊，上下天光，一碧万顷，沙鸥翔集，锦鳞游泳，岸芷汀兰，郁郁青青。而或长烟一空，皓月千里，浮光跃金，静影沉璧，渔歌互答，此乐何极！登斯楼也，则有心旷神怡，宠辱偕忘，把酒临风，其喜洋洋者矣。</p></blockquote><blockquote><p>嗟夫！予尝求古仁人之心，或异二者之为，何哉？不以物喜，不以己悲，居庙堂之高则忧其民，处江湖之远则忧其君。是进亦忧，退亦忧。然则何时而乐耶？其必曰“先天下之忧而忧，后天下之乐而乐”乎！噫！微斯人，吾谁与归？</p></blockquote><blockquote><p>时六年九月十五日。</p></blockquote><h3 id="逍遥游"><a class="header-anchor" href="#逍遥游">¶</a>逍遥游</h3><p>庄子</p><blockquote><p>北冥有鱼，其名为鲲。鲲之大，不知其几千里也；化而为鸟，其名为鹏。鹏之背，不知其几千里也；怒而飞，其翼若垂天之云。是鸟也，海运则将徙于南冥。南冥者，天池也。《齐谐》者，志怪者也。《谐》之言曰：“鹏之徙于南冥也，水击三千里，抟扶摇而上者九万里，去以六月息者也。”野马也，尘埃也，生物之以息相吹也。天之苍苍，其正色邪？其远而无所至极邪？其视下也，亦若是则已矣。且夫水之积也不厚，则其负大舟也无力。覆杯水于坳堂之上，则芥为之舟；置杯焉则胶，水浅而舟大也。风之积也不厚，则其负大翼也无力。故九万里，则风斯在下矣，而后乃今培风；背负青天，而莫之夭阏者，而后乃今将图南。蜩与学鸠笑之曰：“我决起而飞，抢榆枋而止，时则不至，而控于地而已矣，奚以之九万里而南为？”适莽苍者，三餐而反，腹犹果然；适百里者，宿舂粮；适千里者，三月聚粮。之二虫又何知！小知不及大知，小年不及大年。奚以知其然也？朝菌不知晦朔，蟪蛄不知春秋，此小年也。楚之南有冥灵者，以五百岁为春，五百岁为秋；上古有大椿者，以八千岁为春，八千岁为秋。此大年也。而彭祖乃今以久特闻，众人匹之，不亦悲乎？</p></blockquote><blockquote><p>汤之问棘也是已：“穷发之北，有冥海者，天池也。有鱼焉，其广数千里，未有知其修者，其名为鲲。有鸟焉，其名为鹏，背若泰山，翼若垂天之云；抟扶摇羊角而上者九万里，绝云气，负青天，然后图南，且适南冥也。斥鷃笑之曰：‘彼且奚适也？我腾跃而上，不过数仞而下，翱翔蓬蒿之间，此亦飞之至也。而彼且奚适也？’”此小大之辩也。</p></blockquote><blockquote><p>故夫知效一官、行比一乡、德合一君、而征一国者，其自视也，亦若此矣。而宋荣子犹然笑之。且举世誉之而不加劝，举世非之而不加沮，定乎内外之分，辩乎荣辱之境，斯已矣。彼其于世，未数数然也。虽然，犹有未树也。夫列子御风而行，泠然善也，旬有五日而后反。彼于致福者，未数数然也。此虽免乎行，犹有所待者也。若夫乘天地之正，而御六气之辩，以游无穷者，彼且恶乎待哉？故曰：至人无己，神人无功，圣人无名。</p></blockquote><blockquote><p>尧让天下于许由，曰：“日月出矣，而爝火不息；其于光也，不亦难乎？时雨降矣，而犹浸灌；其于泽也，不亦劳乎？夫子立而天下治，而我犹尸之；吾自视缺然，请致天下。”许由曰：“子治天下，天下既已治也；而我犹代子，吾将为名乎？名者，实之宾也；吾将为宾乎？鹪鹩巢于深林，不过一枝；偃鼠饮河，不过满腹。归休乎君，予无所用天下为！庖人虽不治庖，尸祝不越樽俎而代之矣！”</p></blockquote><blockquote><p>肩吾问于连叔曰：“吾闻言于接舆，大而无当，往而不反。吾惊怖其言。犹河汉而无极也；大有径庭，不近人情焉。”连叔曰：“其言谓何哉？”曰：“藐姑射之山，有神人居焉。肌肤若冰雪，淖约若处子，不食五谷，吸风饮露，乘云气，御飞龙，而游乎四海之外；其神凝，使物不疵疠而年谷熟。吾以是狂而不信也。”连叔曰：“然。瞽者无以与乎文章之观，聋者无以与乎钟鼓之声。岂唯形骸有聋盲哉？夫知亦有之！是其言也犹时女也。之人也，之德也，将旁礴万物以为一，世蕲乎乱，孰弊弊焉以天下为事！之人也，物莫之伤：大浸稽天而不溺，大旱金石流，土山焦而不热。是其尘垢秕糠将犹陶铸尧舜者也，孰肯以物为事？”宋人资章甫而适诸越，越人断发文身，无所用之。尧治天下之民，平海内之政，往见四子藐姑射之山，汾水之阳，窅然丧其天下焉。</p></blockquote><blockquote><p>惠子谓庄子曰：“魏王贻我大瓠之种，我树之成，而实五石。以盛水浆，其坚不能自举也。剖之以为瓢，则瓠落无所容。非不呺然大也，吾为其无用而掊之。”庄子曰：“夫子固拙于用大矣。宋人有善为不龟手之药者，世世以洴澼絖为事。客闻之，请买其方百金。聚族而谋曰：‘我世世为洴澼絖，不过数金，今一朝而鬻技百金，请与之。’客得之，以说吴王。越有难，吴王使之将，冬，与越人水战，大败越人。裂地而封之。能不龟手一也，或以封，或不免于洴澼絖，则所用之异也。今子有五石之瓠，何不虑以为大樽，而浮于江湖，而忧其瓠落无所容？则夫子犹有蓬之心也夫！”</p></blockquote><blockquote><p>惠子谓庄子曰：“吾有大树，人谓之樗。其大本拥肿而不中绳墨，其小枝卷曲而不中规矩，立之涂，匠者不顾。今子之言大而无用，众所同去也。”庄子曰：“子独不见狸狌乎？卑身而伏，以候敖者；东西跳梁，不辟高下；中于机辟，死于罔罟。今夫斄牛，其大若垂天之云。此能为大矣，而不能执鼠。今子有大树，患其无用，何不树之于无何有之乡，广莫之野，彷徨乎无为其侧，逍遥乎寝卧其下。不夭斤斧，物无害者，无所可用，安所困苦哉！”</p></blockquote><h3 id="生于忧患，死于安乐"><a class="header-anchor" href="#生于忧患，死于安乐">¶</a>生于忧患，死于安乐</h3><p>孟子</p><blockquote><p>舜发于畎亩之中，傅说举于版筑之间，胶鬲举于鱼盐之中，管夷吾举于士，孙叔敖举于海，百里奚举于市。故天将降大任于是人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。</p></blockquote><blockquote><p>人恒过，然后能改；困于心，衡于虑，而后作；征于色，发于声，而后喻。入则无法家拂士，出则无敌国外患者，国恒亡。然后知生于忧患而死于安乐也。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近好烦，背一背古文静心叭。&lt;/p&gt;
&lt;h3 id=&quot;滕王阁序&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#滕王阁序&quot;&gt;¶&lt;/a&gt;滕王阁序&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;滕王阁序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;【唐】王勃&lt;/p&gt;
&lt;blockquo</summary>
      
    
    
    
    <category term="日常" scheme="https://115jiege.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="发疯" scheme="https://115jiege.github.io/tags/%E5%8F%91%E7%96%AF/"/>
    
  </entry>
  
  <entry>
    <title>github拉取上传失败的解决</title>
    <link href="https://115jiege.github.io/2023/06/30/tips%E6%95%B4%E7%90%86/github%E6%8B%89%E5%8F%96%E4%B8%8A%E4%BC%A0%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
    <id>https://115jiege.github.io/2023/06/30/tips%E6%95%B4%E7%90%86/github%E6%8B%89%E5%8F%96%E4%B8%8A%E4%BC%A0%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3/</id>
    <published>2023-06-30T07:40:10.601Z</published>
    <updated>2023-06-30T09:15:33.054Z</updated>
    
    <content type="html"><![CDATA[<p>今天久违的更新一下国密，结果push的时候提示<code>could not find UI helper 'GitHub.UI'</code>，并且卡死在这里。</p><p>bing了一下，两种原因；</p><h3 id="1-缺少凭据"><a class="header-anchor" href="#1-缺少凭据">¶</a>1.缺少凭据</h3><p>打开控制面板-&gt;用户账户-&gt;凭据管理器-&gt;管理Windows凭据；</p><p>添加普通凭据，</p><p>地址输入<a href="https://gitee.com/" title="https://gitee.com/">https://gitee.com/</a>，或者你的github地址，填写用户名密码。</p><h3 id="2-已配置其他凭据"><a class="header-anchor" href="#2-已配置其他凭据">¶</a>2.已配置其他凭据</h3><p>就像我。凭据是已经配置了的，但是！！我的git全局配置居然设了另一个凭据。</p><p>(git config --list可以查看当前git目录的配置)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git-credential-manager configure</span><br><span class="line"></span><br><span class="line">git-credential-manager get</span><br></pre></td></tr></table></figure><p>然后就有登录页面辣！重登就好~</p><h3 id="终极解决方法"><a class="header-anchor" href="#终极解决方法">¶</a>终极解决方法</h3><p>安装<a href="https://desktop.github.com/">GitHub Desktop | Simple collaboration from your desktop</a></p><p>方便好用的嘞。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天久违的更新一下国密，结果push的时候提示&lt;code&gt;could not find UI helper &#39;GitHub.UI&#39;&lt;/code&gt;，并且卡死在这里。&lt;/p&gt;
&lt;p&gt;bing了一下，两种原因；&lt;/p&gt;
&lt;h3 id=&quot;1-缺少凭据&quot;&gt;&lt;a class=&quot;head</summary>
      
    
    
    
    <category term="tips整理" scheme="https://115jiege.github.io/categories/tips%E6%95%B4%E7%90%86/"/>
    
    
    <category term="踩坑" scheme="https://115jiege.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>Windows开发——管理系统服务 </title>
    <link href="https://115jiege.github.io/2023/06/08/%E5%B9%B3%E5%8F%B0-Windows/Windows%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"/>
    <id>https://115jiege.github.io/2023/06/08/%E5%B9%B3%E5%8F%B0-Windows/Windows%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/</id>
    <published>2023-06-08T05:26:52.637Z</published>
    <updated>2023-06-30T09:10:30.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建删除"><a class="header-anchor" href="#创建删除">¶</a>创建删除</h2><h3 id="CreateService"><a class="header-anchor" href="#CreateService">¶</a>CreateService</h3><p><a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winsvc/nf-winsvc-createservicea">CreateService</a></p><ol><li><p>用途<br>创建服务对象并将其添加到指定的服务控制管理器数据库。</p></li><li><p>语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SC_HANDLE <span class="title">CreateServiceA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            SC_HANDLE hSCManager,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            LPCSTR    lpServiceName,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpDisplayName,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            DWORD     dwDesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            DWORD     dwServiceType,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            DWORD     dwStartType,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            DWORD     dwErrorControl,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpBinaryPathName,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpLoadOrderGroup,</span></span></span><br><span class="line"><span class="params"><span class="function">[out, optional] LPDWORD   lpdwTagId,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpDependencies,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpServiceStartName,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpPassword</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>返回值<br>如果函数成功，则返回值是服务的句柄。<br>如果函数失败，则返回值为 NULL。 要获得更多的错误信息，请调用 GetLastError</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CreateMyService</span><span class="params">(SC_HANDLE* scm, SC_HANDLE* myservice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 创建一个自启动服务 */</span></span><br><span class="line">SC_HANDLE service = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">std::wstring ServiceName = <span class="string">L&quot;Jiege Service&quot;</span>;</span><br><span class="line">std::wstring ShowServiceName = <span class="string">L&quot;Jiege&quot;</span>;</span><br><span class="line"></span><br><span class="line">DWORD dwError = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">service = <span class="built_in">OpenService</span>(*scm, ServiceName.<span class="built_in">c_str</span>(), SERVICE_ALL_ACCESS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (service != <span class="literal">NULL</span>)   <span class="comment">/* 服务已存在 */</span></span><br><span class="line">&#123;</span><br><span class="line">dwError = <span class="built_in">GetLastError</span>();</span><br><span class="line"><span class="built_in">LOG_ERROR</span>(<span class="string">&quot;OpenService error: &#123;0&#125;.&quot;</span>, dwError);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">DeleteService</span>(service))</span><br><span class="line">&#123;</span><br><span class="line">dwError = <span class="built_in">GetLastError</span>();</span><br><span class="line"><span class="built_in">LOG_ERROR</span>(<span class="string">&quot;DeleteService error: &#123;0&#125;.&quot;</span>, dwError);</span><br><span class="line">::<span class="built_in">CloseServiceHandle</span>(service);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::<span class="built_in">CloseServiceHandle</span>(service);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">service = <span class="built_in">CreateService</span>(*scm,</span><br><span class="line">ServiceName.<span class="built_in">c_str</span>(),</span><br><span class="line">ShowServiceName.<span class="built_in">c_str</span>(),</span><br><span class="line">SERVICE_ALL_ACCESS,</span><br><span class="line">SERVICE_WIN32_OWN_PROCESS,</span><br><span class="line">SERVICE_AUTO_START,</span><br><span class="line">SERVICE_ERROR_NORMAL,</span><br><span class="line"><span class="string">L&quot;F:/myproject/JiegeService/JiegeService.EXE&quot;</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(service))</span><br><span class="line">&#123;</span><br><span class="line">dwError = <span class="built_in">GetLastError</span>();</span><br><span class="line"><span class="built_in">LOG_ERROR</span>(<span class="string">&quot;CreateService error: &#123;0&#125;.&quot;</span>, dwError);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*myservice = service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="DeleteService"><a class="header-anchor" href="#DeleteService">¶</a>DeleteService</h3><p><a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winsvc/nf-winsvc-deleteservice">DeleteService</a></p><ol><li><p>用途<br>标记要从服务控制管理器数据库中删除的指定服务。</p></li><li><p>语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DeleteService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[in] SC_HANDLE hService</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>返回值<br>如果该函数成功，则返回值为非零值。<br>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。<br>服务控制管理器可以设置以下错误代码。 其他函数可能由服务控制管理器调用的注册表函数设置。</p><table><thead><tr><th>返回代码</th><th>说明</th></tr></thead><tbody><tr><td><strong>ERROR_ACCESS_DENIED</strong></td><td>句柄没有 DELETE 访问权限。</td></tr><tr><td><strong>ERROR_INVALID_HANDLE</strong></td><td>指定的句柄无效。</td></tr><tr><td><strong>ERROR_SERVICE_MARKED_FOR_DELETE</strong></td><td>指定的服务已被标记为要删除。</td></tr></tbody></table></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">       <span class="keyword">if</span> (!<span class="built_in">DeleteService</span>(service))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">LOG_ERROR</span>(<span class="string">&quot;DeleteService error.&quot;</span>);</span><br><span class="line">::<span class="built_in">CloseServiceHandle</span>(scm);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;DeleteService success.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::<span class="built_in">CloseServiceHandle</span>(scm);</span><br></pre></td></tr></table></figure></li></ol><h2 id="枚举信息"><a class="header-anchor" href="#枚举信息">¶</a>枚举信息</h2><h3 id="EnumServicesStatus"><a class="header-anchor" href="#EnumServicesStatus">¶</a>EnumServicesStatus</h3><ol><li><p>用途<br>枚举指定服务控制管理器数据库中的服务。 提供了每个服务的名称和状态。<br>此函数已被 EnumServicesStatusEx)函数取代。 它返回相同的信息 <strong>EnumServicesStatus</strong> 返回，以及进程标识符和服务的其他信息。 此外， <strong>EnumServicesStatusEx</strong> 使你可以枚举属于指定组的服务。</p></li><li><p>语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EnumServicesStatusA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[in]                SC_HANDLE              hSCManager,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]                DWORD                  dwServiceType,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]                DWORD                  dwServiceState,</span></span></span><br><span class="line"><span class="params"><span class="function">[out, optional]     LPENUM_SERVICE_STATUSA lpServices,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]                DWORD                  cbBufSize,</span></span></span><br><span class="line"><span class="params"><span class="function">[out]               LPDWORD                pcbBytesNeeded,</span></span></span><br><span class="line"><span class="params"><span class="function">[out]               LPDWORD                lpServicesReturned,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, out, optional] LPDWORD                lpResumeHandle</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>ENUM_SERVICE_STATUSA结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span></span><br><span class="line">LPSTR          lpServiceName;</span><br><span class="line">LPSTR          lpDisplayName;</span><br><span class="line">SERVICE_STATUS ServiceStatus;</span><br><span class="line">&#125; ENUM_SERVICE_STATUSA, *LPENUM_SERVICE_STATUSA;</span><br></pre></td></tr></table></figure><p>结构中包含服务名称，显示名称，启动状态.</p></li><li><p>返回值<br>如果该函数成功，则返回值为非零值。<br>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。 可能会返回以下错误。</p><table><thead><tr><th>返回代码</th><th>说明</th></tr></thead><tbody><tr><td><strong>ERROR_ACCESS_DENIED</strong></td><td>句柄没有<strong>SC_MANAGER_ENUMERATE_SERVICE</strong> 访问权限。</td></tr><tr><td><strong>ERROR_MORE_DATA</strong></td><td>缓冲区太小。 并非所有活动数据库中的数据都可以返回。<em>tbBytesNeeded</em> 参数包含接收剩余条目所需的字节数。</td></tr><tr><td><strong>ERROR_INVALID_PARAMETER</strong></td><td>使用了非法参数值。</td></tr><tr><td><strong>ERROR_INVALID_HANDLE</strong></td><td>该句柄无效。</td></tr><tr><td><strong>ERROR_INVALID_LEVEL</strong></td><td><em>InfoLevel</em> 参数包含不受支持的值。</td></tr><tr><td><strong>ERROR_SHUTDOWN_IN_PROGRESS</strong></td><td>系统正在关闭;无法调用此函数。</td></tr></tbody></table></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">LPENUM\_SERVICE\_STATUS lpServices    = <span class="literal">NULL</span>;   </span><br><span class="line"> DWORD    nSize = <span class="number">0</span>;</span><br><span class="line"> DWORD    n;</span><br><span class="line"> DWORD    nResumeHandle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> lpServices = (LPENUM\_SERVICE\_STATUS) <span class="built_in">LocalAlloc</span>(LPTR, <span class="number">64</span> \* <span class="number">1024</span>);   </span><br><span class="line"> <span class="built_in">EnumServicesStatus</span>(scm,SERVICE\_WIN32,   </span><br><span class="line">                    SERVICE\_STATE\_ALL,   </span><br><span class="line">                    (LPENUM\_SERVICE\_STATUS)lpServices,   </span><br><span class="line">                     <span class="number">64</span>  * <span class="number">1024</span>,   </span><br><span class="line">                     &amp;nSize,   </span><br><span class="line">                     &amp;n,   </span><br><span class="line">                     &amp;nResumeHandle);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n; i++)   </span><br><span class="line"> &#123; </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;服务名称: %s&quot;</span>,lpServices[i].lpServiceName);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;显示名称: %s&quot;</span>,lpServices[i].lpDisplayName);</span><br><span class="line">     <span class="keyword">if</span> ( lpServices[i].ServiceStatus.dwCurrentState!=SERVICE\_STOPPED)</span><br><span class="line">     &#123;   </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;启动状态:    已启动/n&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="EnumServicesStatusEx"><a class="header-anchor" href="#EnumServicesStatusEx">¶</a>EnumServicesStatusEx</h3><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-enumservicesstatusexa">EnumServicesStatusEx</a></p><ol><li><p>用途<br>枚举指定服务控制管理器数据库中的服务。 提供每个服务的名称和状态，以及基于指定信息级别的其他数据。</p></li><li><p>语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EnumServicesStatusExA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[in]                SC_HANDLE    hSCManager,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]                SC_ENUM_TYPE InfoLevel,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]                DWORD        dwServiceType,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]                DWORD        dwServiceState,</span></span></span><br><span class="line"><span class="params"><span class="function">[out, optional]     LPBYTE       lpServices,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]                DWORD        cbBufSize,</span></span></span><br><span class="line"><span class="params"><span class="function">[out]               LPDWORD      pcbBytesNeeded,</span></span></span><br><span class="line"><span class="params"><span class="function">[out]               LPDWORD      lpServicesReturned,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, out, optional] LPDWORD      lpResumeHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]      LPCSTR       pszGroupName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>返回值<br>如果该函数成功，则返回值为非零值。<br>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。 可能会返回以下错误。</p><table><thead><tr><th>返回代码</th><th>说明</th></tr></thead><tbody><tr><td><strong>ERROR_ACCESS_DENIED</strong></td><td>句柄没有<strong>SC_MANAGER_ENUMERATE_SERVICE</strong> 访问权限。</td></tr><tr><td><strong>ERROR_MORE_DATA</strong></td><td>缓冲区太小。 并非所有活动数据库中的数据都可以返回。<em>tbBytesNeeded</em> 参数包含接收剩余条目所需的字节数。</td></tr><tr><td><strong>ERROR_INVALID_PARAMETER</strong></td><td>使用了非法参数值。</td></tr><tr><td><strong>ERROR_INVALID_HANDLE</strong></td><td>该句柄无效。</td></tr><tr><td><strong>ERROR_INVALID_LEVEL</strong></td><td><em>InfoLevel</em> 参数包含不受支持的值。</td></tr><tr><td><strong>ERROR_SHUTDOWN_IN_PROGRESS</strong></td><td>系统正在关闭;无法调用此函数。</td></tr></tbody></table></li></ol><h3 id="QueryServiceConfig"><a class="header-anchor" href="#QueryServiceConfig">¶</a>QueryServiceConfig</h3><p><a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winsvc/nf-winsvc-queryserviceconfiga">QueryServiceConfig</a></p><ol><li><p>用途<br>检索指定服务的配置参数。</p></li><li><p>语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">QueryServiceConfigA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            SC_HANDLE               hService,</span></span></span><br><span class="line"><span class="params"><span class="function">[out, optional] LPQUERY_SERVICE_CONFIGA lpServiceConfig,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            DWORD                   cbBufSize,</span></span></span><br><span class="line"><span class="params"><span class="function">[out]           LPDWORD                 pcbBytesNeeded</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>返回值<br>如果该函数成功，则返回值为非零值。<br>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。<br>服务控制管理器可以设置以下错误代码。 其他可由服务控制管理器调用的注册表函数设置。</p><table><thead><tr><th>返回代码</th><th>说明</th></tr></thead><tbody><tr><td><strong>ERROR_ACCESS_DENIED</strong></td><td>句柄没有SERVICE_QUERY_CONFIG访问权限。</td></tr><tr><td><strong>ERROR_INSUFFICIENT_BUFFER</strong></td><td>服务配置信息比<em>lpServiceConfig</em> 缓冲区更适合。 获取所有信息所需的字节数在 <em>tbBytesNeededed</em> 参数中返回。 不写入 <em>lpServiceConfig</em>。</td></tr><tr><td><strong>ERROR_INVALID_HANDLE</strong></td><td>指定的句柄无效。</td></tr></tbody></table></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LPQUERY\_SERVICE\_CONFIG ServicesInfo = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n; i++)   </span><br><span class="line"> &#123;</span><br><span class="line">     SC_HANDLE service = <span class="literal">NULL</span>;</span><br><span class="line">     DWORD     nResumeHandle = <span class="number">0</span>; </span><br><span class="line">     service=<span class="built_in">OpenService</span>(scm,lpServices[i].lpServiceName,SERVICE_ALL_ACCESS);</span><br><span class="line">     ServicesInfo = (LPQUERY_SERVICE_CONFIG) <span class="built_in">LocalAlloc</span>(LPTR, <span class="number">64</span> \* <span class="number">1024</span>);      <span class="comment">//注意分配足够的空间</span></span><br><span class="line">     <span class="built_in">QueryServiceConfig</span>(service,ServicesInfo,<span class="number">64</span> \* <span class="number">1024</span>,&amp;nResumeHandle);      <span class="comment">//枚举各个服务信息</span></span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;程序路径: %s&quot;</span>,ServicesInfo-&gt;lpBinaryPathName);   </span><br><span class="line">     <span class="keyword">if</span>(<span class="number">2</span>==ServicesInfo-&gt;dwStartType)        <span class="comment">//启动方式   </span></span><br><span class="line">     &#123; </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;自动/n&quot;</span>);   </span><br><span class="line">     &#125;   </span><br><span class="line">     <span class="keyword">if</span>(<span class="number">3</span>==ServicesInfo-&gt;dwStartType)        &#123;   </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;手动/n&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(<span class="number">4</span>==ServicesInfo-&gt;dwStartType)   </span><br><span class="line">     &#123;   </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;禁止/n&quot;</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="配置权限"><a class="header-anchor" href="#配置权限">¶</a>配置权限</h2><h3 id="openSCManager"><a class="header-anchor" href="#openSCManager">¶</a>openSCManager</h3><p><a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winsvc/nf-winsvc-openscmanagera">OpenSCManager</a></p><ol><li><p>用途<br>建立与指定计算机上的服务控制管理器的连接，并打开指定的服务控制管理器数据库。</p></li><li><p>语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SC_HANDLE <span class="title">OpenSCManagerA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR lpMachineName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR lpDatabaseName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DWORD  dwDesiredAccess</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>返回值<br>如果函数成功，则返回值是指定服务控制管理器数据库的句柄。<br>如果函数失败，则返回值为 NULL。 要获得更多的错误信息，请调用GetLastError。<br>SCM 可以设置以下错误代码。 其他错误代码可由 SCM 调用的注册表函数设置。</p><table><thead><tr><th>返回代码</th><th>描述</th></tr></thead><tbody><tr><td><strong>ERROR_ACCESS_DENIED</strong></td><td>请求的访问被拒绝。</td></tr><tr><td><strong>ERROR_DATABASE_DOES_NOT_EXIST</strong></td><td>指定的数据库不存在。</td></tr></tbody></table></li><li><p>示例<br>以完全权限打开：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SC_HANDLE scm;</span><br><span class="line"><span class="keyword">if</span>((scm = <span class="built_in">openSCManager</span>(<span class="literal">NULL</span>,<span class="literal">NULL</span>,SC_MANAGER_ALL_ACCESS)==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;OpenSCManager Error/n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="openService"><a class="header-anchor" href="#openService">¶</a>openService</h3><p>[openService](<a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winsvc/nf-winsvc-openservicea">openServiceA 函数 (winsvc.h) - Win32 apps | Microsoft Learn</a>)</p><ol><li><p>用途<br>打开现有服务。</p></li><li><p>语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SC_HANDLE <span class="title">OpenServiceA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[in] SC_HANDLE hSCManager,</span></span></span><br><span class="line"><span class="params"><span class="function">[in] LPCSTR    lpServiceName,</span></span></span><br><span class="line"><span class="params"><span class="function">[in] DWORD     dwDesiredAccess</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>返回值<br>如果函数成功，则返回值是服务的句柄。<br>如果函数失败，则返回值为 NULL。 要获得更多的错误信息，请调用 GetLastError。<br>服务控制管理器可以设置以下错误代码。 其他函数可由服务控制管理器调用的注册表函数设置。</p><table><thead><tr><th>返回代码</th><th>描述</th></tr></thead><tbody><tr><td><strong>ERROR_ACCESS_DENIED</strong></td><td>句柄无权访问服务。</td></tr><tr><td><strong>ERROR_INVALID_HANDLE</strong></td><td>指定的句柄无效。</td></tr><tr><td><strong>ERROR_INVALID_NAME</strong></td><td>指定的服务名称无效。</td></tr><tr><td><strong>ERROR_SERVICE_DOES_NOT_EXIST</strong></td><td>指定的服务不存在。</td></tr></tbody></table></li><li><p>示例<br>以完全权限打开</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SC_HANDLE service;</span><br><span class="line"><span class="keyword">if</span>(!(service=<span class="built_in">OpenService</span>(scm,ServerName,SERVICE\_ALL\_ACCESS)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OpenService error!/n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="启动停止"><a class="header-anchor" href="#启动停止">¶</a>启动停止</h2><h3 id="startService"><a class="header-anchor" href="#startService">¶</a>startService</h3><p><a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winsvc/nf-winsvc-startservicea">startService</a></p><ol><li><p>用途<br>启动服务</p></li><li><p>语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">StartServiceA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[in]           SC_HANDLE hService,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]           DWORD     dwNumServiceArgs,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional] LPCSTR    *lpServiceArgVectors</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>返回值<br>如果该函数成功，则返回值为非零值。<br>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p></li></ol><h3 id="ControlService"><a class="header-anchor" href="#ControlService">¶</a>ControlService</h3><ol><li><p>用途<br>将控制代码发送到服务。</p></li><li><p>语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ControlService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[in]  SC_HANDLE        hService,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]  DWORD            dwControl,</span></span></span><br><span class="line"><span class="params"><span class="function">[out] LPSERVICE_STATUS lpServiceStatus</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>返回值<br>如果该函数成功，则返回值为非零值。<br>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p></li></ol><h2 id="更改启动方式"><a class="header-anchor" href="#更改启动方式">¶</a>更改启动方式</h2><h3 id="ChangeServiceConfig"><a class="header-anchor" href="#ChangeServiceConfig">¶</a>ChangeServiceConfig</h3><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-changeserviceconfiga">ChangeServiceConfig</a></p><ol><li><p>用途<br>更改服务的配置参数</p></li><li><p>语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ChangeServiceConfigA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            SC_HANDLE hService,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            DWORD     dwServiceType,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            DWORD     dwStartType,</span></span></span><br><span class="line"><span class="params"><span class="function">[in]            DWORD     dwErrorControl,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpBinaryPathName,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpLoadOrderGroup,</span></span></span><br><span class="line"><span class="params"><span class="function">[out, optional] LPDWORD   lpdwTagId,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpDependencies,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpServiceStartName,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpPassword,</span></span></span><br><span class="line"><span class="params"><span class="function">[in, optional]  LPCSTR    lpDisplayName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>返回值<br>如果该函数成功，则返回值为非零值。<br>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建删除&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#创建删除&quot;&gt;¶&lt;/a&gt;创建删除&lt;/h2&gt;
&lt;h3 id=&quot;CreateService&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#CreateService&quot;&gt;¶&lt;/</summary>
      
    
    
    
    <category term="平台-Windows" scheme="https://115jiege.github.io/categories/%E5%B9%B3%E5%8F%B0-Windows/"/>
    
    
    <category term="Windows" scheme="https://115jiege.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>qt获取屏幕分辨率</title>
    <link href="https://115jiege.github.io/2023/05/22/qt%E5%BC%80%E5%8F%91/qt%E5%BC%80%E5%8F%91--4/"/>
    <id>https://115jiege.github.io/2023/05/22/qt%E5%BC%80%E5%8F%91/qt%E5%BC%80%E5%8F%91--4/</id>
    <published>2023-05-22T07:29:30.696Z</published>
    <updated>2023-06-07T01:19:21.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="qt获取屏幕分辨率"><a class="header-anchor" href="#qt获取屏幕分辨率">¶</a>qt获取屏幕分辨率</h2><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取主屏分辨率 </span></span><br><span class="line"><span class="variable">QRect</span> <span class="variable">mRect</span>； </span><br><span class="line"><span class="variable">mRect</span> = <span class="variable">QGuiApplication</span>::<span class="function"><span class="title">primaryScreen</span>()-&gt;<span class="title">geometry</span>(); </span></span><br><span class="line"><span class="function"><span class="title">qDebug</span>()&lt;&lt;<span class="string">&quot;width:&quot;</span>&lt;&lt;<span class="variable">mRect.width</span>()&lt;&lt;<span class="string">&quot;  height:&quot;</span>&lt;&lt;<span class="variable">mRect.height</span>();</span></span><br></pre></td></tr></table></figure><p>.获取多个显示器屏幕大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取多显示器,通过list存储当前主机所有显示器 </span></span><br><span class="line">QList&lt;QScreen *&gt; list_screen = QGuiApplication::<span class="built_in">screens</span>(); </span><br><span class="line"><span class="comment">// 通过循环可以遍历每个显示器 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list_screen.<span class="built_in">size</span>(); i++) </span><br><span class="line">&#123; </span><br><span class="line">    QRect rect = list_screen.<span class="built_in">at</span>(i)-&gt;<span class="built_in">geometry</span>(); </span><br><span class="line">    <span class="type">int</span> desktop_width = rect.<span class="built_in">width</span>(); </span><br><span class="line">    <span class="type">int</span> desktop_height = rect.<span class="built_in">height</span>(); </span><br><span class="line">    <span class="comment">// 打印屏幕分辨率 </span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; desktop_width &lt;&lt;desktop_height; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>error：</p><p><a href="http://libQt5WebEngineCore.so">libQt5WebEngineCore.so</a>: .dynsym local <a href="https://so.csdn.net/so/search?q=symbol&amp;spm=1001.2101.3001.7020">symbol</a> at index 3</p><p>解决：sudo ln -sf /usr/bin/x86_64-linux-gnu-ld.gold /usr/bin/ld</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;qt获取屏幕分辨率&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#qt获取屏幕分辨率&quot;&gt;¶&lt;/a&gt;qt获取屏幕分辨率&lt;/h2&gt;
&lt;figure class=&quot;highlight isbl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte</summary>
      
    
    
    
    <category term="qt" scheme="https://115jiege.github.io/categories/qt/"/>
    
    
    <category term="qt" scheme="https://115jiege.github.io/tags/qt/"/>
    
  </entry>
  
  <entry>
    <title>root权限启动QtWebEngine</title>
    <link href="https://115jiege.github.io/2023/05/22/%E5%B9%B3%E5%8F%B0-Linux/root%E6%9D%83%E9%99%90%E5%90%AF%E5%8A%A8QtWebEngine/"/>
    <id>https://115jiege.github.io/2023/05/22/%E5%B9%B3%E5%8F%B0-Linux/root%E6%9D%83%E9%99%90%E5%90%AF%E5%8A%A8QtWebEngine/</id>
    <published>2023-05-22T07:12:45.668Z</published>
    <updated>2023-06-07T00:38:53.982Z</updated>
    
    <content type="html"><![CDATA[<p>QtWebEngine这个部件用到了chrome的插件，众所周知，chrome不允许在root权限下启动，除非加上–no-sandbox；</p><p>所以这里的解决方案也是一样，选择无沙盒启动。</p><h3 id="Qt调试"><a class="header-anchor" href="#Qt调试">¶</a>Qt调试</h3><p>对于以root权限在Qtcreator中调试含QtWebEngine的工程的情况，可以项目-&gt;运行-&gt;环境中添加一个新的变量</p><p>QTWEBENGINE_DISABLE_SANDBOX，并置其为1。</p><h3 id="脚本启动"><a class="header-anchor" href="#脚本启动">¶</a>脚本启动</h3><p>对于脚本启动则需要在脚本中添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> XDG_RUNTIME_DIR=/tmp/runtime-root</span><br><span class="line"><span class="built_in">export</span> QTWEBENGINE_DISABLE_SANDBOX=1</span><br></pre></td></tr></table></figure><h3 id="自定义宏编译"><a class="header-anchor" href="#自定义宏编译">¶</a>自定义宏编译</h3><p>题外话，在编译阶段，如果想根据宏的开关选择不同的链接库活着编译不同的代码，</p><p>可以在项目-&gt;构建-&gt;构建的步骤-&gt;qmake-&gt;额外的参数中添加’DEFINES+=XXX’(单引号不要漏掉)；</p><p>这样就可以在pro文件和工程其他文件中使用了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> XXX</span></span><br><span class="line"> ......</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> ......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;QtWebEngine这个部件用到了chrome的插件，众所周知，chrome不允许在root权限下启动，除非加上–no-sandbox；&lt;/p&gt;
&lt;p&gt;所以这里的解决方案也是一样，选择无沙盒启动。&lt;/p&gt;
&lt;h3 id=&quot;Qt调试&quot;&gt;&lt;a class=&quot;header-an</summary>
      
    
    
    
    <category term="平台-Linux" scheme="https://115jiege.github.io/categories/%E5%B9%B3%E5%8F%B0-Linux/"/>
    
    
    <category term="Linux" scheme="https://115jiege.github.io/tags/Linux/"/>
    
    <category term="qtcreator" scheme="https://115jiege.github.io/tags/qtcreator/"/>
    
    <category term="QtWebEngine" scheme="https://115jiege.github.io/tags/QtWebEngine/"/>
    
  </entry>
  
  <entry>
    <title>linux平台打包qt应用程序</title>
    <link href="https://115jiege.github.io/2023/05/22/%E5%B9%B3%E5%8F%B0-Linux/linux%E5%B9%B3%E5%8F%B0%E6%89%93%E5%8C%85qt%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>https://115jiege.github.io/2023/05/22/%E5%B9%B3%E5%8F%B0-Linux/linux%E5%B9%B3%E5%8F%B0%E6%89%93%E5%8C%85qt%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</id>
    <published>2023-05-22T06:37:02.066Z</published>
    <updated>2023-06-07T05:12:43.555Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做Linux平台的Qt开发，功能基本实现之后，就要考虑应用程序的打包了。</p><h2 id="LINUX打包步骤"><a class="header-anchor" href="#LINUX打包步骤">¶</a>LINUX打包步骤</h2><h3 id="环境"><a class="header-anchor" href="#环境">¶</a>环境</h3><p>os：ubuntu 20.04</p><p>开发工具：qt5.15.2(默认安装目录/opt/Qt)</p><h3 id="linuxdeployqt打包"><a class="header-anchor" href="#linuxdeployqt打包">¶</a>linuxdeployqt打包</h3><p>linux平台打包qt可以用linuxdeployqt一键部署，不用担心会少了什么，推荐先使用这个方法！</p><ol><li><p>下载<br><a href="https://github.com/probonopd/linuxdeployqt/releases">Download linuxdeployqt</a><br>下载编译好的linuxdeployqt应用程序，我这里用的是linuxdeployqt-continuous-x86_64.AppImage，或者也可以下载源码创建linuxdeployqt docker版。</p></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x linuxdeployqt-5-x86_64.AppImage</span><br><span class="line"><span class="built_in">cp</span> linuxdeployqt-5-x86_64.AppImage /usr/local/bin/linuxdeployqt</span><br></pre></td></tr></table></figure></li><li><p>添加环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># QT_HOME是自己安装的路径</span></span><br><span class="line"><span class="built_in">export</span> QT_HOME=/opt/Qt/5.15.2/gcc_64  <span class="comment">#修改QT_HOME</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:<span class="variable">$&#123;QT_HOME&#125;</span>/lib</span><br><span class="line"><span class="built_in">export</span> QT_PLUGIN_PATH=<span class="variable">$QT_PLUGIN_PATH</span>:<span class="variable">$&#123;QT_HOME&#125;</span>/plugins</span><br><span class="line"><span class="built_in">export</span> QML2_IMPORT_PATH=<span class="variable">$QML2_IMPORT_PATH</span>:<span class="variable">$&#123;QT_HOME&#125;</span>/qml</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$&#123;QT_HOME&#125;</span>/bin</span><br></pre></td></tr></table></figure></li><li><p>打包qt程序<br>编译Release版本的目标程序，执行linuxdeployqt。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># linuxdeployqt 程序名称 -appimage -always-overwrite</span></span><br><span class="line">linuxdeployqt VPNClient_Web -appimage -always-overwrite</span><br></pre></td></tr></table></figure></li><li><p>运行打包好的程序<br>运行linuxdeployqt中生成的AppRun程序。</p></li></ol><h3 id="自制脚本打包"><a class="header-anchor" href="#自制脚本打包">¶</a>自制脚本打包</h3><p>当然linuxdeployqt可能会拷贝不全，从而导致程序运行出错。<br>比如对含有QtWebEngine的程序，使用linuxdeployqt一键打包，运行时出现缺少libsoftokn3.so库、缺少libmozsqlite3.so库等错误。<br>根本原因就是缺少了需要的nss，这时需要手动把nss目录下的所有文件拷贝到linuxdeployqt生成的lib文件夹下。<br>这时可以寄几制作打包脚本，运行脚本一键打包，不过脚本的制作需要考虑全面，可能比较复杂，可以对比两种方式实现打包。</p><h4 id="准备ldd-sh"><a class="header-anchor" href="#准备ldd-sh">¶</a><a href="http://xn--ldd-361er54a.sh">准备ldd.sh</a></h4><p><code>ldd.sh</code>：在当前目录下新建lib文件夹，拷贝目标程序的依赖库，存放到新建的lib下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 ldd.sh</span><br></pre></td></tr></table></figure><h4 id="制作打包脚本（copy-lib-sh）"><a class="header-anchor" href="#制作打包脚本（copy-lib-sh）">¶</a>制作打包脚本（copy_lib.sh）</h4><ol><li><p>变量设置</p><p>设置QT安装路径 QT_HOME=</p><p>设置目标文件夹 target_dir=</p><p>设置应用程序命 appname=</p></li><li><p>添加目标程序<br>将目标程序(mytest)、<a href="http://ldd.sh">ldd.sh</a> 和它的依赖库拷贝到目标文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> mytest <span class="variable">$target_dir</span></span><br><span class="line"><span class="built_in">cp</span> ldd.sh <span class="variable">$target_dir</span></span><br></pre></td></tr></table></figure></li><li><p>添加程序依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ldd.sh mytest</span><br></pre></td></tr></table></figure><p>会在目标文件夹下生成lib目录，存放程序的依赖库。</p></li><li><p>添加qt依赖<br>创建plugins目录，拷贝qt的platfroms文件夹到目标文件夹的plugins目录;对platforms目录下的libqxcb.so生成qt依赖库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> plugins</span><br><span class="line"><span class="built_in">cp</span> -r <span class="variable">$QT_HOME</span>/plugins/platforms  <span class="variable">$target_dir</span>/plugins</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$target_dir</span>/plugins/platforms</span><br><span class="line">./ldd.sh libqxcb.so</span><br></pre></td></tr></table></figure><p>拷贝platfroms/lib目录下的所有文件到目标文件夹的lib目录，删除lib目录和目标文件夹中的ldd.sh文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> <span class="variable">$target_dir</span>/platforms/lib/* <span class="variable">$target_dir</span>/lib</span><br><span class="line"><span class="built_in">rm</span> -r <span class="variable">$target_dir</span>/platforms/lib</span><br><span class="line"><span class="built_in">rm</span> <span class="variable">$target_dir</span>/ldd.sh</span><br></pre></td></tr></table></figure></li><li><p>添加XCB</p><p>拷贝qt的xcbglintegrations目录到目标文件夹的plugins目录；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r <span class="variable">$QT_HOME</span>/plugins/xcbglintegrations  <span class="variable">$target_dir</span>/plugins</span><br></pre></td></tr></table></figure></li><li><p>（可选）拷贝WebEngine依赖</p><p>如果项目工程里用到了QtWebEngine插件，那么为了WebEngine的正常运行，还需要拷贝其他依赖库。</p><ol><li>添加QtWebEngine程序</li></ol><p>目标文件夹下新建libexec目录，拷qt的QtWebEngineProcess程序到libexec目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>  <span class="variable">$target_dir</span></span><br><span class="line"><span class="built_in">mkdir</span> libexec</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$QT_HOME</span>/libexec/QtWebEngineProcess <span class="variable">$target_dir</span>/libexec/</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>拷贝插件<br>拷贝qt目录的bearer、imageformats、platforminputcontexts、platformthemes拷贝到目标文件夹的plugins目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r <span class="variable">$QT_HOME</span>/plugins/bearer <span class="variable">$target_dir</span>/plugins/</span><br><span class="line"><span class="built_in">cp</span> -r <span class="variable">$QT_HOME</span>/plugins/imageformats <span class="variable">$target_dir</span>/plugins/</span><br><span class="line"><span class="built_in">cp</span> -r <span class="variable">$QT_HOME</span>/plugins/platforminputcontexts <span class="variable">$target_dir</span>/plugins/</span><br><span class="line"><span class="built_in">cp</span> -r <span class="variable">$QT_HOME</span>/plugins/platformthemes <span class="variable">$target_dir</span>/plugins/</span><br></pre></td></tr></table></figure></li><li><p>拷贝资源文件<br>拷贝qt的resources目录到目标文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r <span class="variable">$QT_HOME</span>/resources <span class="variable">$target_dir</span></span><br></pre></td></tr></table></figure></li><li><p>拷贝翻译文件<br>拷贝qt的translations目录到目标文件夹；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r <span class="variable">$QT_HOME</span>/translations <span class="variable">$target_dir</span></span><br></pre></td></tr></table></figure></li><li><p>添加nss<br>拷贝系统的nss文件夹下所有文件到到目标文件夹的lib目录；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nss_path=`find /usr/ -name nss`</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$nss_path</span>/* <span class="variable">$target_dir</span>/lib</span><br></pre></td></tr></table></figure></li></ol><h4 id="制作运行脚本"><a class="header-anchor" href="#制作运行脚本">¶</a>制作运行脚本</h4><p>打包好的程序怎么执行呢？</p><p>解压压缩包，<a href="http://xn--sudomytest-cc9tv146a.sh">sudo执行mytest.sh</a>。</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./mytest.sh</span><br></pre></td></tr></table></figure><h3 id="脚本示例："><a class="header-anchor" href="#脚本示例：">¶</a>脚本示例：</h3><p>源码模板</p><ol><li><p><a href="http://ldd.sh">ldd.sh</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">LibDir=<span class="variable">$PWD</span><span class="string">&quot;/lib&quot;</span></span><br><span class="line">Target=<span class="variable">$1</span></span><br><span class="line">lib_array=($(ldd <span class="variable">$Target</span> | grep -o <span class="string">&quot;/.*&quot;</span> | grep -o <span class="string">&quot;/.*/[^[:space:]]*&quot;</span>))</span><br><span class="line">$(<span class="built_in">mkdir</span> <span class="variable">$LibDir</span>)</span><br><span class="line"><span class="keyword">for</span> Variable <span class="keyword">in</span> <span class="variable">$&#123;lib_array[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">cp</span> <span class="string">&quot;<span class="variable">$Variable</span>&quot;</span> <span class="variable">$LibDir</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p><a href="http://xn--mytest-2g4m562owsnywr.sh">运行脚本mytest.sh</a>(与可执行程序同名)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">appname=`<span class="built_in">basename</span> <span class="variable">$0</span> | sed s,\.sh$,,`</span><br><span class="line"><span class="built_in">dirname</span>=`<span class="built_in">dirname</span> <span class="variable">$0</span>`</span><br><span class="line">tmp=<span class="string">&quot;<span class="variable">$&#123;dirname#?&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;dirname%$tmp&#125;</span>&quot;</span> != <span class="string">&quot;/&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">dirname</span>=<span class="variable">$PWD</span>/<span class="variable">$dirname</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">LD_LIBRARY_PATH=<span class="variable">$dirname</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH</span><br><span class="line"><span class="variable">$dirname</span>/<span class="variable">$appname</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span> </span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在做Linux平台的Qt开发，功能基本实现之后，就要考虑应用程序的打包了。&lt;/p&gt;
&lt;h2 id=&quot;LINUX打包步骤&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#LINUX打包步骤&quot;&gt;¶&lt;/a&gt;LINUX打包步骤&lt;/h2&gt;
&lt;h3 id=&quot;环境&quot;</summary>
      
    
    
    
    <category term="平台-Linux" scheme="https://115jiege.github.io/categories/%E5%B9%B3%E5%8F%B0-Linux/"/>
    
    
    <category term="qt" scheme="https://115jiege.github.io/tags/qt/"/>
    
    <category term="linuxdeployqt" scheme="https://115jiege.github.io/tags/linuxdeployqt/"/>
    
  </entry>
  
  <entry>
    <title>使用U盘重装Win10系统</title>
    <link href="https://115jiege.github.io/2023/05/12/%E5%B9%B3%E5%8F%B0-Windows/%E4%BD%BF%E7%94%A8U%E7%9B%98%E9%87%8D%E8%A3%85Win10%E7%B3%BB%E7%BB%9F/"/>
    <id>https://115jiege.github.io/2023/05/12/%E5%B9%B3%E5%8F%B0-Windows/%E4%BD%BF%E7%94%A8U%E7%9B%98%E9%87%8D%E8%A3%85Win10%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-05-12T01:43:14.000Z</published>
    <updated>2023-05-12T01:43:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工具准备"><a class="header-anchor" href="#工具准备">¶</a>工具准备</h2><ol><li>U盘<br>准备一个8G以上的空白U盘<br>注意：<strong>制作系统重装工具会格式化U盘，需要做好U盘文件备份</strong></li><li>Windows下载工具<br><a href="https://www.microsoft.com/zh-cn/software-download/windows10">官方下载连接</a></li></ol><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-12-10-08-55-image.png" alt></p><h2 id="制作安装U盘"><a class="header-anchor" href="#制作安装U盘">¶</a>制作安装U盘</h2><ol><li><p>双击下载的文件</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-12-10-10-24-image.png" alt></p></li><li><p>同意所有不平等条约</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-12-10-11-46-image.png" alt></p></li><li><p>选择为另一台电脑创建安装介质</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-12-10-12-38-image.png" alt></p></li><li><p>取消勾选“对这台电脑使用推荐的选项”，如果是DIY主机，建议选择“专业版”；否则选择家庭版，可以免去激活过程。</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-12-10-14-01-image.png" alt></p></li><li><p>选择使用的介质</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-12-10-17-25-image.png" alt></p></li><li><p>选择U盘</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-12-10-18-11-image.png" alt></p><p><strong>制作系统重装工具会格式化U盘，需要做好U盘文件备份</strong></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;工具准备&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#工具准备&quot;&gt;¶&lt;/a&gt;工具准备&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;U盘&lt;br&gt;
准备一个8G以上的空白U盘&lt;br&gt;
注意：&lt;strong&gt;制作系统重装工具会格式化U盘，需要做好U盘文件备份&lt;/s</summary>
      
    
    
    
    <category term="平台-Windows" scheme="https://115jiege.github.io/categories/%E5%B9%B3%E5%8F%B0-Windows/"/>
    
    
    <category term="Windows" scheme="https://115jiege.github.io/tags/Windows/"/>
    
    <category term="U盘" scheme="https://115jiege.github.io/tags/U%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>Linux捕获程序崩溃异常——qbreakpad</title>
    <link href="https://115jiege.github.io/2023/05/08/%E5%B9%B3%E5%8F%B0-Linux/Linux%E6%8D%95%E8%8E%B7%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E5%BC%82%E5%B8%B8/"/>
    <id>https://115jiege.github.io/2023/05/08/%E5%B9%B3%E5%8F%B0-Linux/Linux%E6%8D%95%E8%8E%B7%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E5%BC%82%E5%B8%B8/</id>
    <published>2023-05-08T07:58:08.000Z</published>
    <updated>2023-05-08T09:21:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>在进行Linux平台的qt程序开发时，出现程序崩溃退出的情况，而且没有什么信息(ˉ▽ˉ；)…。</p><p>bing了一下发现一个可以定位崩溃位置的工具qbreakpad，这里记录一下qbreakpad的安装过程。</p><h1>qbreakpad的安装过程</h1><h2 id="源码准备"><a class="header-anchor" href="#源码准备">¶</a>源码准备</h2><h3 id="下载Breakpad源码"><a class="header-anchor" href="#下载Breakpad源码">¶</a>下载Breakpad源码</h3><p><a href="https://github.com/google/breakpad">下载地址</a></p><p>建议选择tags=<strong>v2021.08.09</strong></p><h3 id="下载LSS源码"><a class="header-anchor" href="#下载LSS源码">¶</a>下载LSS源码</h3><p><a href="https://github.com/ithaibo/linux-syscall-support">下载地址</a></p><p>需要注意，如果您的gcc版本高于9.0，在构建breakpad时可能会报错：</p><p><code>linux\_syscall\_support.h: error: listing the stack pointer register 'rsp' in a clobber list is deprecated</code></p><p>解决：更换修正版lss</p><p><a href="https://chromium.googlesource.com/linux-syscall-support/+/8048ece6c16c91acfe0d36d1d3cc0890ab6e945c">下载地址</a></p><h3 id="下载qBreakpad源码"><a class="header-anchor" href="#下载qBreakpad源码">¶</a>下载qBreakpad源码</h3><p><a href="https://github.com/buzzySmile/qBreakpad">下载地址</a></p><h2 id="编译qBreakpad"><a class="header-anchor" href="#编译qBreakpad">¶</a>编译qBreakpad</h2><p>下载qBreakpad源码，在<code>qBreakpad/third_party</code>目录下，把下载好的LSS源码和Breakpad源码放入其中；修改文件夹名为lss和breakpad;</p><p><a href="http://xn--qtcreatorqBreakpad-ci98aj42blj7g.pro">用qtcreator打开qBreakpad.pro</a>，直接构建；</p><p>构建成功后，会在<code>qBreakpad/handler</code> 目录下生成<code>libqBreakpad.a</code>文件，保存目录下的头文件<code>QBreakpadHandler.h、QBreakpadHttpUploader.h、singletone/call_once.h、singletone/singleton.h</code>。</p><h2 id="调用qBreakpad"><a class="header-anchor" href="#调用qBreakpad">¶</a>调用qBreakpad</h2><p>在自己的qt工程(qbreakpadTest)下新建qBreakpad目录，将<code>libqBreakpad.a</code>拷贝至，<code>qBreakpad\lib\</code>目录下；</p><p>将调用库所需的头文件<code>QBreakpadHandler.h、QBreakpadHttpUploader.h、call_once.h、singleton.h</code>共4个文件拷贝至<code>qBreakpad\include</code>下。</p><p>在qbreakTest.pro下增加以下内容：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############ for qBreakpad ############</span></span><br><span class="line"><span class="comment"># qBreakpad中需要使用到network模块</span></span><br><span class="line"><span class="attr">QT</span> <span class="string">+= network</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 启用多线程、异常、RTTI、STL支持</span></span><br><span class="line"><span class="attr">CONFIG</span> <span class="string">+= thread exceptions rtti stl</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># without c++11 &amp; AppKit library compiler can&#x27;t solve address for symbols</span></span><br><span class="line"><span class="attr">CONFIG</span> <span class="string">+= c++11</span></span><br><span class="line"><span class="attr">macx</span>: <span class="string">LIBS += -framework AppKit</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 配置头文件搜索路径和链接库路径</span></span><br><span class="line"><span class="attr">unix</span>:<span class="string">!macx: LIBS += -L$$PWD/qBreakpad/lib/ -lqBreakpad</span></span><br><span class="line"></span><br><span class="line"><span class="attr">INCLUDEPATH</span> <span class="string">+= $$PWD/qBreakpad/include</span></span><br><span class="line"><span class="attr">DEPENDPATH</span> <span class="string">+= $$PWD/qBreakpad/include</span></span><br><span class="line"></span><br><span class="line"><span class="attr">unix</span>:<span class="string">!macx: PRE_TARGETDEPS += $$PWD/qBreakpad/lib/libqBreakpad.a</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">############ for qBreakpad ############</span></span><br></pre></td></tr></table></figure><p>在main.cpp中添加</p><p><code> QBreakpadInstance.setDumpPath(&quot;crashes&quot;); // 设置生成dump文件路径</code></p><p>崩溃示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">qBreakpadTest::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QLabel * label = <span class="literal">nullptr</span>;</span><br><span class="line">    label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;crash&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译，运行程序，生成的<code>dump</code>文件存放在<code>Debug/crashes</code>目录下。</p><h2 id="编译breakpad"><a class="header-anchor" href="#编译breakpad">¶</a>编译breakpad</h2><p><code>Breakpad</code>提供了两个工具<code>dump_syms</code>和<code>minidump_stackwalk</code>，用于分析<code>dump</code>，定位<code>bug</code>。</p><p>下载<code>Breakpad</code>源码，将<code>LSS(linux-syscall-support)</code>源码拷贝至<code>breakpad\src\third_party</code>目录下，并重命名为lss；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> breakpad</span><br><span class="line"><span class="built_in">chmod</span> 755 configure</span><br><span class="line">./configure</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>编译完成后，在<code>breakpad/src/tools/linux/dump_syms</code>目录下，生成了<code>dump_syms</code>；</p><p>在<code>breakpad/src/processor</code>目录下，生成了<code>minidump_stackwalk</code>。</p><h2 id="使用dump-syms和minidump-stackwalk定位bug"><a class="header-anchor" href="#使用dump-syms和minidump-stackwalk定位bug">¶</a>使用dump_syms和minidump_stackwalk定位bug</h2><h3 id="1、生成符号文件"><a class="header-anchor" href="#1、生成符号文件">¶</a>1、生成符号文件</h3><p>使用<code>dump_syms</code>读取带调试信息的程序文件，并生成符号文件<code>qBreakpadTest.sym</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump_syms ./qBreakpadTest &gt; qBreakpadTest.sym</span><br></pre></td></tr></table></figure><h3 id="2、将符号文件移动到特定路径"><a class="header-anchor" href="#2、将符号文件移动到特定路径">¶</a>2、将符号文件移动到特定路径</h3><p>在自己的qt工程(qBreakpadTest)所在目录下，创建目录结构：</p><ul><li>第一级目录，固定为<code>symbols</code>；</li><li>第二级目录，为即将放入的<code>符号文件名称</code>，如<code>qBreakpadTest.sym</code>，则目录名为<code>qBreakpadTest</code>；</li><li>第三级目录，在sym文件中第一行内容，有一串<code>16进制</code>编号，将其作为<code>目录名</code>。</li></ul><p>建立好以上路径后，将<code>qBreakpadTest.sym</code>移动到此路径下。</p><h3 id="3、生成崩溃处调用堆栈信息"><a class="header-anchor" href="#3、生成崩溃处调用堆栈信息">¶</a>3、生成崩溃处调用堆栈信息</h3><p>将<code>crashes目录</code>拷贝到和<code>symbols目录</code>一个级别目录下；</p><p>然后执行如下命令，生成调用堆栈信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minidump_stackwalk ./crashes/7211c8b8-126d-4de2-7f8f00a4-db86eecc.dmp ./symbols &gt; error.log</span><br></pre></td></tr></table></figure><p>第一个参数，是dump文件名；<br>第二个参数，固定为./symbols，应该是指定符号文件位于当前symbols目录下默认路径位置；<br>第三个参数，将命令执行结果，写入到error.log文件中。</p><p>查看生成的堆栈调用信息文件<code>error.log</code>，找到<code>“crashed”</code>字样，与它最近的一行，就是发生崩溃时，程序的调用堆栈。</p><h3 id="4、dump文件上报"><a class="header-anchor" href="#4、dump文件上报">¶</a>4、dump文件上报</h3><p>将生成的<code>dump</code>文件上传到指定的服务器。</p><ul><li>先通过setDumpPath设置dump文件生成目录；以便在发生崩溃时，自动在该目录下生成dump文件。</li><li>再通过setUploadUrl设置上报地址，以便后续将dump文件，上传到该地址。</li><li>最后，通过sendDumps将dump文件发送至服务器。该函数会自动遍历，前面设置的dump生成目录，将每一个dump文件进行发送。</li></ul><p>上报演示程序，位于<code>qBreakpad\demo\reporter</code>下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在进行Linux平台的qt程序开发时，出现程序崩溃退出的情况，而且没有什么信息(ˉ▽ˉ；)…。&lt;/p&gt;
&lt;p&gt;bing了一下发现一个可以定位崩溃位置的工具qbreakpad，这里记录一下qbreakpad的安装过程。&lt;/p&gt;
&lt;h1&gt;qbreakpad的安装过程&lt;/h1&gt;
</summary>
      
    
    
    
    <category term="平台-Linux" scheme="https://115jiege.github.io/categories/%E5%B9%B3%E5%8F%B0-Linux/"/>
    
    
    <category term="Linux" scheme="https://115jiege.github.io/tags/Linux/"/>
    
    <category term="qBreakpad" scheme="https://115jiege.github.io/tags/qBreakpad/"/>
    
  </entry>
  
  <entry>
    <title>u盘格式错误</title>
    <link href="https://115jiege.github.io/2023/05/05/%E5%B9%B3%E5%8F%B0-Windows/u%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%98%E4%B8%BARAW/"/>
    <id>https://115jiege.github.io/2023/05/05/%E5%B9%B3%E5%8F%B0-Windows/u%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%98%E4%B8%BARAW/</id>
    <published>2023-05-05T00:23:30.000Z</published>
    <updated>2023-05-05T00:46:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有用的u盘，今天插了试了一下，发现U盘无法被读取，于是开始排查原因；</p><p>首先检查驱动，计算机-&gt;管理-&gt;设备管理器查看驱动，驱动没有问题；</p><p>检查磁盘分区，win+R，输入diskmgmt.msc，找到出错的u盘，发现文件系统为RAW？？(ˉ▽ˉ；)…</p><p><code>RAW格式(未格式化)磁盘代表文档系统已损坏，导致系统无法识别是FAT、NTFS、EXT2或EXT3…等格式。在这种情况下，您无法存取这台磁盘且无法使用磁盘中的文档。引发这种问题的原因有很多种，可能是因为感染病毒、，格式化失败、意外关机、停电…等原因所造成的。</code></p><p><code>如果一块磁盘在Windows中显示为RAW格式硬盘，可能（但非全部）的症状是：</code></p><p><code>无效的磁盘媒体格式。中止，重试，失败？ </code></p><p><code>文档系统显示为「RAW」— RAW文档系统 </code></p><p><code>Windows可能会提示是否要格式化磁盘，比如「硬盘未格式化，是否要立即格式化？」 </code></p><p><code>文件名称包含奇怪的字符。 </code></p><p><code>「找不到磁区」讯息</code></p><p>所以需要把U盘格式化为NTFS，方法：</p><p><strong>使用chkdsk命令</strong></p><p>我这里用这个命令就搞好了，</p><p>打开win+R-&gt;cmd，输入chkdsk G:(损坏U盘)/f /r /x</p><p>是否将丢失的链转换为文件(Y/N)? N</p><p>如果这个命令不好使，显示<code>文件系统的类型是RAW，CHKDSK无法供RAW驱动器使用</code>，那就参考一下文章——<a href="https://zhuanlan.zhihu.com/p/393142509">文件系统的类型是RAW，CHKDSK无法供RAW驱动器使用 - 知乎 (zhihu.com)</a> 叭</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好久没有用的u盘，今天插了试了一下，发现U盘无法被读取，于是开始排查原因；&lt;/p&gt;
&lt;p&gt;首先检查驱动，计算机-&amp;gt;管理-&amp;gt;设备管理器查看驱动，驱动没有问题；&lt;/p&gt;
&lt;p&gt;检查磁盘分区，win+R，输入diskmgmt.msc，找到出错的u盘，发现文件系统为RA</summary>
      
    
    
    
    <category term="平台-Windows" scheme="https://115jiege.github.io/categories/%E5%B9%B3%E5%8F%B0-Windows/"/>
    
    
    <category term="Windows" scheme="https://115jiege.github.io/tags/Windows/"/>
    
    <category term="U盘" scheme="https://115jiege.github.io/tags/U%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>(Linux平台)qtcreator的安装与常见问题</title>
    <link href="https://115jiege.github.io/2023/05/04/%E5%B9%B3%E5%8F%B0-Linux/(Linux)qtcreator%E5%AE%89%E8%A3%85%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://115jiege.github.io/2023/05/04/%E5%B9%B3%E5%8F%B0-Linux/(Linux)qtcreator%E5%AE%89%E8%A3%85%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2023-05-04T08:33:56.000Z</published>
    <updated>2023-05-05T00:43:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="qtcreator安装"><a class="header-anchor" href="#qtcreator安装">¶</a>qtcreator安装</h2><p>环境：ubuntu2004</p><p>准备：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure><h3 id="apt-get安装"><a class="header-anchor" href="#apt-get安装">¶</a>apt-get安装</h3><p><a href="https://blog.csdn.net/weixin_48560325/article/details/124373125">参考文章</a></p><p>apt安装会直接安装固定版本的qtcreator</p><h3 id="在线安装"><a class="header-anchor" href="#在线安装">¶</a>在线安装</h3><ol><li><p>下载在线安装器<br><a href="https://www.qt.io/download-qt-installer">Download Qt: Get Qt Online Installer</a></p></li><li><p>双击在线安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> a+x qt-unified-linux-x64-4.5.2-online.run</span><br><span class="line">./qt-unified-linux-x64-4.5.2-online.run</span><br></pre></td></tr></table></figure><p>没有账户的话需要注册</p><p>安装目录(/opt/Qt)</p></li><li><p>创建快捷方式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /opt/Qt/Tools/QtCreator/bin/qtcreator /usr/bin/qtcreator</span><br></pre></td></tr></table></figure></li><li><p>创建桌面文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /opt/Qt/Tools/QtCreator/share/applications/org.qt-project.qtcreator.desktop /usr/share/applications/org.qt-project.qtcreator.desktop</span><br></pre></td></tr></table></figure></li><li><p>配置构建套件</p><p>配置Qt版本</p><p>自动检测-&gt;qmake在/opt/Qt/5.15.2/gcc_64/bin下</p><p>配置编译器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install gcc</span><br><span class="line">apt install g++</span><br></pre></td></tr></table></figure></li><li><p>修改qmake默认编译器</p><p>到这一步qtcreator的使用基本没什么问题了，但是在命令行输入qmake -v，发现qmake报错</p><p><code>could not exec '/usr/lib/x86\_64-linux-gnu/qt4/bin/qmake': No such file or directory</code></p><p>需要修改qmake默认编译器:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/lib/x86_64-linux-gnu/qt-default/qtchooser/default.conf</span><br></pre></td></tr></table></figure><p>在第一行添加qmake位置<code>/opt/Qt/5.15.2/gcc_64/bin</code></p></li></ol><h3 id="国内源在线安装"><a class="header-anchor" href="#国内源在线安装">¶</a>国内源在线安装</h3><p>如果虚拟机在线安装qt十分缓慢（长达2-3小时），可以试试换国内源（约半小时-40分钟），或者挂个梯子。</p><p><a href="https://zhuanlan.zhihu.com/p/597695401#:~:text=Linux%E5%AE%89%E8%A3%85Qt6%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%EF%BC%88%E4%BB%A5Ubuntu22.04%E4%B8%BA%E4%BE%8B%EF%BC%89%201%201.%20%E4%B8%8B%E8%BD%BD%E6%B8%85%E5%8D%8E%E6%8F%90%E4%BE%9B%E7%9A%84%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85%E5%99%A8%20%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85%E5%99%A8%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5%202%202.%20%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E5%9C%B0%E5%9D%80%E8%BF%90%E8%A1%8C%E5%AE%89%E8%A3%85%E5%99%A8,CMake%20configuration%20found%21%20sudo%20apt%20install%20libgl-dev%20">参考文章</a></p><ol><li><p>下载清华在线安装器<br><a href="https://link.zhihu.com/?target=https%3A//mirrors.tuna.tsinghua.edu.cn/qt/official_releases/online_installers/qt-unified-linux-x64-online.run">Download Qt: Get Tuna Qt Online Installer</a></p></li><li><p>配置镜像地址运行在线安装器</p><ul><li>清华源</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./qt-unified-linux-x64-online.run --mirror https://mirrors.tuna.tsinghua.edu.cn/qt</span><br></pre></td></tr></table></figure><ul><li>南大源</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./qt-unified-linux-x64-online.run --mirror http://mirrors.nju.edu.cn/qt/</span><br></pre></td></tr></table></figure></li><li><p>继续上面的步骤安装qt</p></li></ol><h2 id="qt开发中出现的错误"><a class="header-anchor" href="#qt开发中出现的错误">¶</a>qt开发中出现的错误</h2><h3 id="qt安装错报错："><a class="header-anchor" href="#qt安装错报错：">¶</a>qt安装错报错：</h3><p><code>./qt-unified-linux-x64-4.5.2-online.run: error while loading shared libraries: libxcb-xinerama.so.0: cannot open shared object file: No such file or directory</code></p><p>解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install --reinstall libxcb-xinerama0</span><br></pre></td></tr></table></figure><h3 id="配置文件报错"><a class="header-anchor" href="#配置文件报错">¶</a>配置文件报错</h3><p><code>No CMake configuration found!</code></p><p>解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libgl-dev</span><br></pre></td></tr></table></figure><h3 id="pro文件报错：GL"><a class="header-anchor" href="#pro文件报错：GL">¶</a>pro文件报错：GL</h3><p><code>/opt/Qt/5.15.2/gcc_64/include/QtGui/qopengl.h:141:13: fatal error: GL/gl.h: No such file or directory 141 | # include &lt;GL/gl.h&gt; | ^~~~~~~~~</code></p><p>解决：</p><p>安装缺少的插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mesa-common-dev`</span><br></pre></td></tr></table></figure><h3 id="使用WebEngine编译报错：libQt5WebEngineCore-so"><a class="header-anchor" href="#使用WebEngine编译报错：libQt5WebEngineCore-so">¶</a>使用WebEngine编译报错：<a href="http://libQt5WebEngineCore.so">libQt5WebEngineCore.so</a></h3><p><code>libQt5WebEngineCore.so: .dynsym local symbol at index 3 (&gt;= sh_info of 3)</code></p><p>解决：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -sf <span class="regexp">/usr/</span>bin<span class="regexp">/x86_64-linux-gnu-ld.gold /u</span>sr<span class="regexp">/bin/</span>ld</span><br></pre></td></tr></table></figure><h3 id="Qt运行出现-Ignoring-XDG-SESSION-TYPE-wayland-on-Gnome-Use-QT-QPA-PLATFORM-wayland-to-run…解决"><a class="header-anchor" href="#Qt运行出现-Ignoring-XDG-SESSION-TYPE-wayland-on-Gnome-Use-QT-QPA-PLATFORM-wayland-to-run…解决">¶</a>Qt运行出现 Ignoring XDG_SESSION_TYPE=wayland on Gnome. Use QT_QPA_PLATFORM=wayland to run…解决</h3><p>解决：</p><p>vim /etc/gdm3/custom.conf</p><p>WaylandEnable=false</p><p>reboot</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;qtcreator安装&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#qtcreator安装&quot;&gt;¶&lt;/a&gt;qtcreator安装&lt;/h2&gt;
&lt;p&gt;环境：ubuntu2004&lt;/p&gt;
&lt;p&gt;准备：&lt;/p&gt;
&lt;figure class=&quot;highl</summary>
      
    
    
    
    <category term="平台-Linux" scheme="https://115jiege.github.io/categories/%E5%B9%B3%E5%8F%B0-Linux/"/>
    
    
    <category term="Linux" scheme="https://115jiege.github.io/tags/Linux/"/>
    
    <category term="qtcreator" scheme="https://115jiege.github.io/tags/qtcreator/"/>
    
    <category term="QtWebEngine" scheme="https://115jiege.github.io/tags/QtWebEngine/"/>
    
  </entry>
  
  <entry>
    <title>Vector</title>
    <link href="https://115jiege.github.io/2023/04/24/tips%E6%95%B4%E7%90%86/C++%20vector%20%E5%AD%A6%E4%B9%A0/"/>
    <id>https://115jiege.github.io/2023/04/24/tips%E6%95%B4%E7%90%86/C++%20vector%20%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-04-24T01:10:33.000Z</published>
    <updated>2023-05-04T03:20:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Vector（C++）</h1><p>Vector是一个封装了<strong>动态</strong>大小数组的<strong>顺序</strong>*容器，即一个可以存放任意类型的动态数组。</p><h2 id="容器特性"><a class="header-anchor" href="#容器特性">¶</a>容器特性</h2><h3 id="顺序存储"><a class="header-anchor" href="#顺序存储">¶</a>顺序存储</h3><p>顺序容器中的元素线性排列，通过元素在序列中的位置访问元素。</p><h3 id="动态数组"><a class="header-anchor" href="#动态数组">¶</a>动态数组</h3><p>支持对序列中的元素进行快速访问，在序列末尾快速增删元素。</p><h3 id="感知内存分配器的Alloctor-aware"><a class="header-anchor" href="#感知内存分配器的Alloctor-aware">¶</a>感知内存分配器的Alloctor-aware</h3><p><strong>内存分配器（Memory Alloctor）</strong></p><p>通常使用的内存分配器,即malloc/free函数并非系统提供的，而是C标准库提供的。也被称为动态内存分配器。</p><p><em><code>目的</code></em>：平衡内存分配的性能和提高内存使用的效率。</p><p><em><code>内存不足的原因</code></em>：程序内的bug；系统内存不足；内存分配浪费大量空间，导致大量内存碎片。</p><p><strong>Alloctor Aware Container</strong></p><p>所有的STL容器，都保存一个或默认，或由用户提供的allocator的实例，用来提供对象内存分配和构造的方法（除了std::array），这样的容器，被称作Allocator Aware Container。</p><p>Allocator Aware Container的拷贝：</p><p>调用被拷贝对象的std::allocator_traits<TAllocator>::select_on_container_copy_construction()函数，按情况拷贝，如果没有，就直接返回容器本体。</TAllocator></p><p>拷贝对象调用静态的propagate_on_container_copy_assignment，获取被拷贝容器的allocator副本，避免出现直接拷贝容器的bug。</p><p>每一个std::allocator_traits<Tallocator>都拥有三个别名类型：propagate_on_container_copy_assignment， propagate_on_container_move_assignment 和 propagate_on_container_swap，他们都是true_type或false_type的别名，这三个属性除非用户自定义，否则默认是false_type，也即allocator在容器拷贝、移动或交换的时候不能直接进行allocator所分配的内存的所有权的转移<br>对于拷贝赋值（copy assignment），需要运行时判断容器的propagate_on_copy_assignement trait，如果为true，并且两个容器不相等，那么lhs的容器应该先析构所有内存，再拷贝allocator，最后执行对象的拷贝。</Tallocator></p><p>容器在移动赋值（move assignment）的时候需要考虑如下情况，来正确操作容器的allocator:</p><ul><li>propagate_on_container_move_assignemnt 为 true_type<br>lhs拷贝容器使用alloctor释放分配内存，rhs被拷贝者alloctor所有权转移，内存的所有权从rhs转移到lhs。</li><li>propagate_on_container_move_assignemnt 为 false_type，但两个allocator相等<br>lhs拷贝容器使用alloctor释放分配内存，不交换所有权。</li><li>propagete_on_container_move_assignment 为 false_type，两个allocator<br>不等无法执行内存级别的移动，只能进行对象级别的移动。</li></ul><h2 id="函数实现"><a class="header-anchor" href="#函数实现">¶</a>函数实现</h2><h3 id="构造函数"><a class="header-anchor" href="#构造函数">¶</a>构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>() <span class="comment">//创建一个空vector</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">int</span> nSize) <span class="comment">//创建一个vector,元素个数为nSize</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">int</span> nSize,<span class="type">const</span> t&amp; t) <span class="comment">//创建一个vector，元素个数为nSize,且值均为t</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&amp;) <span class="comment">//复制构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(begin,end) <span class="comment">//复制[begin,end)区间内另一个数组的元素到vector中</span></span><br></pre></td></tr></table></figure><h3 id="增加函数"><a class="header-anchor" href="#增加函数">¶</a>增加函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="comment">//向量尾部增加一个元素X</span></span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it,<span class="type">const</span> T&amp; x)</span> <span class="comment">//向量中迭代器指向元素前增加一个元素x</span></span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it,<span class="type">int</span> n,<span class="type">const</span> T&amp; x)</span> <span class="comment">//向量中迭代器指向元素前增加n个相同的元素x</span></span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it,const_iterator first,const_iterator last)</span> <span class="comment">//向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</span></span></span><br></pre></td></tr></table></figure><h3 id="删除函数"><a class="header-anchor" href="#删除函数">¶</a>删除函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span> <span class="comment">//删除向量中迭代器指向元素</span></span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first,iterator last)</span> <span class="comment">//删除向量中[first,last)中元素</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> <span class="comment">//删除向量中最后一个元素</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> <span class="comment">//清空向量中所有元素</span></span></span><br></pre></td></tr></table></figure><h3 id="遍历函数"><a class="header-anchor" href="#遍历函数">¶</a>遍历函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">reference <span class="title">at</span><span class="params">(<span class="type">int</span> pos)</span> <span class="comment">//返回pos位置元素的引用</span></span></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> <span class="comment">//返回首元素的引用</span></span></span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> <span class="comment">//返回尾元素的引用</span></span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="comment">//返回向量头指针，指向第一个元素</span></span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="comment">//返回向量尾指针，指向向量最后一个元素的下一个位置</span></span></span><br><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="comment">//反向迭代器，指向最后一个元素</span></span></span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="comment">//反向迭代器，指向第一个元素之前的位置</span></span></span><br></pre></td></tr></table></figure><h3 id="判空"><a class="header-anchor" href="#判空">¶</a>判空</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//判断向量是否为空，若为空，则向量中无元素</span></span></span><br></pre></td></tr></table></figure><h3 id="大小函数"><a class="header-anchor" href="#大小函数">¶</a>大小函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//返回向量中元素的个数</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//返回当前向量所能容纳的最大元素值</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> max\_<span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//返回最大可允许的vector元素数量值</span></span></span><br></pre></td></tr></table></figure><h3 id="7-其他函数"><a class="header-anchor" href="#7-其他函数">¶</a>7.其他函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&amp;)</span> <span class="comment">//交换两个同类型向量的数据</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">int</span> n,<span class="type">const</span> T&amp; x)</span> <span class="comment">//设置向量中前n个元素的值为x</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">const</span>\_iterator first,<span class="type">const</span>\_iterator last)</span> <span class="comment">//向量中[first,last)中元素设置成当前向量元素</span></span></span><br></pre></td></tr></table></figure><h2 id="使用"><a class="header-anchor" href="#使用">¶</a>使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt; vector&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><ol><li>Vector&lt;类型&gt;标识符</li><li>Vector&lt;类型&gt;标识符(最大容量)</li><li>Vector&lt;类型&gt;标识符(最大容量,初始所有值)</li><li>Int i[5]={1,2,3,4,5}<br>Vector&lt;类型&gt;vi(I,i+2);//得到i索引值为3以后的值</li><li>Vector&lt; vector&lt; int&gt; &gt;v;</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Vector（C++）&lt;/h1&gt;
&lt;p&gt;Vector是一个封装了&lt;strong&gt;动态&lt;/strong&gt;大小数组的&lt;strong&gt;顺序&lt;/strong&gt;*容器，即一个可以存放任意类型的动态数组。&lt;/p&gt;
&lt;h2 id=&quot;容器特性&quot;&gt;&lt;a class=&quot;header-anch</summary>
      
    
    
    
    <category term="tips整理" scheme="https://115jiege.github.io/categories/tips%E6%95%B4%E7%90%86/"/>
    
    
    <category term="c++" scheme="https://115jiege.github.io/tags/c/"/>
    
    <category term="Vector" scheme="https://115jiege.github.io/tags/Vector/"/>
    
  </entry>
  
  <entry>
    <title>VMware错误</title>
    <link href="https://115jiege.github.io/2023/04/23/tips%E6%95%B4%E7%90%86/VMware%E9%94%99%E8%AF%AF/"/>
    <id>https://115jiege.github.io/2023/04/23/tips%E6%95%B4%E7%90%86/VMware%E9%94%99%E8%AF%AF/</id>
    <published>2023-04-23T05:56:14.000Z</published>
    <updated>2023-05-05T00:45:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下在使用VMware workstation的过程中出现的问题。</p><h2 id="虚拟机正在使用"><a class="header-anchor" href="#虚拟机正在使用">¶</a>虚拟机正在使用</h2><p>VMware虚拟机由于一些原因卡死，用Windows任务管理器关闭VMware也关不掉，然后重启电脑，再次打开虚拟机报错。</p><p>错误信息：</p><p><code>该虚拟机似乎正在使用中。如果该虚拟机未在使用，请按“获取所有权(T)”按钮获取它的所有权。否则，请按“取消(C)”按钮以防损坏。</code></p><p>解决方法：</p><p>打开虚拟机所在文件夹，删除.lck结尾的文件夹(不放心的话可以转为备份文件)；重启VMware，即可打开虚拟机;</p><p>分析原因：</p><p>当运行一个“虚拟系统”时，为防止该系统被另外一个VMware程序打开，导致数据被修改或损坏，VMware会自动在该“虚拟系统”所在的文件夹下，生成三个锁定文件（虚拟系统锁定，虚拟磁盘锁定，虚拟内存锁定），分别为：”.vmx.lck”,”.vmdk.lck”,”.vmem.lck”；</p><p>在正常关机的情况下，这些文件会自动删除，当非正常关机的情况下，这些文件就不会自动删除，这就导致了再次打开Ubuntu的时候由于锁的存在而打不开。</p><h2 id="未能连接到虚拟机"><a class="header-anchor" href="#未能连接到虚拟机">¶</a>未能连接到虚拟机</h2><p>强制关闭虚拟机，再次打开时报错。</p><p>错误信息：</p><p><code>未能将管道连接到虚拟机: 所有的管道范例都在使用中。</code></p><p>解决方法：</p><p>打开任务管理器-&gt;详细信息：结束所有vm开头的任务(vmnet不用关);</p><p>分析原因：</p><p>有些相关进程没有关掉，导致管道未释放。</p><h2 id="网络连接失败"><a class="header-anchor" href="#网络连接失败">¶</a>网络连接失败</h2><p>在任务管理器中不小心关掉了vmnat.ext,vmnetdhcp.exe等VMware虚拟网络进程，导致虚拟机网络连接失败。</p><p>解决方法：</p><p>关闭虚拟机，编辑-&gt;虚拟网络编辑器-&gt;还原默认设置;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一下在使用VMware workstation的过程中出现的问题。&lt;/p&gt;
&lt;h2 id=&quot;虚拟机正在使用&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#虚拟机正在使用&quot;&gt;¶&lt;/a&gt;虚拟机正在使用&lt;/h2&gt;
&lt;p&gt;VMware虚拟机由于一些原因卡死，</summary>
      
    
    
    
    <category term="tips整理" scheme="https://115jiege.github.io/categories/tips%E6%95%B4%E7%90%86/"/>
    
    
    <category term="VMware" scheme="https://115jiege.github.io/tags/VMware/"/>
    
  </entry>
  
  <entry>
    <title>VScode通过SSH远程连接主机失败</title>
    <link href="https://115jiege.github.io/2023/04/23/tips%E6%95%B4%E7%90%86/VScode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5/"/>
    <id>https://115jiege.github.io/2023/04/23/tips%E6%95%B4%E7%90%86/VScode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5/</id>
    <published>2023-04-23T05:56:14.000Z</published>
    <updated>2023-05-05T00:45:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>报错信息：</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-16-14-14-42-image.png" alt></p><p>原因：</p><p>我这里是之前安装过一个ubuntu2204，VMware分配了ip，并且使用ssh连接过这个ip。删除虚拟机后，再次安装的ubuntu又恰好被分配了此ip，但用户名或密码与之前不同。这使得本地记录的信息和现有本地记录的服务器信息和现有的产生了冲突，连接失败。</p><p>解决：</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-16-14-19-26-image.png" alt></p><p>把有冲突的本地记录删掉就好了，找到C:\Users\Administrator\ssh\known_hosts文件，删除冲突ip的信息。然后重新连接。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;报错信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-16-14-14-42-image.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;原</summary>
      
    
    
    
    <category term="tips整理" scheme="https://115jiege.github.io/categories/tips%E6%95%B4%E7%90%86/"/>
    
    
    <category term="Vs Code" scheme="https://115jiege.github.io/tags/Vs-Code/"/>
    
  </entry>
  
  <entry>
    <title>java中发送UDP数据包</title>
    <link href="https://115jiege.github.io/2023/04/23/%E5%B9%B3%E5%8F%B0-android/%E5%8F%91%E9%80%81UDP%E6%95%B0%E6%8D%AE%E5%8C%85(java)/"/>
    <id>https://115jiege.github.io/2023/04/23/%E5%B9%B3%E5%8F%B0-android/%E5%8F%91%E9%80%81UDP%E6%95%B0%E6%8D%AE%E5%8C%85(java)/</id>
    <published>2023-04-23T02:20:40.000Z</published>
    <updated>2023-04-23T02:23:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UDP发送数据"><a class="header-anchor" href="#UDP发送数据">¶</a>UDP发送数据</h2><h3 id="步骤"><a class="header-anchor" href="#步骤">¶</a>步骤</h3><ol><li>创建发送端socket对象</li><li>创建数据并打包</li><li>调用socket发送方法发送数据包</li><li>释放资源</li></ol><h3 id="方法"><a class="header-anchor" href="#方法">¶</a>方法</h3><p><strong>类 DatagramSocket</strong></p><p>此类表示用来<strong>发送和接收数据报包</strong>的套接字</p><p><strong>类 DatagramPacket</strong></p><p>此类表示数据报包</p><p>public void <strong>send</strong>(DatagramPacket p)：</p><p>从套接字发送数据报包。DatagramPacket 包含的信息指示：将要发送的数据、其长度、远程主机的 IP 地址和远程主机的端口号。</p><p>public <strong>DatagramPacket</strong>(byte[] buf,int length,InetAddress address,int port)</p><p>构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。</p><h3 id="步骤-v2"><a class="header-anchor" href="#步骤-v2">¶</a>步骤</h3><ol><li>创建socket对象</li><li>创建数据包（接受容器）</li><li>调用socket接受方法接受数据包</li><li>解析数据</li><li>释放资源</li></ol><h3 id="方法-v2"><a class="header-anchor" href="#方法-v2">¶</a>方法</h3><p>public <strong>DatagramSocket</strong>(int port)</p><p>创建数据报套接字并绑定到指定端口</p><p><strong>DatagramPacket</strong>(byte[] buf, int length)</p><p>构造长度为length的数据包</p><p>public void <strong>receive</strong>(DatagramPacket p)</p><p>从套接字接受数据包</p><p>public InetAddress <strong>getAddress</strong>()</p><p>返回某台机器的 IP地址，此数据报将要发往该机器或者是从该机器接收到的。</p><p>public byte[] <strong>getData</strong>()</p><p>返回数据缓冲区。</p><p>public int <strong>getLength()</strong></p><p>返回将要发送或接收到的数据的长度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;UDP发送数据&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#UDP发送数据&quot;&gt;¶&lt;/a&gt;UDP发送数据&lt;/h2&gt;
&lt;h3 id=&quot;步骤&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#步骤&quot;&gt;¶&lt;/a&gt;步骤&lt;/h3&gt;
&lt;ol</summary>
      
    
    
    
    <category term="平台-android" scheme="https://115jiege.github.io/categories/%E5%B9%B3%E5%8F%B0-android/"/>
    
    
    <category term="android" scheme="https://115jiege.github.io/tags/android/"/>
    
    <category term="java" scheme="https://115jiege.github.io/tags/java/"/>
    
    <category term="UDP" scheme="https://115jiege.github.io/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>gmssl各平台编译</title>
    <link href="https://115jiege.github.io/2023/04/21/%E5%9B%BD%E5%AF%86/gmssl%E5%90%84%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"/>
    <id>https://115jiege.github.io/2023/04/21/%E5%9B%BD%E5%AF%86/gmssl%E5%90%84%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/</id>
    <published>2023-04-21T09:28:54.000Z</published>
    <updated>2023-04-23T02:13:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1>gmssl各平台编译</h1><p>官址<a href>click here</a></p><p>我的项目<a href="https://github.com/115Jiege/Gmssl.git">click here</a></p><h2 id="linux版编译"><a class="header-anchor" href="#linux版编译">¶</a>linux版编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./config --prefix=/usr/local --openssldir=/usr/local</span><br><span class="line">sudo make &amp;&amp; make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><h2 id="Windows版编译"><a class="header-anchor" href="#Windows版编译">¶</a>Windows版编译</h2><p>使用</p><p>下载perl工具</p><p>[click here](<a href="https://strawberryperl.com/">Strawberry Perl for Windows</a>)</p><p>以管理员身份打开<code>x86 Native Tools Command Prompt for VS 2019</code> cd gmssl目录 运行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">perl Configure VC-WIN32</span><br><span class="line">nmake </span><br><span class="line">nmake install</span><br></pre></td></tr></table></figure><h2 id="安卓版编译"><a class="header-anchor" href="#安卓版编译">¶</a>安卓版编译</h2><h3 id="编译环境"><a class="header-anchor" href="#编译环境">¶</a>编译环境</h3><p>os: mint 20.1</p><p>(5.4.0-58-generic #64-Ubuntu SMP Wed Dec 9 08:16:25 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux)</p><p>NDK: android-r14b</p><p>Android-abi: android-21</p><h3 id="初步准备"><a class="header-anchor" href="#初步准备">¶</a>初步准备</h3><h4 id="NDK"><a class="header-anchor" href="#NDK">¶</a>NDK</h4><p>选用android-ndk-r14b，可以在<a href="https://www.androiddevtools.cn/">此处</a>下载合适版本;</p><h4 id="环境变量"><a class="header-anchor" href="#环境变量">¶</a>环境变量</h4><p>将android-ndk-r14b所在位置添加到系统环境变量中;</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vim <span class="regexp">/etc/</span>profile</span><br><span class="line"><span class="comment">#编辑文件</span></span><br><span class="line">export ANROID_NDK_PATH=<span class="regexp">/usr/</span>local/android-ndk-r14b</span><br><span class="line"><span class="comment">#:wq保存</span></span><br><span class="line">source <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure><h3 id="编译合适版本"><a class="header-anchor" href="#编译合适版本">¶</a>编译合适版本</h3><p>编写sh文件，在linux系统上使用ndk进行交叉编译</p><h4 id="x86"><a class="header-anchor" href="#x86">¶</a>x86</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">ANDROID_PATH</span>=<span class="variable">$ANDROID_NDK_PATH</span></span><br><span class="line"><span class="attribute">PLATFORM_VERSION</span>=21</span><br><span class="line"></span><br><span class="line"><span class="attribute">MAKE_TOOLCHAIN</span>=<span class="variable">$ANDROID_PATH</span>/build/tools/make-standalone-toolchain.sh</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOLCHAIN_PATH</span>=<span class="variable">$ANDROID_PATH</span>/x86</span><br><span class="line"><span class="variable">$MAKE_TOOLCHAIN</span> <span class="attribute">--arch</span>=x86 <span class="attribute">--platform</span>=android-$PLATFORM_VERSION <span class="attribute">--install-dir</span>=<span class="variable">$TOOLCHAIN_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">CROSS_SYSROOT</span>=<span class="variable">$TOOLCHAIN_PATH</span>/sysroot</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOL_BASENAME</span>=<span class="variable">$TOOLCHAIN_PATH</span>/bin</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$CROSS_SYSROOT</span>:$PATH</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$TOOL_BASENAME</span>:$PATH</span><br><span class="line"></span><br><span class="line">./Configure <span class="attribute">--prefix</span>=/usr/local <span class="attribute">--cross-compile-prefix</span>=i686-linux-android- no-asm no-async shared android-x86</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h4 id="x86-64"><a class="header-anchor" href="#x86-64">¶</a>x86_64</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">ANDROID_PATH</span>=<span class="variable">$ANDROID_NDK_PATH</span></span><br><span class="line"><span class="attribute">PLATFORM_VERSION</span>=21</span><br><span class="line"></span><br><span class="line"><span class="attribute">MAKE_TOOLCHAIN</span>=<span class="variable">$ANDROID_PATH</span>/build/tools/make-standalone-toolchain.sh</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOLCHAIN_PATH</span>=<span class="variable">$ANDROID_PATH</span>/x86_64</span><br><span class="line"><span class="variable">$MAKE_TOOLCHAIN</span> <span class="attribute">--arch</span>=x86_64 <span class="attribute">--platform</span>=android-$PLATFORM_VERSION <span class="attribute">--install-dir</span>=<span class="variable">$TOOLCHAIN_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">CROSS_SYSROOT</span>=<span class="variable">$TOOLCHAIN_PATH</span>/sysroot</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOL_BASENAME</span>=<span class="variable">$TOOLCHAIN_PATH</span>/bin</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$CROSS_SYSROOT</span>:$PATH</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$TOOL_BASENAME</span>:$PATH</span><br><span class="line"></span><br><span class="line">./Configure <span class="attribute">--prefix</span>=/usr/local <span class="attribute">--cross-compile-prefix</span>=x86_64-linux-android- no-asm no-async shared android64</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h4 id="arm64-v8a"><a class="header-anchor" href="#arm64-v8a">¶</a>arm64-v8a</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">ANDROID_PATH</span>=<span class="variable">$ANDROID_NDK_PATH</span></span><br><span class="line"><span class="attribute">PLATFORM_VERSION</span>=21</span><br><span class="line"></span><br><span class="line"><span class="attribute">MAKE_TOOLCHAIN</span>=<span class="variable">$ANDROID_PATH</span>/build/tools/make-standalone-toolchain.sh</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOLCHAIN_PATH</span>=<span class="variable">$ANDROID_PATH</span>/aarch64-linux-android</span><br><span class="line"><span class="variable">$MAKE_TOOLCHAIN</span> <span class="attribute">--arch</span>=arm64 <span class="attribute">--platform</span>=android-$PLATFORM_VERSION <span class="attribute">--install-dir</span>=<span class="variable">$TOOLCHAIN_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">CROSS_SYSROOT</span>=<span class="variable">$TOOLCHAIN_PATH</span>/sysroot</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOL_BASENAME</span>=<span class="variable">$TOOLCHAIN_PATH</span>/bin</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$CROSS_SYSROOT</span>:$PATH</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$TOOL_BASENAME</span>:$PATH</span><br><span class="line"></span><br><span class="line">./Configure <span class="attribute">--prefix</span>=/usr/local <span class="attribute">--cross-compile-prefix</span>=aarch64-linux-android- no-asm no-async shared android64-aarch64</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h4 id="arm-v7a"><a class="header-anchor" href="#arm-v7a">¶</a>arm-v7a</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">ANDROID_PATH</span>=<span class="variable">$ANDROID_NDK_PATH</span></span><br><span class="line"><span class="attribute">PLATFORM_VERSION</span>=21</span><br><span class="line"></span><br><span class="line"><span class="attribute">MAKE_TOOLCHAIN</span>=<span class="variable">$ANDROID_PATH</span>/build/tools/make-standalone-toolchain.sh</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOLCHAIN_PATH</span>=<span class="variable">$ANDROID_PATH</span>/arm-linux-android</span><br><span class="line"><span class="variable">$MAKE_TOOLCHAIN</span> <span class="attribute">--arch</span>=arm <span class="attribute">--platform</span>=android-$PLATFORM_VERSION <span class="attribute">--install-dir</span>=<span class="variable">$TOOLCHAIN_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">CROSS_SYSROOT</span>=<span class="variable">$TOOLCHAIN_PATH</span>/sysroot</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOL_BASENAME</span>=<span class="variable">$TOOLCHAIN_PATH</span>/bin</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$CROSS_SYSROOT</span>:$PATH</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$TOOL_BASENAME</span>:$PATH</span><br><span class="line"></span><br><span class="line">./Configure <span class="attribute">--prefix</span>=/usr/local <span class="attribute">--cross-compile-prefix</span>=arm-linux-androideabi- no-asm no-async shared android-armeabi</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="查看so库信息"><a class="header-anchor" href="#查看so库信息">¶</a>查看so库信息</h3><p>编译后通过</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">readelf</span> -h libcrypto.so.<span class="number">1</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure><p>查看系统架构等信息</p><p>例如：</p><p>Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00<br>类别:                              ELF64<br>数据:                              2 补码，小端序 (little endian)<br>Version:                           1 (current)<br>OS/ABI:                            UNIX - System V<br>ABI 版本:                          0<br>类型:                              DYN (共享目标文件)<br>系统架构:                          AArch64<br>版本:                              0x1<br>入口点地址：               0x78240<br>程序头起点：          64 (bytes into file)<br>Start of section headers:          2968008 (bytes into file)<br>标志：             0x0<br>Size of this header:               64 (bytes)<br>Size of program headers:           56 (bytes)<br>Number of program headers:         6<br>Size of section headers:           64 (bytes)<br>Number of section headers:         32<br>Section header string table index: 29</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;gmssl各平台编译&lt;/h1&gt;
&lt;p&gt;官址&lt;a href&gt;click here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的项目&lt;a href=&quot;https://github.com/115Jiege/Gmssl.git&quot;&gt;click here&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;linux版</summary>
      
    
    
    
    <category term="国密" scheme="https://115jiege.github.io/categories/%E5%9B%BD%E5%AF%86/"/>
    
    
    <category term="gmssl" scheme="https://115jiege.github.io/tags/gmssl/"/>
    
  </entry>
  
  <entry>
    <title>sodium各平台编译</title>
    <link href="https://115jiege.github.io/2023/04/21/tips%E6%95%B4%E7%90%86/libsodium.so%E5%90%84%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"/>
    <id>https://115jiege.github.io/2023/04/21/tips%E6%95%B4%E7%90%86/libsodium.so%E5%90%84%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/</id>
    <published>2023-04-21T09:10:07.000Z</published>
    <updated>2023-04-23T02:13:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1>sodium各平台编译</h1><h2 id="linux版编译-v2"><a class="header-anchor" href="#linux版编译-v2">¶</a>linux版编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.libsodium.org/libsodium/releases/LATEST.tar.gz</span><br><span class="line">tar -zxvf LATEST.tar.gz</span><br><span class="line"><span class="built_in">cd</span> libsodium-stable</span><br><span class="line"> ./configure</span><br><span class="line">make &amp;&amp; make check</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><h2 id="安卓版编译-v2"><a class="header-anchor" href="#安卓版编译-v2">¶</a>安卓版编译</h2><h3 id="交叉编译环境"><a class="header-anchor" href="#交叉编译环境">¶</a>交叉编译环境:</h3><p>打开终端，apt安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt-get install build-enssitial</span><br><span class="line">apt-get install clang</span><br><span class="line">apt-get install libtool</span><br><span class="line">apt-get install autoconf</span><br><span class="line">apt-get install automake</span><br></pre></td></tr></table></figure><h3 id="设置环境变量"><a class="header-anchor" href="#设置环境变量">¶</a>设置环境变量</h3><p>sudo vim /etc/profile<br>添加:<br>export ANDROID_NDK_HOME=/home/Android/Sdk/ndk/23.1.7779620<br>export PATH=$PATH:$ANDROID_NDK_HOME</p><p>source  /etc/profile</p><p>](<a href="https://github.com/jedisct1/libsodium.git">https://github.com/jedisct1/libsodium.git</a>)</p><h3 id="生成configure文件"><a class="header-anchor" href="#生成configure文件">¶</a>生成configure文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> libsodium-stable</span><br><span class="line">./autogen.sh -s</span><br><span class="line"><span class="comment">#可以先用./autogen.sh -h查看使用说明;</span></span><br></pre></td></tr></table></figure><h3 id="选择合适的版本编译"><a class="header-anchor" href="#选择合适的版本编译">¶</a>选择合适的版本编译</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp ./dist-build/android-build<span class="selector-class">.sh</span> android-build<span class="selector-class">.sh</span></span><br><span class="line">cp ./dist-build/android-armv8-<span class="selector-tag">a</span><span class="selector-class">.sh</span> android-armv8-<span class="selector-tag">a</span><span class="selector-class">.sh</span></span><br><span class="line">chmod a+x android-build<span class="selector-class">.sh</span></span><br><span class="line">chmod a+x android-armv8-<span class="selector-tag">a</span><span class="selector-class">.sh</span></span><br><span class="line">./android-armv8-<span class="selector-tag">a</span>.sh</span><br></pre></td></tr></table></figure><p>如果编译过程中报错，需要clean，然后重新编译<br>make distclean</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;sodium各平台编译&lt;/h1&gt;
&lt;h2 id=&quot;linux版编译-v2&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#linux版编译-v2&quot;&gt;¶&lt;/a&gt;linux版编译&lt;/h2&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;ta</summary>
      
    
    
    
    <category term="tips整理" scheme="https://115jiege.github.io/categories/tips%E6%95%B4%E7%90%86/"/>
    
    
    <category term="sodium" scheme="https://115jiege.github.io/tags/sodium/"/>
    
  </entry>
  
  <entry>
    <title>关于线程与进程的Windows-api</title>
    <link href="https://115jiege.github.io/2023/04/18/%E5%B9%B3%E5%8F%B0-Windows/Windows%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://115jiege.github.io/2023/04/18/%E5%B9%B3%E5%8F%B0-Windows/Windows%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2023-04-18T06:34:21.000Z</published>
    <updated>2023-04-23T02:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些常用的Windows-api"><a class="header-anchor" href="#一些常用的Windows-api">¶</a>一些常用的Windows-api</h2><h3 id="WSAGetLastError"><a class="header-anchor" href="#WSAGetLastError">¶</a>WSAGetLastError</h3><h4 id="用途"><a class="header-anchor" href="#用途">¶</a>用途</h4><p>返回该线程进行的上一次 Windows Sockets API 函数调用时的错误代码</p><h4 id="函数原型"><a class="header-anchor" href="#函数原型">¶</a>函数原型</h4><p>int WSAGetLastError ( );</p><h4 id="注意"><a class="header-anchor" href="#注意">¶</a>注意</h4><ol><li>当特定 Windows 套接字函数指示发生错误时，应立即调用<strong>WSAGetLastError</strong>以检索扩展错误代码。</li><li>如果函数调用的返回值指示错误或其他相关数据是在错误代码中返回的，则应立即调用 <strong>WSAGetLastError</strong> ，否则，某些函数可能会将最后一个扩展错误代码重置为 0</li><li>使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winsock/nf-winsock-wsasetlasterror">WSASetLastError</a> 函数重置扩展错误代码，并将 <em>iError</em> 参数设置为零。 使用 <em>SO_ERROR optname</em> 参数调用的 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winsock/nf-winsock-getsockopt">getsockopt</a> 函数也会将扩展错误代码重置为零。</li><li>不应使用 <strong>WSAGetLastError</strong> 函数在收到异步消息时检查扩展错误值。 在这种情况下，扩展错误值在消息的 <em>lParam</em> 参数中传递，这可能与 <strong>WSAGetLastError</strong> 返回的值不同。</li><li><strong>WSAGetLastError</strong> 函数是 Winsock 2.2 DLL 中唯一可在 <strong>WSAStartup</strong> 失败时调用的函数之一。</li></ol><h4 id="要求"><a class="header-anchor" href="#要求">¶</a>要求</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>最低支持的客户端</td><td>windows8.1 Windows Vista</td></tr><tr><td>最低支持的服务端</td><td>Windows server 2003</td></tr><tr><td>标头</td><td>winsock.h</td></tr><tr><td>Library</td><td>Ws2_32.lib</td></tr><tr><td>DLL</td><td>Ws2_32.dll</td></tr></tbody></table><h3 id="beginthread、beginthreadex"><a class="header-anchor" href="#beginthread、beginthreadex">¶</a>beginthread、beginthreadex</h3><h4 id="用途-v2"><a class="header-anchor" href="#用途-v2">¶</a>用途</h4><p>用于创建线程</p><h4 id="语法"><a class="header-anchor" href="#语法">¶</a>语法</h4><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef void     (<span class="variable">__cdecl</span>*   <span class="variable">_beginthread_proc_type</span>  )(void*);</span><br><span class="line">typedef unsigned (<span class="variable">__stdcall</span>* <span class="variable">_beginthreadex_proc_type</span>)(void*);</span><br><span class="line"></span><br><span class="line"><span class="variable">_ACRTIMP</span> uintptr_t <span class="variable">__cdecl</span> <span class="variable">_beginthread</span>(</span><br><span class="line">    <span class="variable">_In_</span>     <span class="variable">_beginthread_proc_type</span> <span class="variable">_StartAddress</span>,</span><br><span class="line">    <span class="variable">_In_</span>     unsigned               <span class="variable">_StackSize</span>,</span><br><span class="line">    <span class="variable">_In_opt_</span> void*                  <span class="variable">_ArgList</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="variable">_ACRTIMP</span> uintptr_t <span class="variable">__cdecl</span> <span class="variable">_beginthreadex</span>(</span><br><span class="line">    <span class="variable">_In_opt_</span>  void*                    <span class="variable">_Security</span>,</span><br><span class="line">    <span class="variable">_In_</span>      unsigned                 <span class="variable">_StackSize</span>,</span><br><span class="line">    <span class="variable">_In_</span>      <span class="variable">_beginthreadex_proc_type</span> <span class="variable">_StartAddress</span>,</span><br><span class="line">    <span class="variable">_In_opt_</span>  void*                    <span class="variable">_ArgList</span>,</span><br><span class="line">    <span class="variable">_In_</span>      unsigned                 <span class="variable">_InitFlag</span>,</span><br><span class="line">    <span class="variable">_Out_opt_</span> unsigned*                <span class="variable">_ThrdAddr</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h4 id="参数"><a class="header-anchor" href="#参数">¶</a>参数</h4><p><em><code>Security</code></em></p><p>指向 <a href="https://learn.microsoft.com/zh-cn/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)"><code>SECURITY_ATTRIBUTES</code></a> 结构的指针，此结构确定返回的句柄是否由子进程继承。 <code>Security</code>为<code>NULL</code>表示默认安全性，无法继承句柄。</p><p><em><code>StackSize</code></em></p><p>新线程的堆栈大小，一般默认为0</p><p><em><code>StartAddress</code></em></p><p>启动开始执行新线程的例程的地址，对于 <strong><code>_beginthread</code></strong>，调用约定是 <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/cdecl?view=msvc-170"><code>__cdecl</code></a> （本机代码) ，或者是 <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/clrcall?view=msvc-170"><code>__clrcall</code></a> （托管代码) 。 对于 <strong><code>_beginthreadex</code></strong>，调用约定是 <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/stdcall?view=msvc-170"><code>__stdcall</code></a> （本机代码) ，或者是 <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/clrcall?view=msvc-170"><code>__clrcall</code></a> （托管代码) 。</p><p><em><code>ArgList</code></em></p><p>要传递到新线程的参数列表or <code>NULL</code></p><p><em><code>InitFlag</code></em></p><p>控制新线程的初始状态的标志。</p><p>设置为 0 则立即运行，</p><p>设置为 <code>CREATE_SUSPENDED</code>则创建后挂起,使用 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread"><code>ResumeThread</code></a> 来执行此线程。</p><p><em><code>ThrdAddr</code></em></p><p>存放线程标识符，它是CreateThread函数中的线程ID</p><h4 id="区别"><a class="header-anchor" href="#区别">¶</a>区别</h4><ol><li>参数形式不同</li><li><code>ex</code>能够创建悬挂状态线程，在nt中能够指定级别，能够被<code>thrdaddr</code>访问，因为它有了<code>id</code>。</li><li><code>ex</code>使用<code>__stdcall</code>调用格式，必须返回<code>exit code</code>。</li><li><code>ex</code>返回0代表失败，原先的返回-1L。</li><li><code>ex</code>创建的必须用ex销毁</li></ol><h3 id="endthread、endthreadex"><a class="header-anchor" href="#endthread、endthreadex">¶</a>endthread、endthreadex</h3><h4 id="用途-v3"><a class="header-anchor" href="#用途-v3">¶</a>用途</h4><p>用于结束线程终止线程；<strong><code>_endthread</code></strong> 终止由 <strong><code>_beginthread</code></strong> 创建的线程，<strong><code>_endthreadex</code></strong> 终止由 <strong><code>_beginthreadex</code></strong> 创建的线程。</p><p>语法</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*释放线程空间、释放线程TLS空间、调用ExiteThread结束线程。*/</span></span><br><span class="line"><span class="variable">_ACRTIMP</span> void <span class="variable">__cdecl</span> <span class="variable">_endthread</span>(void);</span><br><span class="line"></span><br><span class="line"><span class="comment">// retval:设定的线程结束码，与ExiteThread函数的参数功能一样，</span></span><br><span class="line"><span class="comment">//其实这个函数释放线程TLS空间，再调用ExiteThread函数，但没有释放线程空间。</span></span><br><span class="line"><span class="variable">_ACRTIMP</span> void <span class="variable">__cdecl</span> <span class="variable">_endthreadex</span>(</span><br><span class="line">    <span class="variable">_In_</span> unsigned <span class="variable">_ReturnCode</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h4 id="参数-v2"><a class="header-anchor" href="#参数-v2">¶</a>参数</h4><p><em><code>retval</code></em>  线程退出代码</p><h4 id="注意-v2"><a class="header-anchor" href="#注意-v2">¶</a>注意</h4><ol><li>当线程从作为 <strong><code>_endthread</code></strong> 或 <strong><code>_endthreadex</code></strong> 参数传递的例程中返回时，会自动调用 <strong><code>_beginthread</code></strong> 或 <strong><code>_beginthreadex</code></strong>。这有助于适当恢复为线程分配的资源。</li><li><strong><code>_endthread</code></strong> 会自动关闭线程句柄。</li><li><strong><code>_endthreadex</code></strong> 不会关闭线程句柄，所以使用 <strong><code>_beginthreadex</code></strong> 和 <strong><code>_endthreadex</code></strong> 时，必须通过调用 Win32 <code>CloseHandle</code> API 来关闭线程句柄。</li><li>对于与 Libcmt.lib 链接的可执行文件，请不要调用 Win32 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread"><code>ExitThread</code></a> API；这将阻止运行时系统回收已分配的资源。</li><li><strong><code>_endthread</code></strong> 和 <strong><code>_endthreadex</code></strong> 会导致 C++ 析构函数在不会调用的线程中处于挂起状态。</li></ol><h3 id="WaitForSingleObject"><a class="header-anchor" href="#WaitForSingleObject">¶</a>WaitForSingleObject</h3><h4 id="用途-v4"><a class="header-anchor" href="#用途-v4">¶</a>用途</h4><p>等待指定对象处于信号状态或超时间隔已过。</p><p><em>如果要等待多个对象则使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/synchapi/nf-synchapi-waitformultipleobjects">WaitForMultipleObjects</a></em></p><h4 id="语法-v2"><a class="header-anchor" href="#语法-v2">¶</a>语法</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD WaitForSingleObject(</span><br><span class="line"><span class="string">  [in]</span> HANDLE hHandle,</span><br><span class="line"><span class="string">  [in]</span> DWORD  dwMilliseconds</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="参数-v3"><a class="header-anchor" href="#参数-v3">¶</a>参数</h4><p><em><code>[in] hHandle</code></em></p><p>传递一个内核对象句柄，该句柄标识一个内核对象，句柄必须具有 <strong>SYNCHRONIZE</strong> 访问权限。</p><p>如果该内核对象处于未通知状态，则该函数导致线程进入<strong>阻塞状态</strong>；如果该内核对象处于已通知状态，则该函数立即返回WAIT_OBJECT_0</p><p><em><code>[in] dwMilliseconds</code></em></p><p>超时间隔（以毫秒为单位）。</p><p>如果指定了非零值，该函数将等待对象发出信号或间隔。</p><p>如果 <em>dwMilliseconds</em> 为零，则如果对象未发出信号，则函数不会输入等待状态;它始终会立即返回。</p><p>如果 <em>dwMilliseconds</em> 为 <strong>INFINITE</strong>，则仅当发出对象信号时，该函数才会返回。</p><h4 id="返回值"><a class="header-anchor" href="#返回值">¶</a>返回值</h4><table><thead><tr><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>WAIT_OBJECT_0<br>0x00000080L</td><td>等待的对象有信号（对线程来说，表示执行结束）</td></tr><tr><td>WAIT_TIMEOUT<br>0x00000000L</td><td>等待指定时间内，对象一直没有信号（线程没执行完)</td></tr><tr><td>WAIT_ABANDONED<br>0x00000102L</td><td>对象有信号，但还是不能执行 一般是因为未获取到锁或其他原因</td></tr><tr><td>WAIT_FAILED<br>(DWORD) 0xFFFFFFFF</td><td>函数失败。 要获得更多的错误信息，请调用 GetLastError。</td></tr></tbody></table><h3 id="TerminateThread"><a class="header-anchor" href="#TerminateThread">¶</a>TerminateThread</h3><h4 id="用途-v5"><a class="header-anchor" href="#用途-v5">¶</a>用途</h4><p>在线程外终止一个线程，用于强制终止线程。</p><h4 id="语法-v3"><a class="header-anchor" href="#语法-v3">¶</a>语法</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="constructor">TerminateThread( HANDLE <span class="params">hThread</span>, DWORD <span class="params">dwExitCode</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="参数-v4"><a class="header-anchor" href="#参数-v4">¶</a>参数</h4><p><em><code>hThread</code></em></p><p>被终止的线程的句柄</p><p><em><code>dwExitCode</code></em></p><p>退出码</p><h4 id="返回值-v2"><a class="header-anchor" href="#返回值-v2">¶</a>返回值</h4><p>函数执行成功则返回非零值，执行失败返回0。调用getlasterror获得返回的值</p><h4 id="要求-v2"><a class="header-anchor" href="#要求-v2">¶</a>要求</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>最低支持的客户端</td><td>Windows XP</td></tr><tr><td>最低支持的服务端</td><td>Windows server 2003</td></tr><tr><td>标头</td><td>processthreadsapi.h</td></tr><tr><td>Library</td><td>Kernel32.lib</td></tr><tr><td>DLL</td><td>Kernel32.dll</td></tr></tbody></table><h4 id="注意-v3"><a class="header-anchor" href="#注意-v3">¶</a>注意</h4><ol><li>如果目标线程拥有关键部分，则不会释放关键部分。</li><li>如果目标线程从堆分配内存，则不会释放堆锁。</li><li>如果目标线程在终止时正在执行某些 kernel32 调用，则线程进程的 kernel32 状态可能不一致。</li><li>如果目标线程正在操作共享 DLL 的全局状态，可能会销毁 DLL 的状态，从而影响 DLL 的其他用户。</li><li>如果目标线程是调用此函数时进程的最后一个线程，则线程的进程也会终止。线程对象的状态会发出信号，释放等待线程终止的任何其他线程。 线程的终止状态从 <strong>STILL_ACTIVE</strong> 更改为 <em>dwExitCode</em> 参数的值。</li><li>终止线程不一定从系统中删除线程对象。 关闭最后一个线程句柄时，将删除线程对象。</li></ol><h3 id="GetBestInterfaceEx"><a class="header-anchor" href="#GetBestInterfaceEx">¶</a>GetBestInterfaceEx</h3><h4 id="用途-v6"><a class="header-anchor" href="#用途-v6">¶</a>用途</h4><p>检索具有指向指定 IPv4 或 IPv6 地址的最佳路由的接口的索引</p><h4 id="语法-v4"><a class="header-anchor" href="#语法-v4">¶</a>语法</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="constructor">GetBestInterfaceEx(<span class="params">int</span> <span class="operator">*</span><span class="params">pIndex</span>, <span class="params">int</span> <span class="params">maxSize</span>, <span class="params">char</span> <span class="operator">*</span><span class="params">pGateway</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="参数-v5"><a class="header-anchor" href="#参数-v5">¶</a>参数</h4><p><em><code>[in] pIndex</code></em></p><p>要为其检索具有最佳路由的接口的目标 IPv6 或 IPv4 地址</p><p><em><code>[in] maxSize</code></em></p><p>地址最大长度</p><p><code>[out] pdwBestIfIndex</code></p><p><em>pIndex</em> 指定的 IPv6 或 IPv4 地址的最佳路由。</p><h3 id="WSASocketA"><a class="header-anchor" href="#WSASocketA">¶</a>WSASocketA</h3><h4 id="用途-v7"><a class="header-anchor" href="#用途-v7">¶</a>用途</h4><p>创建绑定到特定传输服务提供程序的套接字</p><h4 id="语法-v5"><a class="header-anchor" href="#语法-v5">¶</a>语法</h4><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SOCKET WSAAPI WSASocketA(</span><br><span class="line">    <span class="variable">_In_</span> int af,</span><br><span class="line">    <span class="variable">_In_</span> int <span class="built_in">type</span>,</span><br><span class="line">    <span class="variable">_In_</span> int protocol,</span><br><span class="line">    <span class="variable">_In_opt_</span> LPWSAPROTOCOL_INFOA lpProtocolInfo,</span><br><span class="line">    <span class="variable">_In_</span> <span class="built_in">GROUP</span> g,</span><br><span class="line">    <span class="variable">_In_</span> DWORD dwFlags</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p><em><code>[in] af</code></em></p><p>地址系列规范</p><table><thead><tr><th>af</th><th>含义</th></tr></thead><tbody><tr><td>AF_UNSPEC</td><td></td></tr><tr><td><br>0</td><td>未指定地址系列</td></tr><tr><td>AF_INET</td><td></td></tr><tr><td><br>2</td><td>指定IPV4地址系列</td></tr><tr><td>AF_IPX</td><td></td></tr><tr><td><br>6</td><td>指定IPX/SPX 地址系列</td></tr><tr><td>AF_APPLETALK</td><td></td></tr><tr><td><br>16</td><td>指定AppleTalk 地址系列</td></tr><tr><td>AF_NETBIOS</td><td></td></tr><tr><td><br>17</td><td>指定NetBIOS 地址系列<br>Windows 32位系统</td></tr><tr><td>AF_INET6</td><td></td></tr><tr><td><br>23</td><td>指定I9V6地址系列</td></tr><tr><td>AF_IRDA</td><td></td></tr><tr><td><br>26</td><td>指定红外数据关联 (IrDA) 地址系列</td></tr><tr><td>AF_BTH</td><td></td></tr><tr><td><br>32</td><td>指定蓝牙地址系列</td></tr></tbody></table><p><em><code>[in] type</code></em></p><p>新套接字的类型规范</p><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>SOCK_STREAM</td><td></td></tr><tr><td><br>1</td><td>对应TCP</td></tr><tr><td>SOCK_DGRAM</td><td></td></tr><tr><td><br>2</td><td>对应UDP</td></tr><tr><td>SOCK_RAW</td><td></td></tr><tr><td><br>3</td><td>提供原始套接字的套接字类型，允许应用程序操作下一层协议标头。 若要操作 IPv4 标头，必须在套接字上设置 IP_HDRINCL 套接字选项。 若要操作 IPv6 标头，必须在套接字上设置 IPV6_HDRINCL 套接字选项。</td></tr><tr><td>SOCK_RDM</td><td></td></tr><tr><td><br>4</td><td>对应多播</td></tr><tr><td>SOCK_SEQPACKET</td><td></td></tr><tr><td><br>5</td><td>提供基于数据报的伪流数据包的套接字类型。</td></tr></tbody></table><p><em><code>[in] protocol</code></em></p><p>使用的协议</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一些常用的Windows-api&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#一些常用的Windows-api&quot;&gt;¶&lt;/a&gt;一些常用的Windows-api&lt;/h2&gt;
&lt;h3 id=&quot;WSAGetLastError&quot;&gt;&lt;a class=&quot;he</summary>
      
    
    
    
    <category term="平台-Windows" scheme="https://115jiege.github.io/categories/%E5%B9%B3%E5%8F%B0-Windows/"/>
    
    
    <category term="Windows" scheme="https://115jiege.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>使用Android模拟器</title>
    <link href="https://115jiege.github.io/2023/04/18/%E5%B9%B3%E5%8F%B0-android/%E4%BD%BF%E7%94%A8Android%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
    <id>https://115jiege.github.io/2023/04/18/%E5%B9%B3%E5%8F%B0-android/%E4%BD%BF%E7%94%A8Android%E6%A8%A1%E6%8B%9F%E5%99%A8/</id>
    <published>2023-04-18T03:13:28.000Z</published>
    <updated>2023-06-07T00:35:45.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Android模拟器"><a class="header-anchor" href="#安装Android模拟器">¶</a>安装Android模拟器</h2><p>Android模拟器这步真的太痛苦了ε=( o｀ω′)ノ<br>搞了好多办法最后搞得Android studio总是闪退，解决办法：重装软件啦╮(╯▽╰)╭</p><h3 id="AndroidStudio自带的安卓模拟器"><a class="header-anchor" href="#AndroidStudio自带的安卓模拟器">¶</a>AndroidStudio自带的安卓模拟器</h3><p>在虚拟机里安装Android Studio，使用它自带的安卓模拟器;</p><p>打开Android Studio，第一次打开会进行一些基础设置和安装sdk，默认就好；<br>新建工程，打开tools-&gt;sdk manager;安装Android Emulator(最新版),Android SDK plantform-tools,ndk(自定义奥);</p><p>打开Device Manager，create virtual device:<br>1)choose a device definition — Nexus 5X;</p><p>2)select a system image — Nougat(api:24,ABI:X86)<br>可以自主选择需要的不同api等级和ABI的镜像，但是需要注意:<br><strong>①系统缺少/不支持VT-x/AMD-V;</strong><br>解决：关闭虚拟机，打开设置-系统-处理器-勾选启用嵌套VT-x/AMD-V;</p><p>如果无法启用，选项为灰色，则使用VBoxManage以命令行的方式进行开启,操作步骤如下:<br>物理机管理员身份打开cmd，cd到virtualbox安装目录;<br>VBoxManage.exe list vms   #列出虚拟机名字<br>.\vboxmanage.exe modifyvm hostname --nested-hw-virt on  #打开hostname的嵌套VT-x/AMD-V功能</p><p><strong>②选择api level</strong><br>新建项目工程时选择的api等级是工程支持的最低SDK版本，所以选择镜像的api等级应该不小于这个等级;</p><p>如果想要修改min-api，可以打开工程结构File-&gt;Project Structure(or快捷键Ctrl+Alt+Shift+S)，修改Default Config-&gt;Min SDK version;</p><p><strong>③选择ABI</strong><br>科普：<br>ABI (Application Binray interface):应用程序二进制接口，描述了应用程序和操作系统之间，一个应用和它的库之间，或应用的组成部分之间的底层接口。<br>早期的Android系统几乎只支持ARMv5的CPU架构，后面发展到支持七种不同的CPU架构：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起)，每一种都关联着一个相应的ABI。<br>应用程序二进制接口（Application Binary Interface）定义了二进制文件（尤其是.so文件）如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库。<br>在Android 系统上，每一个CPU架构对应一个ABI：armeabi，armeabi-v7a，x86，mips，arm64- v8a，mips64，x86_64。<br>AndroidStudio自带的模拟器中只有常用的四种：armeabi-v7a，x86，arm64- v8a，x86_64;可以按需选择。</p><p>但是最好是对应系统的CPU架构，建议先查看系统cpu架构(unix系统使用命令&quot;uname -a&quot;查看)，然后选择对应的CPU架构;<br>比如我的ubuntu2204的CPU架构是X86_64，所以就可以选择X86和X86_64位的;<br>尝试使用armeabi-v7a的镜像，结果启动后一直卡在开机页面(Windows试过也是这样，可能是不兼容);</p><p>不过这些虚拟设备动辄四五个G，还有八九个G的，运行起来也很卡，最关键的是，连接不上！！！！<br>经过一番努力后，选择放弃，改用别的安卓模拟器。</p><h3 id="genymotion"><a class="header-anchor" href="#genymotion">¶</a>genymotion</h3><p>寻找资料发现ubuntu等linux系统可用安卓模拟器很多，不仅安装方便，运行也不会很卡;<br>这里我是用的是genymotion，原因是好看。</p><h4 id="安装VirtualBox"><a class="header-anchor" href="#安装VirtualBox">¶</a>安装VirtualBox</h4><p>genymotion依赖于VirtualBox，所以不仅物理机的Virtualbox要开启VT-x/AMD-V扩展功能，还要在虚拟机内安装virtualbox;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install virtualbox</span><br></pre></td></tr></table></figure><h4 id="安装genymotion"><a class="header-anchor" href="#安装genymotion">¶</a>安装genymotion</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.genymotion.com/releases/genymotion-3.1.2/genymotion-3.1.2-linux_x64.bin</span><br><span class="line">sudo ./genymotion-3.1.2-linux_x64.bin</span><br></pre></td></tr></table></figure><p><em>默认安装目录：/opt/genymobile/genymotion</em></p><h4 id="添加快捷方式"><a class="header-anchor" href="#添加快捷方式">¶</a>添加快捷方式</h4><p>打开终端，命令行输入以下内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim</span><br><span class="line"><span class="built_in">ln</span> -s /opt/genymobile/genymotion/genymotion /usr/bin/genymotion</span><br><span class="line"><span class="built_in">ln</span> -s /opt/genymobile/genymotion/icons/genymotion-logo.png /usr/local/share/genymotion-logo.png</span><br><span class="line"><span class="built_in">cd</span> /usr/share/applications </span><br><span class="line">sudo vim ./genymotion.desktop</span><br></pre></td></tr></table></figure><p>新建桌面文件，添加以下内容:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Desktop Entry]</span><br><span class="line"></span><br><span class="line"><span class="attribute">Name</span> <span class="operator">=</span> genymotion</span><br><span class="line"></span><br><span class="line"><span class="attribute">Exec</span> <span class="operator">=/</span>usr/bin/genymotion</span><br><span class="line"></span><br><span class="line"><span class="attribute">Icon</span> <span class="operator">=/</span>usr/local/share/genymotion-logo.png</span><br><span class="line"></span><br><span class="line"><span class="attribute">Comment</span> <span class="operator">=</span> genymotion</span><br><span class="line"></span><br><span class="line"><span class="attribute">Type</span> <span class="operator">=</span> Application   </span><br></pre></td></tr></table></figure><h4 id="注册"><a class="header-anchor" href="#注册">¶</a>注册</h4><p>因为genymotion需要账号登陆，因此我们需要去官网创建账号，因此才可以登陆软件；<br><a href="https://www.genymotion.com/account/create/">创建账号</a><br>创建好账号之后，回到genymotion软件，输入帐号密码，点击next，选择Personal Use，继续next即可使用个人版;</p><h4 id="AndroidStudio插件"><a class="header-anchor" href="#AndroidStudio插件">¶</a>AndroidStudio插件</h4><p>打开AndroidStudio，找到setting-plugins，搜索genymotion，安装插件并重启Android Studio;<br>点击Genymotion插件图标，打开插件;<br>(没有UI工具栏的，需要依次点击 View =&gt; Appearance =&gt; Toolbar 即可找到)<br>打开setting-tools-genymotion plugin，填入Genymotion安装路径;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装Android模拟器&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#安装Android模拟器&quot;&gt;¶&lt;/a&gt;安装Android模拟器&lt;/h2&gt;
&lt;p&gt;Android模拟器这步真的太痛苦了ε=( o｀ω′)ノ&lt;br&gt;
搞了好多办法最后搞得And</summary>
      
    
    
    
    <category term="平台-android" scheme="https://115jiege.github.io/categories/%E5%B9%B3%E5%8F%B0-android/"/>
    
    
    <category term="android studio" scheme="https://115jiege.github.io/tags/android-studio/"/>
    
    <category term="模拟器" scheme="https://115jiege.github.io/tags/%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Virtualbox搭建虚拟机</title>
    <link href="https://115jiege.github.io/2023/04/18/tips%E6%95%B4%E7%90%86/Virtualbox%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://115jiege.github.io/2023/04/18/tips%E6%95%B4%E7%90%86/Virtualbox%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2023-04-18T03:06:48.000Z</published>
    <updated>2023-04-23T02:15:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装virtualbox"><a class="header-anchor" href="#安装virtualbox">¶</a>安装virtualbox:</h2><p><a href="https://www.virtualbox.org/wiki/Downloads">virtualbox主程序</a><br>点击链接，选择合适的版本下载virtualbox;</p><h2 id="安装ubuntu虚拟机"><a class="header-anchor" href="#安装ubuntu虚拟机">¶</a>安装ubuntu虚拟机</h2><p>下载镜像:<br><a href="https://ubuntu.com/download/desktop">官方下载地址</a><br>推荐，官方不花里胡哨，国内镜像源下载的ubuntu-22.04.2-desktop-amd64.iso出现了写入错误，内核编译缺少头文件等情况。<br>写入错误导致ubuntu无法安装，内核头文件确实导致virtualbox安装增强功能失败。</p><p><a href="https://mirrors.cloud.tencent.com/ubuntu-releases/22.04/">腾讯镜像站</a></p><p><a href="https://mirrors.aliyun.com/ubuntu-releases/22.04/">阿里镜像站</a></p><p><a href="https://repo.huaweicloud.com/ubuntu-releases/22.04">华为镜像站</a></p><p><em>ps:widows镜像可以到<a href="https://msdn.itellyou.cn/">msdn</a> 上下载</em></p><p>点击新建，填写虚拟机名称、安装位置，镜像位置，默认安装;<br>虚拟机里装模拟器，要把内存设置的大一点，我设置了100G(‾◡◝)</p><h3 id="修改分辨率"><a class="header-anchor" href="#修改分辨率">¶</a>修改分辨率</h3><p>进入系统之后发现缩放比例不对，其实是分辨率的问题，找到setting-&gt;desplays修改分辨率;</p><p>系统中没有1920x1080的肿么办，可以自己添加:<br>打开终端，输入xrandr，查看到屏幕分辨率最小是1x1，目前是:800x600，最大是8192x8192，虚拟机编号是&quot;Virtual1&quot;;<br>输入cvt 1920 1080，查看显示模式的相关信息:“Modeline xxxxxx”;<br>添加显示模式，输入下面两条命令:<br>sudo xrandr --newmode xxxxxx<br>sudo xrandr --addmode Virtual1(虚拟机编号) “1920x1080 60.00”<br>使用命令xrandr查看，可以发现可供选择的分辨率多了自己自定义的模式，可以到设置里设置显示屏分辨率了;</p><p>或者：<br>点击界面的设备，选择安装增强功能，点击运行;<br>点击光盘，sudo ./VBoxLinuxAdditions.run，成功后重启虚拟机;<br>点击视图-自动调整显示尺寸；可以使显示窗口自动填满界面。</p><h3 id="共享文件夹"><a class="header-anchor" href="#共享文件夹">¶</a>共享文件夹</h3><p>首先弹出上一步安装增强功能所用的光盘(不然挂载会失败);<br>修改虚拟机的设置，点击共享文件夹，新建:填写共享文件夹目录(物理机D:\shared)，文件夹名称(shared)，勾选自动挂载，固定分配;<br>回到虚拟机，打开终端，输入命令行创建文件夹:<br>sudo mkdir /home/Win10<br>将主机共享文件夹与Ubuntu的共享文件夹连接起来:<br>sudo mount -t vboxsf shared /home/Win10<br>在主机的共享文件夹放置一个文件，如果Ubuntu内的对应共享文件夹内能看到该文件，则说明共享文件夹创建成功。</p><p><em>注意：物理机的共享目录不要放到C盘或者virtualbox的安装目录下(需要管理员权限的那种)，不然操作共享目录需要物理机管理员权限，在Ubuntu上就算是sudo也没用。</em></p><h3 id="共享粘贴板和拖放"><a class="header-anchor" href="#共享粘贴板和拖放">¶</a>共享粘贴板和拖放</h3><p>设备-将禁用改为双向;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装virtualbox&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#安装virtualbox&quot;&gt;¶&lt;/a&gt;安装virtualbox:&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.virtualbox.org/wiki/Down</summary>
      
    
    
    
    <category term="tips整理" scheme="https://115jiege.github.io/categories/tips%E6%95%B4%E7%90%86/"/>
    
    
    <category term="virtualbox" scheme="https://115jiege.github.io/tags/virtualbox/"/>
    
  </entry>
  
  <entry>
    <title>android开发--活动的创建与使用</title>
    <link href="https://115jiege.github.io/2023/03/31/%E5%B9%B3%E5%8F%B0-android/android%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://115jiege.github.io/2023/03/31/%E5%B9%B3%E5%8F%B0-android/android%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2023-03-31T00:20:32.000Z</published>
    <updated>2023-04-23T02:03:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>本章学习Android中的活动，活动是一种可以包含用户界面的组件，主要用于和用户交互。</p><h2 id="活动的基本用法"><a class="header-anchor" href="#活动的基本用法">¶</a>活动的基本用法</h2><h3 id="创建活动"><a class="header-anchor" href="#创建活动">¶</a>创建活动</h3><h4 id="新建项目"><a class="header-anchor" href="#新建项目">¶</a>新建项目</h4><p>打开Android Studio新建Android项目，选择no Activity，等待gradle构建;</p><h4 id="新建活动"><a class="header-anchor" href="#新建活动">¶</a>新建活动</h4><p>右击 app/src/main/java/com.example.activitytest-&gt;New-&gt;Actvity-&gt;Empty Activity，创建活动FirstActivity，注意不勾选Generate Layout和Launcher Activity;<br>打开创建的FirstActivity，发现Android Studio自动完成了重写Activity的onCreate()方法，即调用父类的onCreate()方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建布局"><a class="header-anchor" href="#创建布局">¶</a>创建布局</h3><p>布局用于显示页面内容，最好每个活动对应一个布局;</p><h4 id="新建布局文件"><a class="header-anchor" href="#新建布局文件">¶</a>新建布局文件</h4><p>右击app/src/main/res-&gt;New-&gt;Directory，新建layout文件夹；<br>右击layout-&gt;NeW-&gt;Layout resource file,创建first_layout布局文件，选择根元素为LinearLayout;<br>布局文件创建完成后，Android Studio会显示可视化布局编辑器(右上角可切换模式);</p><h4 id="编辑布局文件"><a class="header-anchor" href="#编辑布局文件">¶</a>编辑布局文件</h4><p>编辑布局文件，添加一个按钮：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/button_1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;150dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginEnd</span>=<span class="string">&quot;150dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;400dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;START&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这里添加了一个Button元素，并增加了几个属性。<br><strong>id</strong><br>android:id为当前元素定义一个唯一标识符：在XML中引用一个id，使用@id/id_name;在XML中定义一个id，使用@+id/id_name;<br><strong>width、height</strong><br>android:layout_width、android:layout_height定义了元素的宽高，使用wrap_content表示当前元素的高度只要刚好能包含里面的内容;<br><strong>margin</strong><br>android:layout_marginStart、android:layout_marginTop、android:layout_marginEnd、android:layout_marginBottom定义了元素的位置;</p><p>layout_marginTop 指定该属性所在控件距上部最近控件的最小值;<br>layout_marginBottom 指定该属性所在控件距下部最近控件的最小值;<br>layout_marginLeft 指定该属性所在控件距左边最近控件的最小值;<br>layout_marginRight 指定该属性所在控件距右边最近控件的最小值;<br>layout_marginStart：如果在LTR布局模式下，该属性等同于layout_marginLeft。如果在RTL布局模式下，该属性等同于layout_marginRight。<br>layout_marginEnd：如果在LTR布局模式下，该属性等同于layout_marginRight。如果在RTL布局模式下，该属性等同于layout_marginLeft。<br><strong>text</strong><br>android:text制定了元素显示的文字内容;<br><strong>constraint</strong><br>控件在ConstraintLayout里面要实现margin，必须先约束该控件在ConstraintLayout里的位置;<br>app:layout_constraintBottom_toBottomOf、app:layout_constraintEnd_toEndOf、app:layout_constraintStart_toStartOf、app:layout_constraintTop_toTopOf约束元素在parent里的位置，使得margin生效。</p><blockquote><p>约束布局ConstraintLayout是一个ViewGroup，可以在Api9以上的Android系统使用它，它的出现主要是为了解决布局嵌套过多的问题，以灵活的方式定位和调整小部件。<br>例如：首先是一个垂直的LinearLayout，里面放两个水平的LinearLayout，然后在水平的LinearLayout里面放TextView。这样的写法就嵌套了两层LinearLayout，可能会出现布局嵌套过多的问题，嵌套得越多，设备绘制视图所需的时间和计算功耗也就越多。<br>ConstraintLayout横空出世，ConstraintLayout可以按照比例约束控件位置和尺寸，能够更好地适配屏幕大小不同的机型。</p></blockquote><p>使用ConstraintLayout首先需要添加依赖，在build.gradle(app)中添加<br>implementation ‘com.android.support.constraint:constraint-layout:1.1.3’</p><p>使用ConstraintLayout可以实现控件位置的控制:</p><p>布局文件中添加:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/TextView1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;TextView1&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/TextView2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintLeft_toRightOf</span>=<span class="string">&quot;@+id/TextView1&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>可以实现元素TextView2的相对定位，使用属性app:layout_constraintLeft_toRightOf=“@+id/TextView1”，把TextView2的左边约束到TextView1的右边;</p><p>相对定位的常用属性：<br>layout_constraintLeft_toLeftOf<br>layout_constraintLeft_toRightOf<br>layout_constraintRight_toLeftOf<br>layout_constraintRight_toRightOf<br>layout_constraintTop_toTopOf<br>layout_constraintTop_toBottomOf<br>layout_constraintBottom_toTopOf<br>layout_constraintBottom_toBottomOf<br>layout_constraintBaseline_toBaselineOf<br>layout_constraintStart_toEndOf<br>layout_constraintStart_toStartOf<br>layout_constraintEnd_toStartOf<br>layout_constraintEnd_toEndOf</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:id</span>=<span class="string">&quot;@+id/TextView1&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:text</span>=<span class="string">&quot;TextView1&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:id</span>=<span class="string">&quot;@+id/TextView2&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">app:layout_constraintCircle</span>=<span class="string">&quot;@+id/TextView1&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">app:layout_constraintCircleAngle</span>=<span class="string">&quot;60&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">app:layout_constraintCircleRadius</span>=<span class="string">&quot;100dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>可以实现TextView2的角度定位，属性app:layout_constraintCircle=&quot;@+id/TextView1&quot;确定中心为TextView1，属性app:layout_constraintCircleAngle=&quot;160&quot;确定在TextView1的中心的60°，属性app:layout_constraintCircleRadius=&quot;100dp确定和TextView1距离为100dp;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/TextView1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintHorizontal_bias</span>=<span class="string">&quot;0.618&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">app:layout_constraintVertical_bias</span>=<span class="string">&quot;0.618&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>可以实现TextView1的偏移，layout_constraintHorizontal_bias 水平偏移，layout_constraintVertical_bias 垂直偏移;此外，constraint还可以实现更多更复杂的布局。</p><p>总之，这样一个简单的布局就编写完成了，接下来要在活动中加载这个布局。</p><h4 id="加载布局文件"><a class="header-anchor" href="#加载布局文件">¶</a>加载布局文件</h4><p>编辑FirstActivity，onCreate()方法调用setContentView()方法加载布局:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.first_layout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册活动"><a class="header-anchor" href="#注册活动">¶</a>注册活动</h3><p>所有的活动都要在AndroidManifest.xml中进行注册才能生效，打开app/src/main/AndroidMainfest.xml:</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">application</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    ···</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"> &lt;<span class="attr">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.FirstActivity&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在activity标签中使用android.name注册活动;并在其中加入<intent-filter>标签，设置FirstActivity为主活动，即当程序运行时，首先启动FirstActivity;</intent-filter></p><h3 id="Toast的使用"><a class="header-anchor" href="#Toast的使用">¶</a>Toast的使用</h3><p>Toast是Android系统提供的提醒方式，在程序中可以把一些短小的消息传给用户，这些消息在一定时间后会自动消失，且不占用任何屏幕空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.first_layout);</span><br><span class="line">    <span class="type">Button</span> <span class="variable">button1</span> <span class="operator">=</span> (Button) findViewById(R.id.button_1);</span><br><span class="line">    button1.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">            Toast.makeText(FirstActivity.<span class="built_in">this</span>,<span class="string">&quot;开始测试&quot;</span>,</span><br><span class="line">                    Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">                               &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在活动中，通过findViewById()方法获取到定义在布局文件中的元素，传入R.id.button_1(first_layout中android:id规定的唯一标识符)获取按钮的实例，且findViewById()返回的是一个view对象，需要转化成Button对象;<br>然后调用setOnClickListener()方法为按钮注册一个监听器，点击按钮时就会执行监听器中的onClick()方法;<br>编写onClick()方法，通过静态方法makeText()创建出一个Toast对象，然后显示;</p><p>makeText()方法的输入参数为Context(活动要求的上下文)、Toast现实的文本内容、Toast的显示时长。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本章学习Android中的活动，活动是一种可以包含用户界面的组件，主要用于和用户交互。&lt;/p&gt;
&lt;h2 id=&quot;活动的基本用法&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#活动的基本用法&quot;&gt;¶&lt;/a&gt;活动的基本用法&lt;/h2&gt;
&lt;h3 id=&quot;创建活动&quot;</summary>
      
    
    
    
    <category term="平台-android" scheme="https://115jiege.github.io/categories/%E5%B9%B3%E5%8F%B0-android/"/>
    
    
    <category term="android" scheme="https://115jiege.github.io/tags/android/"/>
    
    <category term="xml" scheme="https://115jiege.github.io/tags/xml/"/>
    
    <category term="java" scheme="https://115jiege.github.io/tags/java/"/>
    
  </entry>
  
</feed>
