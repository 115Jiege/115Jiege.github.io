<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiege</title>
  
  
  <link href="https://115jiege.github.io/atom.xml" rel="self"/>
  
  <link href="https://115jiege.github.io/"/>
  <updated>2023-05-22T07:32:05.145Z</updated>
  <id>https://115jiege.github.io/</id>
  
  <author>
    <name>Jiege</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>qt获取屏幕分辨率</title>
    <link href="https://115jiege.github.io/2023/05/22/qt%E5%BC%80%E5%8F%91--4/"/>
    <id>https://115jiege.github.io/2023/05/22/qt%E5%BC%80%E5%8F%91--4/</id>
    <published>2023-05-22T07:29:30.696Z</published>
    <updated>2023-05-22T07:32:05.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="qt获取屏幕分辨率"><a class="header-anchor" href="#qt获取屏幕分辨率">¶</a>qt获取屏幕分辨率</h2><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取主屏分辨率 </span></span><br><span class="line"><span class="variable">QRect</span> <span class="variable">mRect</span>； </span><br><span class="line"><span class="variable">mRect</span> = <span class="variable">QGuiApplication</span>::<span class="function"><span class="title">primaryScreen</span>()-&gt;<span class="title">geometry</span>(); </span></span><br><span class="line"><span class="function"><span class="title">qDebug</span>()&lt;&lt;<span class="string">&quot;width:&quot;</span>&lt;&lt;<span class="variable">mRect.width</span>()&lt;&lt;<span class="string">&quot;  height:&quot;</span>&lt;&lt;<span class="variable">mRect.height</span>();</span></span><br></pre></td></tr></table></figure><p>.获取多个显示器屏幕大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取多显示器,通过list存储当前主机所有显示器 </span></span><br><span class="line">QList&lt;QScreen *&gt; list_screen = QGuiApplication::<span class="built_in">screens</span>(); </span><br><span class="line"><span class="comment">// 通过循环可以遍历每个显示器 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list_screen.<span class="built_in">size</span>(); i++) </span><br><span class="line">&#123; </span><br><span class="line">    QRect rect = list_screen.<span class="built_in">at</span>(i)-&gt;<span class="built_in">geometry</span>(); </span><br><span class="line">    <span class="type">int</span> desktop_width = rect.<span class="built_in">width</span>(); </span><br><span class="line">    <span class="type">int</span> desktop_height = rect.<span class="built_in">height</span>(); </span><br><span class="line">    <span class="comment">// 打印屏幕分辨率 </span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; desktop_width &lt;&lt;desktop_height; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>error：</p><p><a href="http://libQt5WebEngineCore.so">libQt5WebEngineCore.so</a>: .dynsym local <a href="https://so.csdn.net/so/search?q=symbol&amp;spm=1001.2101.3001.7020">symbol</a> at index 3</p><p>解决：sudo ln -sf /usr/bin/x86_64-linux-gnu-ld.gold /usr/bin/ld</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;qt获取屏幕分辨率&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#qt获取屏幕分辨率&quot;&gt;¶&lt;/a&gt;qt获取屏幕分辨率&lt;/h2&gt;
&lt;figure class=&quot;highlight isbl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte</summary>
      
    
    
    
    <category term="研发" scheme="https://115jiege.github.io/categories/%E7%A0%94%E5%8F%91/"/>
    
    
    <category term="qt" scheme="https://115jiege.github.io/tags/qt/"/>
    
  </entry>
  
  <entry>
    <title>root权限启动QtWebEngine</title>
    <link href="https://115jiege.github.io/2023/05/22/root%E6%9D%83%E9%99%90%E5%90%AF%E5%8A%A8QtWebEngine/"/>
    <id>https://115jiege.github.io/2023/05/22/root%E6%9D%83%E9%99%90%E5%90%AF%E5%8A%A8QtWebEngine/</id>
    <published>2023-05-22T07:12:45.668Z</published>
    <updated>2023-05-22T07:29:30.699Z</updated>
    
    <content type="html"><![CDATA[<p>QtWebEngine这个部件用到了chrome的插件，众所周知，chrome不允许在root权限下启动，除非加上–no-sandbox；</p><p>所以这里的解决方案也是一样，选择无沙盒启动。</p><h3 id="Qt调试"><a class="header-anchor" href="#Qt调试">¶</a>Qt调试</h3><p>对于以root权限在Qtcreator中调试含QtWebEngine的工程的情况，可以项目-&gt;运行-&gt;环境中添加一个新的变量</p><p>QTWEBENGINE_DISABLE_SANDBOX，并置其为1。</p><h3 id="脚本启动"><a class="header-anchor" href="#脚本启动">¶</a>脚本启动</h3><p>对于脚本启动则需要在脚本中添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> XDG_RUNTIME_DIR=/tmp/runtime-root</span><br><span class="line"><span class="built_in">export</span> QTWEBENGINE_DISABLE_SANDBOX=1</span><br></pre></td></tr></table></figure><h3 id="自定义宏编译"><a class="header-anchor" href="#自定义宏编译">¶</a>自定义宏编译</h3><p>题外话，在编译阶段，如果想根据宏的开关选择不同的链接库活着编译不同的代码，</p><p>可以在项目-&gt;构建-&gt;构建的步骤-&gt;qmake-&gt;额外的参数中添加’DEFINES+=XXX’(单引号不要漏掉)；</p><p>这样就可以在pro文件和工程其他文件中使用了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> XXX</span></span><br><span class="line"> ......</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> ......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;QtWebEngine这个部件用到了chrome的插件，众所周知，chrome不允许在root权限下启动，除非加上–no-sandbox；&lt;/p&gt;
&lt;p&gt;所以这里的解决方案也是一样，选择无沙盒启动。&lt;/p&gt;
&lt;h3 id=&quot;Qt调试&quot;&gt;&lt;a class=&quot;header-an</summary>
      
    
    
    
    <category term="研发" scheme="https://115jiege.github.io/categories/%E7%A0%94%E5%8F%91/"/>
    
    
    <category term="qt" scheme="https://115jiege.github.io/tags/qt/"/>
    
  </entry>
  
  <entry>
    <title>linux平台打包qt应用程序</title>
    <link href="https://115jiege.github.io/2023/05/22/linux%E5%B9%B3%E5%8F%B0%E6%89%93%E5%8C%85qt%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>https://115jiege.github.io/2023/05/22/linux%E5%B9%B3%E5%8F%B0%E6%89%93%E5%8C%85qt%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</id>
    <published>2023-05-22T06:37:02.066Z</published>
    <updated>2023-05-22T07:29:30.691Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做Linux平台的Qt开发，功能基本实现之后，就要考虑应用程序的打包了。</p><h2 id="LINUX打包步骤"><a class="header-anchor" href="#LINUX打包步骤">¶</a>LINUX打包步骤</h2><h3 id="环境"><a class="header-anchor" href="#环境">¶</a>环境</h3><p>os：ubuntu 20.04</p><p>开发工具：qt5.15.2(默认安装目录/opt/Qt)</p><h3 id="准备"><a class="header-anchor" href="#准备">¶</a>准备</h3><p>需要准备两个脚本文件，</p><p><a href="http://ldd.sh">ldd.sh</a>：在当前目录下新建lib文件夹，拷贝目标程序的依赖库，存放到新建的lib下；</p><p><a href="http://mytest.sh">mytest.sh</a>：用于执行程序，要和生成的可执行程序同名;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 ldd.sh</span><br><span class="line"><span class="built_in">chmod</span> 777 mytest.sh</span><br></pre></td></tr></table></figure><p>准备目标文件夹(MyTest)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> MyTest</span><br></pre></td></tr></table></figure><p>下面给出源码模板</p><p><strong><a href="http://ldd.sh">ldd.sh</a></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">LibDir=$PWD<span class="string">&quot;/lib&quot;</span></span><br><span class="line">Target=$<span class="number">1</span></span><br><span class="line">lib_array=($(ldd $Target | grep -o <span class="string">&quot;/.*&quot;</span> | grep -o <span class="string">&quot;/.*/[^[:space:]]*&quot;</span>))</span><br><span class="line">$(mkdir $LibDir)</span><br><span class="line"><span class="keyword">for</span> Variable in $&#123;lib_array[@]&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    cp <span class="string">&quot;$Variable&quot;</span> $LibDir</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><a href="http://mytest.sh">mytest.sh</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">appname=`basename $<span class="number">0</span> | sed s,\.sh$,,`</span><br><span class="line">dirname=`dirname $<span class="number">0</span>`</span><br><span class="line">tmp=<span class="string">&quot;$&#123;dirname#?&#125;&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$&#123;dirname%$tmp&#125;&quot;</span> != <span class="string">&quot;/&quot;</span> ]; then</span><br><span class="line">dirname=$PWD/$dirname</span><br><span class="line">fi</span><br><span class="line">LD_LIBRARY_PATH=$dirname</span><br><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH</span><br><span class="line">$dirname/$appname <span class="string">&quot;$@&quot;</span> </span><br></pre></td></tr></table></figure><h3 id="添加程序依赖"><a class="header-anchor" href="#添加程序依赖">¶</a>添加程序依赖</h3><p>1)项目工程(mytest)编译Release版本，拷贝ldd.sh到build-mytest-Desktop_Qt_5_15_2_GCC_64bit-Release下，<a href="http://xn--ldd-m35fr68n.sh">执行ldd.sh</a>；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ldd.sh mytest</span><br></pre></td></tr></table></figure><p>2)拷贝lib目录下的全部文件到MyTest，删除lib文件夹和ldd.sh文件；</p><p>拷贝可执行程序mytest和脚本mytest.sh到MyTest；</p><h3 id="添加qt依赖"><a class="header-anchor" href="#添加qt依赖">¶</a>添加qt依赖</h3><p>拷贝ldd.sh到qt的platfroms文件夹下；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> ldd.sh /opt/Qt/5.15.2/gcc_64/plugins/platforms/</span><br><span class="line"><span class="built_in">cd</span> /opt/Qt/5.15.2/gcc_64/plugins/platforms/</span><br><span class="line">./ldd.sh libqxcb.so</span><br></pre></td></tr></table></figure><p>拷贝/opt/Qt/5.15.2/gcc_64/plugins/platforms/lib目录下的所有文件到MyTest，<a href="http://xn--libldd-ho3j83nko4p.sh">删除lib和ldd.sh</a>；</p><p>拷贝/opt/Qt/5.15.2/gcc_64/plugins/platforms文件夹到MyTest；</p><h3 id="拷贝WebEngine依赖（可选）"><a class="header-anchor" href="#拷贝WebEngine依赖（可选）">¶</a>拷贝WebEngine依赖（可选）</h3><p>如果项目工程里用到了QtWebEngine插件，那么为了WebEngine的正常运行，还需要拷贝其他依赖库;</p><h4 id="添加nss"><a class="header-anchor" href="#添加nss">¶</a>添加nss</h4><p>拷贝/usr/lib/x86_64-linux-gnu/nss文件夹到MyTest；</p><h4 id="添加XCB"><a class="header-anchor" href="#添加XCB">¶</a>添加XCB</h4><p>拷贝/opt/Qt/5.15.2/gcc_64/plugins/xcbglintegrations文件夹到MyTest；</p><h4 id="添加QtWebEngine程序"><a class="header-anchor" href="#添加QtWebEngine程序">¶</a>添加QtWebEngine程序</h4><p>拷贝/opt/Qt/5.15.2/gcc_64/libexec/QtWebEngineProcess程序到MyTest；</p><p>拷贝/opt/Qt/5.15.2/gcc_64/resources下所有文件到MyTest，并拷贝/opt/Qt/5.15.2/gcc_64/resources整个文件夹到MyTest；</p><p>拷贝/opt/Qt/5.15.2/gcc_64/translations文件夹到MyTest；</p><p>打包MyTest。</p><h2 id="打包程序执行"><a class="header-anchor" href="#打包程序执行">¶</a>打包程序执行</h2><p>打包好的程序怎么执行呢？</p><p>解压压缩包</p><p><a href="http://xn--sudomytest-cc9tv146a.sh">sudo执行mytest.sh</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./mytest.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在做Linux平台的Qt开发，功能基本实现之后，就要考虑应用程序的打包了。&lt;/p&gt;
&lt;h2 id=&quot;LINUX打包步骤&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#LINUX打包步骤&quot;&gt;¶&lt;/a&gt;LINUX打包步骤&lt;/h2&gt;
&lt;h3 id=&quot;环境&quot;</summary>
      
    
    
    
    <category term="研发" scheme="https://115jiege.github.io/categories/%E7%A0%94%E5%8F%91/"/>
    
    
    <category term="qt" scheme="https://115jiege.github.io/tags/qt/"/>
    
  </entry>
  
  <entry>
    <title>使用U盘重装Win10系统</title>
    <link href="https://115jiege.github.io/2023/05/12/%E4%BD%BF%E7%94%A8U%E7%9B%98%E9%87%8D%E8%A3%85Win10%E7%B3%BB%E7%BB%9F/"/>
    <id>https://115jiege.github.io/2023/05/12/%E4%BD%BF%E7%94%A8U%E7%9B%98%E9%87%8D%E8%A3%85Win10%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-05-12T01:43:14.000Z</published>
    <updated>2023-05-12T01:43:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工具准备"><a class="header-anchor" href="#工具准备">¶</a>工具准备</h2><ol><li>U盘<br>准备一个8G以上的空白U盘<br>注意：<strong>制作系统重装工具会格式化U盘，需要做好U盘文件备份</strong></li><li>Windows下载工具<br><a href="https://www.microsoft.com/zh-cn/software-download/windows10">官方下载连接</a></li></ol><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-12-10-08-55-image.png" alt></p><h2 id="制作安装U盘"><a class="header-anchor" href="#制作安装U盘">¶</a>制作安装U盘</h2><ol><li><p>双击下载的文件</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-12-10-10-24-image.png" alt></p></li><li><p>同意所有不平等条约</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-12-10-11-46-image.png" alt></p></li><li><p>选择为另一台电脑创建安装介质</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-12-10-12-38-image.png" alt></p></li><li><p>取消勾选“对这台电脑使用推荐的选项”，如果是DIY主机，建议选择“专业版”；否则选择家庭版，可以免去激活过程。</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-12-10-14-01-image.png" alt></p></li><li><p>选择使用的介质</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-12-10-17-25-image.png" alt></p></li><li><p>选择U盘</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-12-10-18-11-image.png" alt></p><p><strong>制作系统重装工具会格式化U盘，需要做好U盘文件备份</strong></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;工具准备&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#工具准备&quot;&gt;¶&lt;/a&gt;工具准备&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;U盘&lt;br&gt;
准备一个8G以上的空白U盘&lt;br&gt;
注意：&lt;strong&gt;制作系统重装工具会格式化U盘，需要做好U盘文件备份&lt;/s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux捕获程序崩溃异常——qbreakpad</title>
    <link href="https://115jiege.github.io/2023/05/08/Linux%E6%8D%95%E8%8E%B7%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E5%BC%82%E5%B8%B8/"/>
    <id>https://115jiege.github.io/2023/05/08/Linux%E6%8D%95%E8%8E%B7%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E5%BC%82%E5%B8%B8/</id>
    <published>2023-05-08T07:58:08.000Z</published>
    <updated>2023-05-08T09:21:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>在进行Linux平台的qt程序开发时，出现程序崩溃退出的情况，而且没有什么信息(ˉ▽ˉ；)…。</p><p>bing了一下发现一个可以定位崩溃位置的工具qbreakpad，这里记录一下qbreakpad的安装过程。</p><h1>qbreakpad的安装过程</h1><h2 id="源码准备"><a class="header-anchor" href="#源码准备">¶</a>源码准备</h2><h3 id="下载Breakpad源码"><a class="header-anchor" href="#下载Breakpad源码">¶</a>下载Breakpad源码</h3><p><a href="https://github.com/google/breakpad">下载地址</a></p><p>建议选择tags=<strong>v2021.08.09</strong></p><h3 id="下载LSS源码"><a class="header-anchor" href="#下载LSS源码">¶</a>下载LSS源码</h3><p><a href="https://github.com/ithaibo/linux-syscall-support">下载地址</a> 需要注意，如果您的gcc版本高于9.0，在构建breakpad时可能会报错：</p><p><code>linux\_syscall\_support.h: error: listing the stack pointer register 'rsp' in a clobber list is deprecated</code></p><p>解决：更换修正版lss</p><p><a href="https://chromium.googlesource.com/linux-syscall-support/+/8048ece6c16c91acfe0d36d1d3cc0890ab6e945c">下载地址</a></p><h3 id="下载qBreakpad源码"><a class="header-anchor" href="#下载qBreakpad源码">¶</a>下载qBreakpad源码</h3><p><a href="https://github.com/buzzySmile/qBreakpad">下载地址</a></p><h2 id="编译qBreakpad"><a class="header-anchor" href="#编译qBreakpad">¶</a>编译qBreakpad</h2><p>下载qBreakpad源码，在<code>qBreakpad/third_party</code>目录下，把下载好的LSS源码和Breakpad源码放入其中；修改文件夹名为lss和breakpad;</p><p><a href="http://xn--qtcreatorqBreakpad-ci98aj42blj7g.pro">用qtcreator打开qBreakpad.pro</a>，直接构建；</p><p>构建成功后，会在<code>qBreakpad/handler</code> 目录下生成<code>libqBreakpad.a</code>文件，保存目录下的头文件<code>QBreakpadHandler.h、QBreakpadHttpUploader.h、singletone/call_once.h、singletone/singleton.h</code>。</p><h2 id="调用qBreakpad"><a class="header-anchor" href="#调用qBreakpad">¶</a>调用qBreakpad</h2><p>在自己的qt工程(qbreakpadTest)下新建qBreakpad目录，将<code>libqBreakpad.a</code>拷贝至，<code>qBreakpad\lib\</code>目录下；</p><p>将调用库所需的头文件<code>QBreakpadHandler.h、QBreakpadHttpUploader.h、call_once.h、singleton.h</code>共4个文件拷贝至<code>qBreakpad\include</code>下。</p><p>在qbreakTest.pro下增加以下内容：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############ for qBreakpad ############</span></span><br><span class="line"><span class="comment"># qBreakpad中需要使用到network模块</span></span><br><span class="line"><span class="attr">QT</span> <span class="string">+= network</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 启用多线程、异常、RTTI、STL支持</span></span><br><span class="line"><span class="attr">CONFIG</span> <span class="string">+= thread exceptions rtti stl</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># without c++11 &amp; AppKit library compiler can&#x27;t solve address for symbols</span></span><br><span class="line"><span class="attr">CONFIG</span> <span class="string">+= c++11</span></span><br><span class="line"><span class="attr">macx</span>: <span class="string">LIBS += -framework AppKit</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 配置头文件搜索路径和链接库路径</span></span><br><span class="line"><span class="attr">unix</span>:<span class="string">!macx: LIBS += -L$$PWD/qBreakpad/lib/ -lqBreakpad</span></span><br><span class="line"></span><br><span class="line"><span class="attr">INCLUDEPATH</span> <span class="string">+= $$PWD/qBreakpad/include</span></span><br><span class="line"><span class="attr">DEPENDPATH</span> <span class="string">+= $$PWD/qBreakpad/include</span></span><br><span class="line"></span><br><span class="line"><span class="attr">unix</span>:<span class="string">!macx: PRE_TARGETDEPS += $$PWD/qBreakpad/lib/libqBreakpad.a</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">############ for qBreakpad ############</span></span><br></pre></td></tr></table></figure><p>在main.cpp中添加</p><p><code> QBreakpadInstance.setDumpPath(&quot;crashes&quot;); // 设置生成dump文件路径</code></p><p>崩溃示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">qBreakpadTest::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QLabel * label = <span class="literal">nullptr</span>;</span><br><span class="line">    label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;crash&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译，运行程序，生成的<code>dump</code>文件存放在<code>Debug/crashes</code>目录下。</p><h2 id="编译breakpad"><a class="header-anchor" href="#编译breakpad">¶</a>编译breakpad</h2><p><code>Breakpad</code>提供了两个工具<code>dump_syms</code>和<code>minidump_stackwalk</code>，用于分析<code>dump</code>，定位<code>bug</code>。</p><p>下载<code>Breakpad</code>源码，将<code>LSS(linux-syscall-support)</code>源码拷贝至<code>breakpad\src\third_party</code>目录下，并重命名为lss；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> breakpad</span><br><span class="line"><span class="built_in">chmod</span> 755 configure</span><br><span class="line">./configure</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>编译完成后，在<code>breakpad/src/tools/linux/dump_syms</code>目录下，生成了<code>dump_syms</code>；</p><p>在<code>breakpad/src/processor</code>目录下，生成了<code>minidump_stackwalk</code>。</p><h2 id="使用dump-syms和minidump-stackwalk定位bug"><a class="header-anchor" href="#使用dump-syms和minidump-stackwalk定位bug">¶</a>使用dump_syms和minidump_stackwalk定位bug</h2><h3 id="1、生成符号文件"><a class="header-anchor" href="#1、生成符号文件">¶</a>1、生成符号文件</h3><p>使用<code>dump_syms</code>读取带调试信息的程序文件，并生成符号文件<code>qBreakpadTest.sym</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump_syms ./qBreakpadTest &gt; qBreakpadTest.sym</span><br></pre></td></tr></table></figure><h3 id="2、将符号文件移动到特定路径"><a class="header-anchor" href="#2、将符号文件移动到特定路径">¶</a>2、将符号文件移动到特定路径</h3><p>在自己的qt工程(qBreakpadTest)所在目录下，创建目录结构：</p><ul><li>第一级目录，固定为<code>symbols</code>；</li><li>第二级目录，为即将放入的<code>符号文件名称</code>，如<code>qBreakpadTest.sym</code>，则目录名为<code>qBreakpadTest</code>；</li><li>第三级目录，在sym文件中第一行内容，有一串<code>16进制</code>编号，将其作为<code>目录名</code>。</li></ul><p>建立好以上路径后，将<code>qBreakpadTest.sym</code>移动到此路径下。</p><h3 id="3、生成崩溃处调用堆栈信息"><a class="header-anchor" href="#3、生成崩溃处调用堆栈信息">¶</a>3、生成崩溃处调用堆栈信息</h3><p>将<code>crashes目录</code>拷贝到和<code>symbols目录</code>一个级别目录下；</p><p>然后执行如下命令，生成调用堆栈信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minidump_stackwalk ./crashes/7211c8b8-126d-4de2-7f8f00a4-db86eecc.dmp ./symbols &gt; error.log</span><br></pre></td></tr></table></figure><p>第一个参数，是dump文件名；<br>第二个参数，固定为./symbols，应该是指定符号文件位于当前symbols目录下默认路径位置；<br>第三个参数，将命令执行结果，写入到error.log文件中。</p><p>查看生成的堆栈调用信息文件<code>error.log</code>，找到<code>“crashed”</code>字样，与它最近的一行，就是发生崩溃时，程序的调用堆栈。</p><h3 id="4、dump文件上报"><a class="header-anchor" href="#4、dump文件上报">¶</a>4、dump文件上报</h3><p>将生成的<code>dump</code>文件上传到指定的服务器。</p><ul><li>先通过setDumpPath设置dump文件生成目录；以便在发生崩溃时，自动在该目录下生成dump文件。</li><li>再通过setUploadUrl设置上报地址，以便后续将dump文件，上传到该地址。</li><li>最后，通过sendDumps将dump文件发送至服务器。该函数会自动遍历，前面设置的dump生成目录，将每一个dump文件进行发送。</li></ul><p>上报演示程序，位于<code>qBreakpad\demo\reporter</code>下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在进行Linux平台的qt程序开发时，出现程序崩溃退出的情况，而且没有什么信息(ˉ▽ˉ；)…。&lt;/p&gt;
&lt;p&gt;bing了一下发现一个可以定位崩溃位置的工具qbreakpad，这里记录一下qbreakpad的安装过程。&lt;/p&gt;
&lt;h1&gt;qbreakpad的安装过程&lt;/h1&gt;
</summary>
      
    
    
    
    <category term="研发" scheme="https://115jiege.github.io/categories/%E7%A0%94%E5%8F%91/"/>
    
    
    <category term="qt" scheme="https://115jiege.github.io/tags/qt/"/>
    
    <category term="qBreakpad" scheme="https://115jiege.github.io/tags/qBreakpad/"/>
    
  </entry>
  
  <entry>
    <title>u盘格式错误</title>
    <link href="https://115jiege.github.io/2023/05/05/u%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%98%E4%B8%BARAW/"/>
    <id>https://115jiege.github.io/2023/05/05/u%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%98%E4%B8%BARAW/</id>
    <published>2023-05-05T00:23:30.000Z</published>
    <updated>2023-05-05T00:46:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有用的u盘，今天插了试了一下，发现U盘无法被读取，于是开始排查原因；</p><p>首先检查驱动，计算机-&gt;管理-&gt;设备管理器查看驱动，驱动没有问题；</p><p>检查磁盘分区，win+R，输入diskmgmt.msc，找到出错的u盘，发现文件系统为RAW？？(ˉ▽ˉ；)…</p><p><code>RAW格式(未格式化)磁盘代表文档系统已损坏，导致系统无法识别是FAT、NTFS、EXT2或EXT3…等格式。在这种情况下，您无法存取这台磁盘且无法使用磁盘中的文档。引发这种问题的原因有很多种，可能是因为感染病毒、，格式化失败、意外关机、停电…等原因所造成的。</code></p><p><code>如果一块磁盘在Windows中显示为RAW格式硬盘，可能（但非全部）的症状是：</code></p><p><code>无效的磁盘媒体格式。中止，重试，失败？ </code></p><p><code>文档系统显示为「RAW」— RAW文档系统 </code></p><p><code>Windows可能会提示是否要格式化磁盘，比如「硬盘未格式化，是否要立即格式化？」 </code></p><p><code>文件名称包含奇怪的字符。 </code></p><p><code>「找不到磁区」讯息</code></p><p>所以需要把U盘格式化为NTFS，方法：</p><p><strong>使用chkdsk命令</strong></p><p>我这里用这个命令就搞好了，</p><p>打开win+R-&gt;cmd，输入chkdsk G:(损坏U盘)/f /r /x</p><p>是否将丢失的链转换为文件(Y/N)? N</p><p>如果这个命令不好使，显示<code>文件系统的类型是RAW，CHKDSK无法供RAW驱动器使用</code>，那就参考一下文章——<a href="https://zhuanlan.zhihu.com/p/393142509">文件系统的类型是RAW，CHKDSK无法供RAW驱动器使用 - 知乎 (zhihu.com)</a> 叭</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好久没有用的u盘，今天插了试了一下，发现U盘无法被读取，于是开始排查原因；&lt;/p&gt;
&lt;p&gt;首先检查驱动，计算机-&amp;gt;管理-&amp;gt;设备管理器查看驱动，驱动没有问题；&lt;/p&gt;
&lt;p&gt;检查磁盘分区，win+R，输入diskmgmt.msc，找到出错的u盘，发现文件系统为RA</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>qtcreator的安装与常见问题</title>
    <link href="https://115jiege.github.io/2023/05/04/qtcreator%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://115jiege.github.io/2023/05/04/qtcreator%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2023-05-04T08:33:56.000Z</published>
    <updated>2023-05-05T00:43:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="qtcreator安装"><a class="header-anchor" href="#qtcreator安装">¶</a>qtcreator安装</h2><p>环境：ubuntu2004</p><p>准备：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure><h3 id="apt-get安装"><a class="header-anchor" href="#apt-get安装">¶</a>apt-get安装</h3><p><a href="https://blog.csdn.net/weixin_48560325/article/details/124373125">参考文章</a></p><p>apt安装会直接安装固定版本的qtcreator</p><h3 id="在线安装"><a class="header-anchor" href="#在线安装">¶</a>在线安装</h3><p><a href="https://www.qt.io/download-qt-installer">Download Qt: Get Qt Online Installer</a></p><ul><li><p>双击在线安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> a+x qt-unified-linux-x64-4.5.2-online.run</span><br><span class="line">./qt-unified-linux-x64-4.5.2-online.run</span><br></pre></td></tr></table></figure></li></ul><p>没有账户的话需要注册</p><p>安装目录(/opt/Qt)</p><ul><li><p>创建快捷方式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /opt/Qt/Tools/QtCreator/bin/qtcreator /usr/bin/qtcreator</span><br></pre></td></tr></table></figure></li><li><p>创建桌面文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /opt/Qt/Tools/QtCreator/share/applications/org.qt-project.qtcreator.desktop /usr/share/applications/org.qt-project.qtcreator.desktop</span><br></pre></td></tr></table></figure></li><li><p>配置构建套件</p><p>配置Qt版本</p><p>自动检测-&gt;qmake在/opt/Qt/5.15.2/gcc_64/bin下</p><p>配置编译器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install gcc</span><br><span class="line">apt install g++</span><br></pre></td></tr></table></figure></li><li><p>修改qmake默认编译器</p><p>到这一步qtcreator的使用基本没什么问题了，但是在命令行输入qmake -v，发现qmake报错</p><p><code>could not exec '/usr/lib/x86\_64-linux-gnu/qt4/bin/qmake': No such file or directory</code></p><p>需要修改qmake默认编译器:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/lib/x86_64-linux-gnu/qt-default/qtchooser/default.conf</span><br></pre></td></tr></table></figure><p>在第一行添加qmake位置<code>/opt/Qt/5.15.2/gcc_64/bin</code><br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p></li></ul><h2 id="qt开发中出现的错误"><a class="header-anchor" href="#qt开发中出现的错误">¶</a>qt开发中出现的错误</h2><h3 id="qt安装错报错："><a class="header-anchor" href="#qt安装错报错：">¶</a>qt安装错报错：</h3><p>./qt-unified-linux-x64-4.5.2-online.run: error while loading shared libraries: libxcb-xinerama.so.0: cannot open shared object file: No such file or directory</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> QT_DEBUG_PLUGINS=1</span><br><span class="line">sudo apt install --reinstall libxcb-xinerama0</span><br></pre></td></tr></table></figure><h3 id="pro文件报错：GL"><a class="header-anchor" href="#pro文件报错：GL">¶</a>pro文件报错：GL</h3><p><code>/opt/Qt/5.15.2/gcc_64/include/QtGui/qopengl.h:141:13: fatal error: GL/gl.h: No such file or directory 141 | # include &lt;GL/gl.h&gt; | ^~~~~~~~~</code></p><p>解决：</p><p>安装缺少的插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mesa-common-dev`</span><br></pre></td></tr></table></figure><h3 id="使用WebEngine编译报错：libQt5WebEngineCore-so"><a class="header-anchor" href="#使用WebEngine编译报错：libQt5WebEngineCore-so">¶</a>使用WebEngine编译报错：<a href="http://libQt5WebEngineCore.so">libQt5WebEngineCore.so</a></h3><p><code>libQt5WebEngineCore.so: .dynsym local symbol at index 3 (&gt;= sh_info of 3) libQt5WebEngineCore.so: .dynsym local symbol at index 4 (&gt;= sh_info of 3) libQt5WebEngineCore.so: .dynsym local symbol at index 5 (&gt;= sh_info of 3) libQt5WebEngineCore.so: .dynsym local symbol at index 6 (&gt;= sh_info of 3)</code></p><p>解决：</p><p>sudo ln -sf /usr/bin/x86_64-linux-gnu-ld.gold /usr/bin/ld</p><h3 id="Qt运行出现-Ignoring-XDG-SESSION-TYPE-wayland-on-Gnome-Use-QT-QPA-PLATFORM-wayland-to-run…解决"><a class="header-anchor" href="#Qt运行出现-Ignoring-XDG-SESSION-TYPE-wayland-on-Gnome-Use-QT-QPA-PLATFORM-wayland-to-run…解决">¶</a>Qt运行出现 Ignoring XDG_SESSION_TYPE=wayland on Gnome. Use QT_QPA_PLATFORM=wayland to run…解决</h3><p>解决：</p><p>vim /etc/gdm3/custom.conf</p><p>WaylandEnable=false</p><h1>reboot</h1><h2 id="qt开发中出现的错误-v2"><a class="header-anchor" href="#qt开发中出现的错误-v2">¶</a>qt开发中出现的错误</h2><h3 id="没有libxcb-xinerama-so-0："><a class="header-anchor" href="#没有libxcb-xinerama-so-0：">¶</a>没有libxcb-xinerama.so.0：</h3><p>错误：<br><code>./qt-unified-linux-x64-4.5.2-online.run: error while loading shared libraries: libxcb-xinerama.so.0: cannot open shared object file: No such file or directory</code><br>解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">export</span> QT_DEBUG_PLUGINS=1</span><br><span class="line">sudo apt install --reinstall libxcb-xinerama0</span><br></pre></td></tr></table></figure><h3 id="没有GL文件"><a class="header-anchor" href="#没有GL文件">¶</a>没有GL文件</h3><p>问题：<br><code>/opt/Qt/5.15.2/gcc_64/include/QtGui/qopengl.h:141:13: fatal error: GL/gl.h: No such file or directory 141 | # include &lt;GL/gl.h&gt; | ^~~~~~~~~</code></p><p>解决：</p><p>安装缺少的插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mesa-common-dev报错：`./qt-unified-linux-x64-4.5.2-online.run: error <span class="keyword">while</span> loading shared libraries: libxcb-xinerama.so.0: cannot open shared object file: No such file or directory`</span><br></pre></td></tr></table></figure><h3 id="使用WebEngine编译报错：libQt5WebEngineCore-so-v2"><a class="header-anchor" href="#使用WebEngine编译报错：libQt5WebEngineCore-so-v2">¶</a>使用WebEngine编译报错：<a href="http://libQt5WebEngineCore.so">libQt5WebEngineCore.so</a></h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">libQt5WebEngineCore</span>.so: .dynsym local symbol at index <span class="number">3</span> (&gt;= sh_info of <span class="number">3</span>)</span><br><span class="line"><span class="attribute">libQt5WebEngineCore</span>.so: .dynsym local symbol at index <span class="number">4</span> (&gt;= sh_info of <span class="number">3</span>)</span><br><span class="line"><span class="attribute">libQt5WebEngineCore</span>.so: .dynsym local symbol at index <span class="number">5</span> (&gt;= sh_info of <span class="number">3</span>)</span><br><span class="line"><span class="attribute">libQt5WebEngineCore</span>.so: .dynsym local symbol at index <span class="number">6</span> (&gt;= sh_info of <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>解决：</p><p>sudo ln -sf /usr/bin/x86_64-linux-gnu-ld.gold /usr/bin/ld</p><h3 id="Qt运行出现-Ignoring-XDG-SESSION-TYPE-wayland-on-Gnome-Use-QT-QPA-PLATFORM-wayland-to-run"><a class="header-anchor" href="#Qt运行出现-Ignoring-XDG-SESSION-TYPE-wayland-on-Gnome-Use-QT-QPA-PLATFORM-wayland-to-run">¶</a>Qt运行出现 Ignoring XDG_SESSION_TYPE=wayland on Gnome. Use QT_QPA_PLATFORM=wayland to run</h3><p>解决：</p><p>vim /etc/gdm3/custom.conf</p><p>WaylandEnable=false</p><p>reboot</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;qtcreator安装&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#qtcreator安装&quot;&gt;¶&lt;/a&gt;qtcreator安装&lt;/h2&gt;
&lt;p&gt;环境：ubuntu2004&lt;/p&gt;
&lt;p&gt;准备：&lt;/p&gt;
&lt;figure class=&quot;highl</summary>
      
    
    
    
    <category term="研发" scheme="https://115jiege.github.io/categories/%E7%A0%94%E5%8F%91/"/>
    
    
    <category term="qt开发" scheme="https://115jiege.github.io/tags/qt%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Vector</title>
    <link href="https://115jiege.github.io/2023/04/24/C++%20vector%20%E5%AD%A6%E4%B9%A0/"/>
    <id>https://115jiege.github.io/2023/04/24/C++%20vector%20%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-04-24T01:10:33.000Z</published>
    <updated>2023-05-04T03:20:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Vector（C++）</h1><p>Vector是一个封装了<strong>动态</strong>大小数组的<strong>顺序</strong>*容器，即一个可以存放任意类型的动态数组。</p><h2 id="容器特性"><a class="header-anchor" href="#容器特性">¶</a>容器特性</h2><h3 id="顺序存储"><a class="header-anchor" href="#顺序存储">¶</a>顺序存储</h3><p>顺序容器中的元素线性排列，通过元素在序列中的位置访问元素。</p><h3 id="动态数组"><a class="header-anchor" href="#动态数组">¶</a>动态数组</h3><p>支持对序列中的元素进行快速访问，在序列末尾快速增删元素。</p><h3 id="感知内存分配器的Alloctor-aware"><a class="header-anchor" href="#感知内存分配器的Alloctor-aware">¶</a>感知内存分配器的Alloctor-aware</h3><p><strong>内存分配器（Memory Alloctor）</strong></p><p>通常使用的内存分配器,即malloc/free函数并非系统提供的，而是C标准库提供的。也被称为动态内存分配器。</p><p><em><code>目的</code></em>：平衡内存分配的性能和提高内存使用的效率。</p><p><em><code>内存不足的原因</code></em>：程序内的bug；系统内存不足；内存分配浪费大量空间，导致大量内存碎片。</p><p><strong>Alloctor Aware Container</strong></p><p>所有的STL容器，都保存一个或默认，或由用户提供的allocator的实例，用来提供对象内存分配和构造的方法（除了std::array），这样的容器，被称作Allocator Aware Container。</p><p>Allocator Aware Container的拷贝：</p><p>调用被拷贝对象的std::allocator_traits<TAllocator>::select_on_container_copy_construction()函数，按情况拷贝，如果没有，就直接返回容器本体。</TAllocator></p><p>拷贝对象调用静态的propagate_on_container_copy_assignment，获取被拷贝容器的allocator副本，避免出现直接拷贝容器的bug。</p><p>每一个std::allocator_traits<Tallocator>都拥有三个别名类型：propagate_on_container_copy_assignment， propagate_on_container_move_assignment 和 propagate_on_container_swap，他们都是true_type或false_type的别名，这三个属性除非用户自定义，否则默认是false_type，也即allocator在容器拷贝、移动或交换的时候不能直接进行allocator所分配的内存的所有权的转移<br>对于拷贝赋值（copy assignment），需要运行时判断容器的propagate_on_copy_assignement trait，如果为true，并且两个容器不相等，那么lhs的容器应该先析构所有内存，再拷贝allocator，最后执行对象的拷贝。</Tallocator></p><p>容器在移动赋值（move assignment）的时候需要考虑如下情况，来正确操作容器的allocator:</p><ul><li>propagate_on_container_move_assignemnt 为 true_type<br>lhs拷贝容器使用alloctor释放分配内存，rhs被拷贝者alloctor所有权转移，内存的所有权从rhs转移到lhs。</li><li>propagate_on_container_move_assignemnt 为 false_type，但两个allocator相等<br>lhs拷贝容器使用alloctor释放分配内存，不交换所有权。</li><li>propagete_on_container_move_assignment 为 false_type，两个allocator<br>不等无法执行内存级别的移动，只能进行对象级别的移动。</li></ul><h2 id="函数实现"><a class="header-anchor" href="#函数实现">¶</a>函数实现</h2><h3 id="构造函数"><a class="header-anchor" href="#构造函数">¶</a>构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>() <span class="comment">//创建一个空vector</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">int</span> nSize) <span class="comment">//创建一个vector,元素个数为nSize</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">int</span> nSize,<span class="type">const</span> t&amp; t) <span class="comment">//创建一个vector，元素个数为nSize,且值均为t</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&amp;) <span class="comment">//复制构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(begin,end) <span class="comment">//复制[begin,end)区间内另一个数组的元素到vector中</span></span><br></pre></td></tr></table></figure><h3 id="增加函数"><a class="header-anchor" href="#增加函数">¶</a>增加函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="comment">//向量尾部增加一个元素X</span></span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it,<span class="type">const</span> T&amp; x)</span> <span class="comment">//向量中迭代器指向元素前增加一个元素x</span></span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it,<span class="type">int</span> n,<span class="type">const</span> T&amp; x)</span> <span class="comment">//向量中迭代器指向元素前增加n个相同的元素x</span></span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it,const_iterator first,const_iterator last)</span> <span class="comment">//向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</span></span></span><br></pre></td></tr></table></figure><h3 id="删除函数"><a class="header-anchor" href="#删除函数">¶</a>删除函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span> <span class="comment">//删除向量中迭代器指向元素</span></span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first,iterator last)</span> <span class="comment">//删除向量中[first,last)中元素</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> <span class="comment">//删除向量中最后一个元素</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> <span class="comment">//清空向量中所有元素</span></span></span><br></pre></td></tr></table></figure><h3 id="遍历函数"><a class="header-anchor" href="#遍历函数">¶</a>遍历函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">reference <span class="title">at</span><span class="params">(<span class="type">int</span> pos)</span> <span class="comment">//返回pos位置元素的引用</span></span></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> <span class="comment">//返回首元素的引用</span></span></span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> <span class="comment">//返回尾元素的引用</span></span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="comment">//返回向量头指针，指向第一个元素</span></span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="comment">//返回向量尾指针，指向向量最后一个元素的下一个位置</span></span></span><br><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="comment">//反向迭代器，指向最后一个元素</span></span></span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="comment">//反向迭代器，指向第一个元素之前的位置</span></span></span><br></pre></td></tr></table></figure><h3 id="判空"><a class="header-anchor" href="#判空">¶</a>判空</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//判断向量是否为空，若为空，则向量中无元素</span></span></span><br></pre></td></tr></table></figure><h3 id="大小函数"><a class="header-anchor" href="#大小函数">¶</a>大小函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//返回向量中元素的个数</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//返回当前向量所能容纳的最大元素值</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> max\_<span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//返回最大可允许的vector元素数量值</span></span></span><br></pre></td></tr></table></figure><h3 id="7-其他函数"><a class="header-anchor" href="#7-其他函数">¶</a>7.其他函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&amp;)</span> <span class="comment">//交换两个同类型向量的数据</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">int</span> n,<span class="type">const</span> T&amp; x)</span> <span class="comment">//设置向量中前n个元素的值为x</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">const</span>\_iterator first,<span class="type">const</span>\_iterator last)</span> <span class="comment">//向量中[first,last)中元素设置成当前向量元素</span></span></span><br></pre></td></tr></table></figure><h2 id="使用"><a class="header-anchor" href="#使用">¶</a>使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt; vector&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><ol><li>Vector&lt;类型&gt;标识符</li><li>Vector&lt;类型&gt;标识符(最大容量)</li><li>Vector&lt;类型&gt;标识符(最大容量,初始所有值)</li><li>Int i[5]={1,2,3,4,5}<br>Vector&lt;类型&gt;vi(I,i+2);//得到i索引值为3以后的值</li><li>Vector&lt; vector&lt; int&gt; &gt;v;</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Vector（C++）&lt;/h1&gt;
&lt;p&gt;Vector是一个封装了&lt;strong&gt;动态&lt;/strong&gt;大小数组的&lt;strong&gt;顺序&lt;/strong&gt;*容器，即一个可以存放任意类型的动态数组。&lt;/p&gt;
&lt;h2 id=&quot;容器特性&quot;&gt;&lt;a class=&quot;header-anch</summary>
      
    
    
    
    <category term="研发" scheme="https://115jiege.github.io/categories/%E7%A0%94%E5%8F%91/"/>
    
    
    <category term="c++" scheme="https://115jiege.github.io/tags/c/"/>
    
    <category term="Vector" scheme="https://115jiege.github.io/tags/Vector/"/>
    
  </entry>
  
  <entry>
    <title>VMware错误</title>
    <link href="https://115jiege.github.io/2023/04/23/VMware%E9%94%99%E8%AF%AF/"/>
    <id>https://115jiege.github.io/2023/04/23/VMware%E9%94%99%E8%AF%AF/</id>
    <published>2023-04-23T05:56:14.000Z</published>
    <updated>2023-05-05T00:45:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下在使用VMware workstation的过程中出现的问题。</p><h2 id="虚拟机正在使用"><a class="header-anchor" href="#虚拟机正在使用">¶</a>虚拟机正在使用</h2><p>VMware虚拟机由于一些原因卡死，用Windows任务管理器关闭VMware也关不掉，然后重启电脑，再次打开虚拟机报错。</p><p>错误信息：</p><p><code>该虚拟机似乎正在使用中。如果该虚拟机未在使用，请按“获取所有权(T)”按钮获取它的所有权。否则，请按“取消(C)”按钮以防损坏。</code></p><p>解决方法：</p><p>打开虚拟机所在文件夹，删除.lck结尾的文件夹(不放心的话可以转为备份文件)；重启VMware，即可打开虚拟机;</p><p>分析原因：</p><p>当运行一个“虚拟系统”时，为防止该系统被另外一个VMware程序打开，导致数据被修改或损坏，VMware会自动在该“虚拟系统”所在的文件夹下，生成三个锁定文件（虚拟系统锁定，虚拟磁盘锁定，虚拟内存锁定），分别为：”.vmx.lck”,”.vmdk.lck”,”.vmem.lck”；</p><p>在正常关机的情况下，这些文件会自动删除，当非正常关机的情况下，这些文件就不会自动删除，这就导致了再次打开Ubuntu的时候由于锁的存在而打不开。</p><h2 id="未能连接到虚拟机"><a class="header-anchor" href="#未能连接到虚拟机">¶</a>未能连接到虚拟机</h2><p>强制关闭虚拟机，再次打开时报错。</p><p>错误信息：</p><p><code>未能将管道连接到虚拟机: 所有的管道范例都在使用中。</code></p><p>解决方法：</p><p>打开任务管理器-&gt;详细信息：结束所有vm开头的任务(vmnet不用关);</p><p>分析原因：</p><p>有些相关进程没有关掉，导致管道未释放。</p><h2 id="网络连接失败"><a class="header-anchor" href="#网络连接失败">¶</a>网络连接失败</h2><p>在任务管理器中不小心关掉了vmnat.ext,vmnetdhcp.exe等VMware虚拟网络进程，导致虚拟机网络连接失败。</p><p>解决方法：</p><p>关闭虚拟机，编辑-&gt;虚拟网络编辑器-&gt;还原默认设置;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一下在使用VMware workstation的过程中出现的问题。&lt;/p&gt;
&lt;h2 id=&quot;虚拟机正在使用&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#虚拟机正在使用&quot;&gt;¶&lt;/a&gt;虚拟机正在使用&lt;/h2&gt;
&lt;p&gt;VMware虚拟机由于一些原因卡死，</summary>
      
    
    
    
    
    <category term="VMware" scheme="https://115jiege.github.io/tags/VMware/"/>
    
  </entry>
  
  <entry>
    <title>VScode通过SSH远程连接主机失败</title>
    <link href="https://115jiege.github.io/2023/04/23/VScode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5/"/>
    <id>https://115jiege.github.io/2023/04/23/VScode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5/</id>
    <published>2023-04-23T05:56:14.000Z</published>
    <updated>2023-05-05T00:45:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>报错信息：</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-16-14-14-42-image.png" alt></p><p>原因：</p><p>我这里是之前安装过一个ubuntu2204，VMware分配了ip，并且使用ssh连接过这个ip。删除虚拟机后，再次安装的ubuntu又恰好被分配了此ip，但用户名或密码与之前不同。这使得本地记录的信息和现有本地记录的服务器信息和现有的产生了冲突，连接失败。</p><p>解决：</p><p><img src="/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-16-14-19-26-image.png" alt></p><p>把有冲突的本地记录删掉就好了，找到C:\Users\Administrator\ssh\known_hosts文件，删除冲突ip的信息。然后重新连接。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;报错信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-05-16-14-14-42-image.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;原</summary>
      
    
    
    
    <category term="杂七杂八" scheme="https://115jiege.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="VMware" scheme="https://115jiege.github.io/tags/VMware/"/>
    
  </entry>
  
  <entry>
    <title>java中发送UDP数据包</title>
    <link href="https://115jiege.github.io/2023/04/23/%E5%8F%91%E9%80%81UDP%E6%95%B0%E6%8D%AE%E5%8C%85(java)/"/>
    <id>https://115jiege.github.io/2023/04/23/%E5%8F%91%E9%80%81UDP%E6%95%B0%E6%8D%AE%E5%8C%85(java)/</id>
    <published>2023-04-23T02:20:40.000Z</published>
    <updated>2023-04-23T02:23:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UDP发送数据"><a class="header-anchor" href="#UDP发送数据">¶</a>UDP发送数据</h2><h3 id="步骤"><a class="header-anchor" href="#步骤">¶</a>步骤</h3><ol><li>创建发送端socket对象</li><li>创建数据并打包</li><li>调用socket发送方法发送数据包</li><li>释放资源</li></ol><h3 id="方法"><a class="header-anchor" href="#方法">¶</a>方法</h3><p><strong>类 DatagramSocket</strong></p><p>此类表示用来<strong>发送和接收数据报包</strong>的套接字</p><p><strong>类 DatagramPacket</strong></p><p>此类表示数据报包</p><p>public void <strong>send</strong>(DatagramPacket p)：</p><p>从套接字发送数据报包。DatagramPacket 包含的信息指示：将要发送的数据、其长度、远程主机的 IP 地址和远程主机的端口号。</p><p>public <strong>DatagramPacket</strong>(byte[] buf,int length,InetAddress address,int port)</p><p>构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。</p><h3 id="步骤-v2"><a class="header-anchor" href="#步骤-v2">¶</a>步骤</h3><ol><li>创建socket对象</li><li>创建数据包（接受容器）</li><li>调用socket接受方法接受数据包</li><li>解析数据</li><li>释放资源</li></ol><h3 id="方法-v2"><a class="header-anchor" href="#方法-v2">¶</a>方法</h3><p>public <strong>DatagramSocket</strong>(int port)</p><p>创建数据报套接字并绑定到指定端口</p><p><strong>DatagramPacket</strong>(byte[] buf, int length)</p><p>构造长度为length的数据包</p><p>public void <strong>receive</strong>(DatagramPacket p)</p><p>从套接字接受数据包</p><p>public InetAddress <strong>getAddress</strong>()</p><p>返回某台机器的 IP地址，此数据报将要发往该机器或者是从该机器接收到的。</p><p>public byte[] <strong>getData</strong>()</p><p>返回数据缓冲区。</p><p>public int <strong>getLength()</strong></p><p>返回将要发送或接收到的数据的长度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;UDP发送数据&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#UDP发送数据&quot;&gt;¶&lt;/a&gt;UDP发送数据&lt;/h2&gt;
&lt;h3 id=&quot;步骤&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#步骤&quot;&gt;¶&lt;/a&gt;步骤&lt;/h3&gt;
&lt;ol</summary>
      
    
    
    
    <category term="研发" scheme="https://115jiege.github.io/categories/%E7%A0%94%E5%8F%91/"/>
    
    
    <category term="UDP数据报" scheme="https://115jiege.github.io/tags/UDP%E6%95%B0%E6%8D%AE%E6%8A%A5/"/>
    
    <category term="java" scheme="https://115jiege.github.io/tags/java/"/>
    
    <category term="android开发" scheme="https://115jiege.github.io/tags/android%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>gmssl各平台编译</title>
    <link href="https://115jiege.github.io/2023/04/21/gmssl%E5%90%84%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"/>
    <id>https://115jiege.github.io/2023/04/21/gmssl%E5%90%84%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/</id>
    <published>2023-04-21T09:28:54.000Z</published>
    <updated>2023-04-23T02:13:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1>gmssl各平台编译</h1><p>官址<a href>click here</a></p><p>我的项目<a href="https://github.com/115Jiege/Gmssl.git">click here</a></p><h2 id="linux版编译"><a class="header-anchor" href="#linux版编译">¶</a>linux版编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./config --prefix=/usr/local --openssldir=/usr/local</span><br><span class="line">sudo make &amp;&amp; make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><h2 id="Windows版编译"><a class="header-anchor" href="#Windows版编译">¶</a>Windows版编译</h2><p>使用</p><p>下载perl工具</p><p>[click here](<a href="https://strawberryperl.com/">Strawberry Perl for Windows</a>)</p><p>以管理员身份打开<code>x86 Native Tools Command Prompt for VS 2019</code> cd gmssl目录 运行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">perl Configure VC-WIN32</span><br><span class="line">nmake </span><br><span class="line">nmake install</span><br></pre></td></tr></table></figure><h2 id="安卓版编译"><a class="header-anchor" href="#安卓版编译">¶</a>安卓版编译</h2><h3 id="编译环境"><a class="header-anchor" href="#编译环境">¶</a>编译环境</h3><p>os: mint 20.1</p><p>(5.4.0-58-generic #64-Ubuntu SMP Wed Dec 9 08:16:25 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux)</p><p>NDK: android-r14b</p><p>Android-abi: android-21</p><h3 id="初步准备"><a class="header-anchor" href="#初步准备">¶</a>初步准备</h3><h4 id="NDK"><a class="header-anchor" href="#NDK">¶</a>NDK</h4><p>选用android-ndk-r14b，可以在<a href="https://www.androiddevtools.cn/">此处</a>下载合适版本;</p><h4 id="环境变量"><a class="header-anchor" href="#环境变量">¶</a>环境变量</h4><p>将android-ndk-r14b所在位置添加到系统环境变量中;</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vim <span class="regexp">/etc/</span>profile</span><br><span class="line"><span class="comment">#编辑文件</span></span><br><span class="line">export ANROID_NDK_PATH=<span class="regexp">/usr/</span>local/android-ndk-r14b</span><br><span class="line"><span class="comment">#:wq保存</span></span><br><span class="line">source <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure><h3 id="编译合适版本"><a class="header-anchor" href="#编译合适版本">¶</a>编译合适版本</h3><p>编写sh文件，在linux系统上使用ndk进行交叉编译</p><h4 id="x86"><a class="header-anchor" href="#x86">¶</a>x86</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">ANDROID_PATH</span>=<span class="variable">$ANDROID_NDK_PATH</span></span><br><span class="line"><span class="attribute">PLATFORM_VERSION</span>=21</span><br><span class="line"></span><br><span class="line"><span class="attribute">MAKE_TOOLCHAIN</span>=<span class="variable">$ANDROID_PATH</span>/build/tools/make-standalone-toolchain.sh</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOLCHAIN_PATH</span>=<span class="variable">$ANDROID_PATH</span>/x86</span><br><span class="line"><span class="variable">$MAKE_TOOLCHAIN</span> <span class="attribute">--arch</span>=x86 <span class="attribute">--platform</span>=android-$PLATFORM_VERSION <span class="attribute">--install-dir</span>=<span class="variable">$TOOLCHAIN_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">CROSS_SYSROOT</span>=<span class="variable">$TOOLCHAIN_PATH</span>/sysroot</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOL_BASENAME</span>=<span class="variable">$TOOLCHAIN_PATH</span>/bin</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$CROSS_SYSROOT</span>:$PATH</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$TOOL_BASENAME</span>:$PATH</span><br><span class="line"></span><br><span class="line">./Configure <span class="attribute">--prefix</span>=/usr/local <span class="attribute">--cross-compile-prefix</span>=i686-linux-android- no-asm no-async shared android-x86</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h4 id="x86-64"><a class="header-anchor" href="#x86-64">¶</a>x86_64</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">ANDROID_PATH</span>=<span class="variable">$ANDROID_NDK_PATH</span></span><br><span class="line"><span class="attribute">PLATFORM_VERSION</span>=21</span><br><span class="line"></span><br><span class="line"><span class="attribute">MAKE_TOOLCHAIN</span>=<span class="variable">$ANDROID_PATH</span>/build/tools/make-standalone-toolchain.sh</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOLCHAIN_PATH</span>=<span class="variable">$ANDROID_PATH</span>/x86_64</span><br><span class="line"><span class="variable">$MAKE_TOOLCHAIN</span> <span class="attribute">--arch</span>=x86_64 <span class="attribute">--platform</span>=android-$PLATFORM_VERSION <span class="attribute">--install-dir</span>=<span class="variable">$TOOLCHAIN_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">CROSS_SYSROOT</span>=<span class="variable">$TOOLCHAIN_PATH</span>/sysroot</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOL_BASENAME</span>=<span class="variable">$TOOLCHAIN_PATH</span>/bin</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$CROSS_SYSROOT</span>:$PATH</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$TOOL_BASENAME</span>:$PATH</span><br><span class="line"></span><br><span class="line">./Configure <span class="attribute">--prefix</span>=/usr/local <span class="attribute">--cross-compile-prefix</span>=x86_64-linux-android- no-asm no-async shared android64</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h4 id="arm64-v8a"><a class="header-anchor" href="#arm64-v8a">¶</a>arm64-v8a</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">ANDROID_PATH</span>=<span class="variable">$ANDROID_NDK_PATH</span></span><br><span class="line"><span class="attribute">PLATFORM_VERSION</span>=21</span><br><span class="line"></span><br><span class="line"><span class="attribute">MAKE_TOOLCHAIN</span>=<span class="variable">$ANDROID_PATH</span>/build/tools/make-standalone-toolchain.sh</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOLCHAIN_PATH</span>=<span class="variable">$ANDROID_PATH</span>/aarch64-linux-android</span><br><span class="line"><span class="variable">$MAKE_TOOLCHAIN</span> <span class="attribute">--arch</span>=arm64 <span class="attribute">--platform</span>=android-$PLATFORM_VERSION <span class="attribute">--install-dir</span>=<span class="variable">$TOOLCHAIN_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">CROSS_SYSROOT</span>=<span class="variable">$TOOLCHAIN_PATH</span>/sysroot</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOL_BASENAME</span>=<span class="variable">$TOOLCHAIN_PATH</span>/bin</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$CROSS_SYSROOT</span>:$PATH</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$TOOL_BASENAME</span>:$PATH</span><br><span class="line"></span><br><span class="line">./Configure <span class="attribute">--prefix</span>=/usr/local <span class="attribute">--cross-compile-prefix</span>=aarch64-linux-android- no-asm no-async shared android64-aarch64</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h4 id="arm-v7a"><a class="header-anchor" href="#arm-v7a">¶</a>arm-v7a</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">ANDROID_PATH</span>=<span class="variable">$ANDROID_NDK_PATH</span></span><br><span class="line"><span class="attribute">PLATFORM_VERSION</span>=21</span><br><span class="line"></span><br><span class="line"><span class="attribute">MAKE_TOOLCHAIN</span>=<span class="variable">$ANDROID_PATH</span>/build/tools/make-standalone-toolchain.sh</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOLCHAIN_PATH</span>=<span class="variable">$ANDROID_PATH</span>/arm-linux-android</span><br><span class="line"><span class="variable">$MAKE_TOOLCHAIN</span> <span class="attribute">--arch</span>=arm <span class="attribute">--platform</span>=android-$PLATFORM_VERSION <span class="attribute">--install-dir</span>=<span class="variable">$TOOLCHAIN_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">CROSS_SYSROOT</span>=<span class="variable">$TOOLCHAIN_PATH</span>/sysroot</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TOOL_BASENAME</span>=<span class="variable">$TOOLCHAIN_PATH</span>/bin</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$CROSS_SYSROOT</span>:$PATH</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$TOOL_BASENAME</span>:$PATH</span><br><span class="line"></span><br><span class="line">./Configure <span class="attribute">--prefix</span>=/usr/local <span class="attribute">--cross-compile-prefix</span>=arm-linux-androideabi- no-asm no-async shared android-armeabi</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="查看so库信息"><a class="header-anchor" href="#查看so库信息">¶</a>查看so库信息</h3><p>编译后通过</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">readelf</span> -h libcrypto.so.<span class="number">1</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure><p>查看系统架构等信息</p><p>例如：</p><p>Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00<br>类别:                              ELF64<br>数据:                              2 补码，小端序 (little endian)<br>Version:                           1 (current)<br>OS/ABI:                            UNIX - System V<br>ABI 版本:                          0<br>类型:                              DYN (共享目标文件)<br>系统架构:                          AArch64<br>版本:                              0x1<br>入口点地址：               0x78240<br>程序头起点：          64 (bytes into file)<br>Start of section headers:          2968008 (bytes into file)<br>标志：             0x0<br>Size of this header:               64 (bytes)<br>Size of program headers:           56 (bytes)<br>Number of program headers:         6<br>Size of section headers:           64 (bytes)<br>Number of section headers:         32<br>Section header string table index: 29</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;gmssl各平台编译&lt;/h1&gt;
&lt;p&gt;官址&lt;a href&gt;click here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的项目&lt;a href=&quot;https://github.com/115Jiege/Gmssl.git&quot;&gt;click here&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;linux版</summary>
      
    
    
    
    <category term="杂七杂八" scheme="https://115jiege.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="gmssl" scheme="https://115jiege.github.io/tags/gmssl/"/>
    
  </entry>
  
  <entry>
    <title>sodium各平台编译</title>
    <link href="https://115jiege.github.io/2023/04/21/libsodium.so%E5%90%84%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"/>
    <id>https://115jiege.github.io/2023/04/21/libsodium.so%E5%90%84%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/</id>
    <published>2023-04-21T09:10:07.000Z</published>
    <updated>2023-04-23T02:13:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1>sodium各平台编译</h1><h2 id="linux版编译-v2"><a class="header-anchor" href="#linux版编译-v2">¶</a>linux版编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.libsodium.org/libsodium/releases/LATEST.tar.gz</span><br><span class="line">tar -zxvf LATEST.tar.gz</span><br><span class="line"><span class="built_in">cd</span> libsodium-stable</span><br><span class="line"> ./configure</span><br><span class="line">make &amp;&amp; make check</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><h2 id="安卓版编译-v2"><a class="header-anchor" href="#安卓版编译-v2">¶</a>安卓版编译</h2><h3 id="交叉编译环境"><a class="header-anchor" href="#交叉编译环境">¶</a>交叉编译环境:</h3><p>打开终端，apt安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt-get install build-enssitial</span><br><span class="line">apt-get install clang</span><br><span class="line">apt-get install libtool</span><br><span class="line">apt-get install autoconf</span><br><span class="line">apt-get install automake</span><br></pre></td></tr></table></figure><h3 id="设置环境变量"><a class="header-anchor" href="#设置环境变量">¶</a>设置环境变量</h3><p>sudo vim /etc/profile<br>添加:<br>export ANDROID_NDK_HOME=/home/Android/Sdk/ndk/23.1.7779620<br>export PATH=$PATH:$ANDROID_NDK_HOME</p><p>source  /etc/profile</p><p>](<a href="https://github.com/jedisct1/libsodium.git">https://github.com/jedisct1/libsodium.git</a>)</p><h3 id="生成configure文件"><a class="header-anchor" href="#生成configure文件">¶</a>生成configure文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> libsodium-stable</span><br><span class="line">./autogen.sh -s</span><br><span class="line"><span class="comment">#可以先用./autogen.sh -h查看使用说明;</span></span><br></pre></td></tr></table></figure><h3 id="选择合适的版本编译"><a class="header-anchor" href="#选择合适的版本编译">¶</a>选择合适的版本编译</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp ./dist-build/android-build<span class="selector-class">.sh</span> android-build<span class="selector-class">.sh</span></span><br><span class="line">cp ./dist-build/android-armv8-<span class="selector-tag">a</span><span class="selector-class">.sh</span> android-armv8-<span class="selector-tag">a</span><span class="selector-class">.sh</span></span><br><span class="line">chmod a+x android-build<span class="selector-class">.sh</span></span><br><span class="line">chmod a+x android-armv8-<span class="selector-tag">a</span><span class="selector-class">.sh</span></span><br><span class="line">./android-armv8-<span class="selector-tag">a</span>.sh</span><br></pre></td></tr></table></figure><p>如果编译过程中报错，需要clean，然后重新编译<br>make distclean</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;sodium各平台编译&lt;/h1&gt;
&lt;h2 id=&quot;linux版编译-v2&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#linux版编译-v2&quot;&gt;¶&lt;/a&gt;linux版编译&lt;/h2&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;ta</summary>
      
    
    
    
    <category term="杂七杂八" scheme="https://115jiege.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>关于线程与进程的Windows-api</title>
    <link href="https://115jiege.github.io/2023/04/18/Windows%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://115jiege.github.io/2023/04/18/Windows%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2023-04-18T06:34:21.000Z</published>
    <updated>2023-04-23T02:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些常用的Windows-api"><a class="header-anchor" href="#一些常用的Windows-api">¶</a>一些常用的Windows-api</h2><h3 id="WSAGetLastError"><a class="header-anchor" href="#WSAGetLastError">¶</a>WSAGetLastError</h3><h4 id="用途"><a class="header-anchor" href="#用途">¶</a>用途</h4><p>返回该线程进行的上一次 Windows Sockets API 函数调用时的错误代码</p><h4 id="函数原型"><a class="header-anchor" href="#函数原型">¶</a>函数原型</h4><p>int WSAGetLastError ( );</p><h4 id="注意"><a class="header-anchor" href="#注意">¶</a>注意</h4><ol><li>当特定 Windows 套接字函数指示发生错误时，应立即调用<strong>WSAGetLastError</strong>以检索扩展错误代码。</li><li>如果函数调用的返回值指示错误或其他相关数据是在错误代码中返回的，则应立即调用 <strong>WSAGetLastError</strong> ，否则，某些函数可能会将最后一个扩展错误代码重置为 0</li><li>使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winsock/nf-winsock-wsasetlasterror">WSASetLastError</a> 函数重置扩展错误代码，并将 <em>iError</em> 参数设置为零。 使用 <em>SO_ERROR optname</em> 参数调用的 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winsock/nf-winsock-getsockopt">getsockopt</a> 函数也会将扩展错误代码重置为零。</li><li>不应使用 <strong>WSAGetLastError</strong> 函数在收到异步消息时检查扩展错误值。 在这种情况下，扩展错误值在消息的 <em>lParam</em> 参数中传递，这可能与 <strong>WSAGetLastError</strong> 返回的值不同。</li><li><strong>WSAGetLastError</strong> 函数是 Winsock 2.2 DLL 中唯一可在 <strong>WSAStartup</strong> 失败时调用的函数之一。</li></ol><h4 id="要求"><a class="header-anchor" href="#要求">¶</a>要求</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>最低支持的客户端</td><td>windows8.1 Windows Vista</td></tr><tr><td>最低支持的服务端</td><td>Windows server 2003</td></tr><tr><td>标头</td><td>winsock.h</td></tr><tr><td>Library</td><td>Ws2_32.lib</td></tr><tr><td>DLL</td><td>Ws2_32.dll</td></tr></tbody></table><h3 id="beginthread、beginthreadex"><a class="header-anchor" href="#beginthread、beginthreadex">¶</a>beginthread、beginthreadex</h3><h4 id="用途-v2"><a class="header-anchor" href="#用途-v2">¶</a>用途</h4><p>用于创建线程</p><h4 id="语法"><a class="header-anchor" href="#语法">¶</a>语法</h4><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef void     (<span class="variable">__cdecl</span>*   <span class="variable">_beginthread_proc_type</span>  )(void*);</span><br><span class="line">typedef unsigned (<span class="variable">__stdcall</span>* <span class="variable">_beginthreadex_proc_type</span>)(void*);</span><br><span class="line"></span><br><span class="line"><span class="variable">_ACRTIMP</span> uintptr_t <span class="variable">__cdecl</span> <span class="variable">_beginthread</span>(</span><br><span class="line">    <span class="variable">_In_</span>     <span class="variable">_beginthread_proc_type</span> <span class="variable">_StartAddress</span>,</span><br><span class="line">    <span class="variable">_In_</span>     unsigned               <span class="variable">_StackSize</span>,</span><br><span class="line">    <span class="variable">_In_opt_</span> void*                  <span class="variable">_ArgList</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="variable">_ACRTIMP</span> uintptr_t <span class="variable">__cdecl</span> <span class="variable">_beginthreadex</span>(</span><br><span class="line">    <span class="variable">_In_opt_</span>  void*                    <span class="variable">_Security</span>,</span><br><span class="line">    <span class="variable">_In_</span>      unsigned                 <span class="variable">_StackSize</span>,</span><br><span class="line">    <span class="variable">_In_</span>      <span class="variable">_beginthreadex_proc_type</span> <span class="variable">_StartAddress</span>,</span><br><span class="line">    <span class="variable">_In_opt_</span>  void*                    <span class="variable">_ArgList</span>,</span><br><span class="line">    <span class="variable">_In_</span>      unsigned                 <span class="variable">_InitFlag</span>,</span><br><span class="line">    <span class="variable">_Out_opt_</span> unsigned*                <span class="variable">_ThrdAddr</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h4 id="参数"><a class="header-anchor" href="#参数">¶</a>参数</h4><p><em><code>Security</code></em></p><p>指向 <a href="https://learn.microsoft.com/zh-cn/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)"><code>SECURITY_ATTRIBUTES</code></a> 结构的指针，此结构确定返回的句柄是否由子进程继承。 <code>Security</code>为<code>NULL</code>表示默认安全性，无法继承句柄。</p><p><em><code>StackSize</code></em></p><p>新线程的堆栈大小，一般默认为0</p><p><em><code>StartAddress</code></em></p><p>启动开始执行新线程的例程的地址，对于 <strong><code>_beginthread</code></strong>，调用约定是 <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/cdecl?view=msvc-170"><code>__cdecl</code></a> （本机代码) ，或者是 <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/clrcall?view=msvc-170"><code>__clrcall</code></a> （托管代码) 。 对于 <strong><code>_beginthreadex</code></strong>，调用约定是 <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/stdcall?view=msvc-170"><code>__stdcall</code></a> （本机代码) ，或者是 <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/clrcall?view=msvc-170"><code>__clrcall</code></a> （托管代码) 。</p><p><em><code>ArgList</code></em></p><p>要传递到新线程的参数列表or <code>NULL</code></p><p><em><code>InitFlag</code></em></p><p>控制新线程的初始状态的标志。</p><p>设置为 0 则立即运行，</p><p>设置为 <code>CREATE_SUSPENDED</code>则创建后挂起,使用 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread"><code>ResumeThread</code></a> 来执行此线程。</p><p><em><code>ThrdAddr</code></em></p><p>存放线程标识符，它是CreateThread函数中的线程ID</p><h4 id="区别"><a class="header-anchor" href="#区别">¶</a>区别</h4><ol><li>参数形式不同</li><li><code>ex</code>能够创建悬挂状态线程，在nt中能够指定级别，能够被<code>thrdaddr</code>访问，因为它有了<code>id</code>。</li><li><code>ex</code>使用<code>__stdcall</code>调用格式，必须返回<code>exit code</code>。</li><li><code>ex</code>返回0代表失败，原先的返回-1L。</li><li><code>ex</code>创建的必须用ex销毁</li></ol><h3 id="endthread、endthreadex"><a class="header-anchor" href="#endthread、endthreadex">¶</a>endthread、endthreadex</h3><h4 id="用途-v3"><a class="header-anchor" href="#用途-v3">¶</a>用途</h4><p>用于结束线程终止线程；<strong><code>_endthread</code></strong> 终止由 <strong><code>_beginthread</code></strong> 创建的线程，<strong><code>_endthreadex</code></strong> 终止由 <strong><code>_beginthreadex</code></strong> 创建的线程。</p><p>语法</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*释放线程空间、释放线程TLS空间、调用ExiteThread结束线程。*/</span></span><br><span class="line"><span class="variable">_ACRTIMP</span> void <span class="variable">__cdecl</span> <span class="variable">_endthread</span>(void);</span><br><span class="line"></span><br><span class="line"><span class="comment">// retval:设定的线程结束码，与ExiteThread函数的参数功能一样，</span></span><br><span class="line"><span class="comment">//其实这个函数释放线程TLS空间，再调用ExiteThread函数，但没有释放线程空间。</span></span><br><span class="line"><span class="variable">_ACRTIMP</span> void <span class="variable">__cdecl</span> <span class="variable">_endthreadex</span>(</span><br><span class="line">    <span class="variable">_In_</span> unsigned <span class="variable">_ReturnCode</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h4 id="参数-v2"><a class="header-anchor" href="#参数-v2">¶</a>参数</h4><p><em><code>retval</code></em>  线程退出代码</p><h4 id="注意-v2"><a class="header-anchor" href="#注意-v2">¶</a>注意</h4><ol><li>当线程从作为 <strong><code>_endthread</code></strong> 或 <strong><code>_endthreadex</code></strong> 参数传递的例程中返回时，会自动调用 <strong><code>_beginthread</code></strong> 或 <strong><code>_beginthreadex</code></strong>。这有助于适当恢复为线程分配的资源。</li><li><strong><code>_endthread</code></strong> 会自动关闭线程句柄。</li><li><strong><code>_endthreadex</code></strong> 不会关闭线程句柄，所以使用 <strong><code>_beginthreadex</code></strong> 和 <strong><code>_endthreadex</code></strong> 时，必须通过调用 Win32 <code>CloseHandle</code> API 来关闭线程句柄。</li><li>对于与 Libcmt.lib 链接的可执行文件，请不要调用 Win32 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread"><code>ExitThread</code></a> API；这将阻止运行时系统回收已分配的资源。</li><li><strong><code>_endthread</code></strong> 和 <strong><code>_endthreadex</code></strong> 会导致 C++ 析构函数在不会调用的线程中处于挂起状态。</li></ol><h3 id="WaitForSingleObject"><a class="header-anchor" href="#WaitForSingleObject">¶</a>WaitForSingleObject</h3><h4 id="用途-v4"><a class="header-anchor" href="#用途-v4">¶</a>用途</h4><p>等待指定对象处于信号状态或超时间隔已过。</p><p><em>如果要等待多个对象则使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/synchapi/nf-synchapi-waitformultipleobjects">WaitForMultipleObjects</a></em></p><h4 id="语法-v2"><a class="header-anchor" href="#语法-v2">¶</a>语法</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD WaitForSingleObject(</span><br><span class="line"><span class="string">  [in]</span> HANDLE hHandle,</span><br><span class="line"><span class="string">  [in]</span> DWORD  dwMilliseconds</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="参数-v3"><a class="header-anchor" href="#参数-v3">¶</a>参数</h4><p><em><code>[in] hHandle</code></em></p><p>传递一个内核对象句柄，该句柄标识一个内核对象，句柄必须具有 <strong>SYNCHRONIZE</strong> 访问权限。</p><p>如果该内核对象处于未通知状态，则该函数导致线程进入<strong>阻塞状态</strong>；如果该内核对象处于已通知状态，则该函数立即返回WAIT_OBJECT_0</p><p><em><code>[in] dwMilliseconds</code></em></p><p>超时间隔（以毫秒为单位）。</p><p>如果指定了非零值，该函数将等待对象发出信号或间隔。</p><p>如果 <em>dwMilliseconds</em> 为零，则如果对象未发出信号，则函数不会输入等待状态;它始终会立即返回。</p><p>如果 <em>dwMilliseconds</em> 为 <strong>INFINITE</strong>，则仅当发出对象信号时，该函数才会返回。</p><h4 id="返回值"><a class="header-anchor" href="#返回值">¶</a>返回值</h4><table><thead><tr><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>WAIT_OBJECT_0<br>0x00000080L</td><td>等待的对象有信号（对线程来说，表示执行结束）</td></tr><tr><td>WAIT_TIMEOUT<br>0x00000000L</td><td>等待指定时间内，对象一直没有信号（线程没执行完)</td></tr><tr><td>WAIT_ABANDONED<br>0x00000102L</td><td>对象有信号，但还是不能执行 一般是因为未获取到锁或其他原因</td></tr><tr><td>WAIT_FAILED<br>(DWORD) 0xFFFFFFFF</td><td>函数失败。 要获得更多的错误信息，请调用 GetLastError。</td></tr></tbody></table><h3 id="TerminateThread"><a class="header-anchor" href="#TerminateThread">¶</a>TerminateThread</h3><h4 id="用途-v5"><a class="header-anchor" href="#用途-v5">¶</a>用途</h4><p>在线程外终止一个线程，用于强制终止线程。</p><h4 id="语法-v3"><a class="header-anchor" href="#语法-v3">¶</a>语法</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="constructor">TerminateThread( HANDLE <span class="params">hThread</span>, DWORD <span class="params">dwExitCode</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="参数-v4"><a class="header-anchor" href="#参数-v4">¶</a>参数</h4><p><em><code>hThread</code></em></p><p>被终止的线程的句柄</p><p><em><code>dwExitCode</code></em></p><p>退出码</p><h4 id="返回值-v2"><a class="header-anchor" href="#返回值-v2">¶</a>返回值</h4><p>函数执行成功则返回非零值，执行失败返回0。调用getlasterror获得返回的值</p><h4 id="要求-v2"><a class="header-anchor" href="#要求-v2">¶</a>要求</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>最低支持的客户端</td><td>Windows XP</td></tr><tr><td>最低支持的服务端</td><td>Windows server 2003</td></tr><tr><td>标头</td><td>processthreadsapi.h</td></tr><tr><td>Library</td><td>Kernel32.lib</td></tr><tr><td>DLL</td><td>Kernel32.dll</td></tr></tbody></table><h4 id="注意-v3"><a class="header-anchor" href="#注意-v3">¶</a>注意</h4><ol><li>如果目标线程拥有关键部分，则不会释放关键部分。</li><li>如果目标线程从堆分配内存，则不会释放堆锁。</li><li>如果目标线程在终止时正在执行某些 kernel32 调用，则线程进程的 kernel32 状态可能不一致。</li><li>如果目标线程正在操作共享 DLL 的全局状态，可能会销毁 DLL 的状态，从而影响 DLL 的其他用户。</li><li>如果目标线程是调用此函数时进程的最后一个线程，则线程的进程也会终止。线程对象的状态会发出信号，释放等待线程终止的任何其他线程。 线程的终止状态从 <strong>STILL_ACTIVE</strong> 更改为 <em>dwExitCode</em> 参数的值。</li><li>终止线程不一定从系统中删除线程对象。 关闭最后一个线程句柄时，将删除线程对象。</li></ol><h3 id="GetBestInterfaceEx"><a class="header-anchor" href="#GetBestInterfaceEx">¶</a>GetBestInterfaceEx</h3><h4 id="用途-v6"><a class="header-anchor" href="#用途-v6">¶</a>用途</h4><p>检索具有指向指定 IPv4 或 IPv6 地址的最佳路由的接口的索引</p><h4 id="语法-v4"><a class="header-anchor" href="#语法-v4">¶</a>语法</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="constructor">GetBestInterfaceEx(<span class="params">int</span> <span class="operator">*</span><span class="params">pIndex</span>, <span class="params">int</span> <span class="params">maxSize</span>, <span class="params">char</span> <span class="operator">*</span><span class="params">pGateway</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="参数-v5"><a class="header-anchor" href="#参数-v5">¶</a>参数</h4><p><em><code>[in] pIndex</code></em></p><p>要为其检索具有最佳路由的接口的目标 IPv6 或 IPv4 地址</p><p><em><code>[in] maxSize</code></em></p><p>地址最大长度</p><p><code>[out] pdwBestIfIndex</code></p><p><em>pIndex</em> 指定的 IPv6 或 IPv4 地址的最佳路由。</p><h3 id="WSASocketA"><a class="header-anchor" href="#WSASocketA">¶</a>WSASocketA</h3><h4 id="用途-v7"><a class="header-anchor" href="#用途-v7">¶</a>用途</h4><p>创建绑定到特定传输服务提供程序的套接字</p><h4 id="语法-v5"><a class="header-anchor" href="#语法-v5">¶</a>语法</h4><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SOCKET WSAAPI WSASocketA(</span><br><span class="line">    <span class="variable">_In_</span> int af,</span><br><span class="line">    <span class="variable">_In_</span> int <span class="built_in">type</span>,</span><br><span class="line">    <span class="variable">_In_</span> int protocol,</span><br><span class="line">    <span class="variable">_In_opt_</span> LPWSAPROTOCOL_INFOA lpProtocolInfo,</span><br><span class="line">    <span class="variable">_In_</span> <span class="built_in">GROUP</span> g,</span><br><span class="line">    <span class="variable">_In_</span> DWORD dwFlags</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p><em><code>[in] af</code></em></p><p>地址系列规范</p><table><thead><tr><th>af</th><th>含义</th></tr></thead><tbody><tr><td>AF_UNSPEC</td><td></td></tr><tr><td><br>0</td><td>未指定地址系列</td></tr><tr><td>AF_INET</td><td></td></tr><tr><td><br>2</td><td>指定IPV4地址系列</td></tr><tr><td>AF_IPX</td><td></td></tr><tr><td><br>6</td><td>指定IPX/SPX 地址系列</td></tr><tr><td>AF_APPLETALK</td><td></td></tr><tr><td><br>16</td><td>指定AppleTalk 地址系列</td></tr><tr><td>AF_NETBIOS</td><td></td></tr><tr><td><br>17</td><td>指定NetBIOS 地址系列<br>Windows 32位系统</td></tr><tr><td>AF_INET6</td><td></td></tr><tr><td><br>23</td><td>指定I9V6地址系列</td></tr><tr><td>AF_IRDA</td><td></td></tr><tr><td><br>26</td><td>指定红外数据关联 (IrDA) 地址系列</td></tr><tr><td>AF_BTH</td><td></td></tr><tr><td><br>32</td><td>指定蓝牙地址系列</td></tr></tbody></table><p><em><code>[in] type</code></em></p><p>新套接字的类型规范</p><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>SOCK_STREAM</td><td></td></tr><tr><td><br>1</td><td>对应TCP</td></tr><tr><td>SOCK_DGRAM</td><td></td></tr><tr><td><br>2</td><td>对应UDP</td></tr><tr><td>SOCK_RAW</td><td></td></tr><tr><td><br>3</td><td>提供原始套接字的套接字类型，允许应用程序操作下一层协议标头。 若要操作 IPv4 标头，必须在套接字上设置 IP_HDRINCL 套接字选项。 若要操作 IPv6 标头，必须在套接字上设置 IPV6_HDRINCL 套接字选项。</td></tr><tr><td>SOCK_RDM</td><td></td></tr><tr><td><br>4</td><td>对应多播</td></tr><tr><td>SOCK_SEQPACKET</td><td></td></tr><tr><td><br>5</td><td>提供基于数据报的伪流数据包的套接字类型。</td></tr></tbody></table><p><em><code>[in] protocol</code></em></p><p>使用的协议</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一些常用的Windows-api&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#一些常用的Windows-api&quot;&gt;¶&lt;/a&gt;一些常用的Windows-api&lt;/h2&gt;
&lt;h3 id=&quot;WSAGetLastError&quot;&gt;&lt;a class=&quot;he</summary>
      
    
    
    
    <category term="研发" scheme="https://115jiege.github.io/categories/%E7%A0%94%E5%8F%91/"/>
    
    
    <category term="Windows" scheme="https://115jiege.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>使用Android模拟器</title>
    <link href="https://115jiege.github.io/2023/04/18/%E7%A0%94%E5%8F%91/android%E5%BC%80%E5%8F%91/%E4%BD%BF%E7%94%A8Android%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
    <id>https://115jiege.github.io/2023/04/18/%E7%A0%94%E5%8F%91/android%E5%BC%80%E5%8F%91/%E4%BD%BF%E7%94%A8Android%E6%A8%A1%E6%8B%9F%E5%99%A8/</id>
    <published>2023-04-18T03:13:28.000Z</published>
    <updated>2023-04-18T05:38:38.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Android模拟器"><a class="header-anchor" href="#安装Android模拟器">¶</a>安装Android模拟器</h2><p>Android模拟器这步真的太痛苦了ε=( o｀ω′)ノ<br>搞了好多办法最后搞得Android studio总是闪退，解决办法：重装软件啦╮(╯▽╰)╭</p><h3 id="AndroidStudio自带的安卓模拟器"><a class="header-anchor" href="#AndroidStudio自带的安卓模拟器">¶</a>AndroidStudio自带的安卓模拟器</h3><p>在虚拟机里安装Android Studio，使用它自带的安卓模拟器;</p><p>打开Android Studio，第一次打开会进行一些基础设置和安装sdk，默认就好；<br>新建工程，打开tools-&gt;sdk manager;安装Android Emulator(最新版),Android SDK plantform-tools,ndk(自定义奥);</p><p>打开Device Manager，create virtual device:<br>1)choose a device definition — Nexus 5X;</p><p>2)select a system image — Nougat(api:24,ABI:X86)<br>可以自主选择需要的不同api等级和ABI的镜像，但是需要注意:<br><strong>①系统缺少/不支持VT-x/AMD-V;</strong><br>解决：关闭虚拟机，打开设置-系统-处理器-勾选启用嵌套VT-x/AMD-V;</p><p>如果无法启用，选项为灰色，则使用VBoxManage以命令行的方式进行开启,操作步骤如下:<br>物理机管理员身份打开cmd，cd到virtualbox安装目录;<br>VBoxManage.exe list vms   #列出虚拟机名字<br>.\vboxmanage.exe modifyvm hostname --nested-hw-virt on  #打开hostname的嵌套VT-x/AMD-V功能</p><p><strong>②选择api level</strong><br>新建项目工程时选择的api等级是工程支持的最低SDK版本，所以选择镜像的api等级应该不小于这个等级;</p><p>如果想要修改min-api，可以打开工程结构File-&gt;Project Structure(or快捷键Ctrl+Alt+Shift+S)，修改Default Config-&gt;Min SDK version;</p><p><strong>③选择ABI</strong><br>科普：<br>ABI (Application Binray interface):应用程序二进制接口，描述了应用程序和操作系统之间，一个应用和它的库之间，或应用的组成部分之间的底层接口。<br>早期的Android系统几乎只支持ARMv5的CPU架构，后面发展到支持七种不同的CPU架构：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起)，每一种都关联着一个相应的ABI。<br>应用程序二进制接口（Application Binary Interface）定义了二进制文件（尤其是.so文件）如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库。<br>在Android 系统上，每一个CPU架构对应一个ABI：armeabi，armeabi-v7a，x86，mips，arm64- v8a，mips64，x86_64。<br>AndroidStudio自带的模拟器中只有常用的四种：armeabi-v7a，x86，arm64- v8a，x86_64;可以按需选择。</p><p>但是最好是对应系统的CPU架构，建议先查看系统cpu架构(unix系统使用命令&quot;uname -a&quot;查看)，然后选择对应的CPU架构;<br>比如我的ubuntu2204的CPU架构是X86_64，所以就可以选择X86和X86_64位的;<br>尝试使用armeabi-v7a的镜像，结果启动后一直卡在开机页面(Windows试过也是这样，可能是不兼容);</p><p>不过这些虚拟设备动辄四五个G，还有八九个G的，运行起来也很卡，最关键的是，连接不上！！！！<br>经过一番努力后，选择放弃，改用别的安卓模拟器。</p><h3 id="genymotion"><a class="header-anchor" href="#genymotion">¶</a>genymotion</h3><p>寻找资料发现ubuntu等linux系统可用安卓模拟器很多，不仅安装方便，运行也不会很卡;<br>这里我是用的是genymotion，原因是好看。</p><h4 id="安装VirtualBox"><a class="header-anchor" href="#安装VirtualBox">¶</a>安装VirtualBox</h4><p>genymotion依赖于VirtualBox，所以不仅物理机的Virtualbox要开启VT-x/AMD-V扩展功能，还要在虚拟机内安装virtualbox;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install virtualbox</span><br></pre></td></tr></table></figure><h4 id="安装genymotion"><a class="header-anchor" href="#安装genymotion">¶</a>安装genymotion</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.genymotion.com/releases/genymotion-3.1.2/genymotion-3.1.2-linux_x64.bin</span><br><span class="line">sudo ./genymotion-3.1.2-linux_x64.bin</span><br></pre></td></tr></table></figure><p><em>默认安装目录：/opt/genymobile/genymotion</em></p><h4 id="添加快捷方式"><a class="header-anchor" href="#添加快捷方式">¶</a>添加快捷方式</h4><p>打开终端，命令行输入以下内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim</span><br><span class="line"><span class="built_in">ln</span> -s /opt/genymobile/genymotion/genymotion /usr/bin/genymotion</span><br><span class="line"><span class="built_in">ln</span> -s /opt/genymobile/genymotion/icons/genymotion-logo.png /usr/local/share/genymotion-logo.png</span><br><span class="line"><span class="built_in">cd</span> /usr/share/applications </span><br><span class="line">sudo vim ./genymotion.desktop</span><br></pre></td></tr></table></figure><p>新建桌面文件，添加以下内容:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Desktop Entry]</span><br><span class="line"></span><br><span class="line"><span class="attribute">Name</span> <span class="operator">=</span> genymotion</span><br><span class="line"></span><br><span class="line"><span class="attribute">Exec</span> <span class="operator">=/</span>usr/bin/genymotion</span><br><span class="line"></span><br><span class="line"><span class="attribute">Icon</span> <span class="operator">=/</span>usr/local/share/genymotion-logo.png</span><br><span class="line"></span><br><span class="line"><span class="attribute">Comment</span> <span class="operator">=</span> genymotion</span><br><span class="line"></span><br><span class="line"><span class="attribute">Type</span> <span class="operator">=</span> Application   </span><br></pre></td></tr></table></figure><h4 id="注册"><a class="header-anchor" href="#注册">¶</a>注册</h4><p>因为genymotion需要账号登陆，因此我们需要去官网创建账号，因此才可以登陆软件；<br><a href="https://www.genymotion.com/account/create/">创建账号</a><br>创建好账号之后，回到genymotion软件，输入帐号密码，点击next，选择Personal Use，继续next即可使用个人版;</p><h4 id="AndroidStudio插件"><a class="header-anchor" href="#AndroidStudio插件">¶</a>AndroidStudio插件</h4><p>打开AndroidStudio，找到setting-plugins，搜索genymotion，安装插件并重启Android Studio;<br>点击Genymotion插件图标，打开插件;<br>(没有UI工具栏的，需要依次点击 View =&gt; Appearance =&gt; Toolbar 即可找到)<br>打开setting-tools-genymotion plugin，填入Genymotion安装路径;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装Android模拟器&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#安装Android模拟器&quot;&gt;¶&lt;/a&gt;安装Android模拟器&lt;/h2&gt;
&lt;p&gt;Android模拟器这步真的太痛苦了ε=( o｀ω′)ノ&lt;br&gt;
搞了好多办法最后搞得And</summary>
      
    
    
    
    <category term="研发" scheme="https://115jiege.github.io/categories/%E7%A0%94%E5%8F%91/"/>
    
    
    <category term="android开发" scheme="https://115jiege.github.io/tags/android%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Virtualbox搭建虚拟机</title>
    <link href="https://115jiege.github.io/2023/04/18/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/Virtualbox%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://115jiege.github.io/2023/04/18/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/Virtualbox%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2023-04-18T03:06:48.000Z</published>
    <updated>2023-04-23T02:15:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装virtualbox"><a class="header-anchor" href="#安装virtualbox">¶</a>安装virtualbox:</h2><p><a href="https://www.virtualbox.org/wiki/Downloads">virtualbox主程序</a><br>点击链接，选择合适的版本下载virtualbox;</p><h2 id="安装ubuntu虚拟机"><a class="header-anchor" href="#安装ubuntu虚拟机">¶</a>安装ubuntu虚拟机</h2><p>下载镜像:<br><a href="https://ubuntu.com/download/desktop">官方下载地址</a><br>推荐，官方不花里胡哨，国内镜像源下载的ubuntu-22.04.2-desktop-amd64.iso出现了写入错误，内核编译缺少头文件等情况。<br>写入错误导致ubuntu无法安装，内核头文件确实导致virtualbox安装增强功能失败。</p><p><a href="https://mirrors.cloud.tencent.com/ubuntu-releases/22.04/">腾讯镜像站</a></p><p><a href="https://mirrors.aliyun.com/ubuntu-releases/22.04/">阿里镜像站</a></p><p><a href="https://repo.huaweicloud.com/ubuntu-releases/22.04">华为镜像站</a></p><p><em>ps:widows镜像可以到<a href="https://msdn.itellyou.cn/">msdn</a> 上下载</em></p><p>点击新建，填写虚拟机名称、安装位置，镜像位置，默认安装;<br>虚拟机里装模拟器，要把内存设置的大一点，我设置了100G(‾◡◝)</p><h3 id="修改分辨率"><a class="header-anchor" href="#修改分辨率">¶</a>修改分辨率</h3><p>进入系统之后发现缩放比例不对，其实是分辨率的问题，找到setting-&gt;desplays修改分辨率;</p><p>系统中没有1920x1080的肿么办，可以自己添加:<br>打开终端，输入xrandr，查看到屏幕分辨率最小是1x1，目前是:800x600，最大是8192x8192，虚拟机编号是&quot;Virtual1&quot;;<br>输入cvt 1920 1080，查看显示模式的相关信息:“Modeline xxxxxx”;<br>添加显示模式，输入下面两条命令:<br>sudo xrandr --newmode xxxxxx<br>sudo xrandr --addmode Virtual1(虚拟机编号) “1920x1080 60.00”<br>使用命令xrandr查看，可以发现可供选择的分辨率多了自己自定义的模式，可以到设置里设置显示屏分辨率了;</p><p>或者：<br>点击界面的设备，选择安装增强功能，点击运行;<br>点击光盘，sudo ./VBoxLinuxAdditions.run，成功后重启虚拟机;<br>点击视图-自动调整显示尺寸；可以使显示窗口自动填满界面。</p><h3 id="共享文件夹"><a class="header-anchor" href="#共享文件夹">¶</a>共享文件夹</h3><p>首先弹出上一步安装增强功能所用的光盘(不然挂载会失败);<br>修改虚拟机的设置，点击共享文件夹，新建:填写共享文件夹目录(物理机D:\shared)，文件夹名称(shared)，勾选自动挂载，固定分配;<br>回到虚拟机，打开终端，输入命令行创建文件夹:<br>sudo mkdir /home/Win10<br>将主机共享文件夹与Ubuntu的共享文件夹连接起来:<br>sudo mount -t vboxsf shared /home/Win10<br>在主机的共享文件夹放置一个文件，如果Ubuntu内的对应共享文件夹内能看到该文件，则说明共享文件夹创建成功。</p><p><em>注意：物理机的共享目录不要放到C盘或者virtualbox的安装目录下(需要管理员权限的那种)，不然操作共享目录需要物理机管理员权限，在Ubuntu上就算是sudo也没用。</em></p><h3 id="共享粘贴板和拖放"><a class="header-anchor" href="#共享粘贴板和拖放">¶</a>共享粘贴板和拖放</h3><p>设备-将禁用改为双向;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装virtualbox&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#安装virtualbox&quot;&gt;¶&lt;/a&gt;安装virtualbox:&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.virtualbox.org/wiki/Down</summary>
      
    
    
    
    <category term="杂七杂八" scheme="https://115jiege.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="virtualbox" scheme="https://115jiege.github.io/tags/virtualbox/"/>
    
  </entry>
  
  <entry>
    <title>android开发--活动的创建与使用</title>
    <link href="https://115jiege.github.io/2023/03/31/%E7%A0%94%E5%8F%91/android%E5%BC%80%E5%8F%91/android%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://115jiege.github.io/2023/03/31/%E7%A0%94%E5%8F%91/android%E5%BC%80%E5%8F%91/android%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2023-03-31T00:20:32.000Z</published>
    <updated>2023-04-23T02:03:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>本章学习Android中的活动，活动是一种可以包含用户界面的组件，主要用于和用户交互。</p><h2 id="活动的基本用法"><a class="header-anchor" href="#活动的基本用法">¶</a>活动的基本用法</h2><h3 id="创建活动"><a class="header-anchor" href="#创建活动">¶</a>创建活动</h3><h4 id="新建项目"><a class="header-anchor" href="#新建项目">¶</a>新建项目</h4><p>打开Android Studio新建Android项目，选择no Activity，等待gradle构建;</p><h4 id="新建活动"><a class="header-anchor" href="#新建活动">¶</a>新建活动</h4><p>右击 app/src/main/java/com.example.activitytest-&gt;New-&gt;Actvity-&gt;Empty Activity，创建活动FirstActivity，注意不勾选Generate Layout和Launcher Activity;<br>打开创建的FirstActivity，发现Android Studio自动完成了重写Activity的onCreate()方法，即调用父类的onCreate()方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建布局"><a class="header-anchor" href="#创建布局">¶</a>创建布局</h3><p>布局用于显示页面内容，最好每个活动对应一个布局;</p><h4 id="新建布局文件"><a class="header-anchor" href="#新建布局文件">¶</a>新建布局文件</h4><p>右击app/src/main/res-&gt;New-&gt;Directory，新建layout文件夹；<br>右击layout-&gt;NeW-&gt;Layout resource file,创建first_layout布局文件，选择根元素为LinearLayout;<br>布局文件创建完成后，Android Studio会显示可视化布局编辑器(右上角可切换模式);</p><h4 id="编辑布局文件"><a class="header-anchor" href="#编辑布局文件">¶</a>编辑布局文件</h4><p>编辑布局文件，添加一个按钮：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/button_1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;150dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginEnd</span>=<span class="string">&quot;150dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;400dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;START&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这里添加了一个Button元素，并增加了几个属性。<br><strong>id</strong><br>android:id为当前元素定义一个唯一标识符：在XML中引用一个id，使用@id/id_name;在XML中定义一个id，使用@+id/id_name;<br><strong>width、height</strong><br>android:layout_width、android:layout_height定义了元素的宽高，使用wrap_content表示当前元素的高度只要刚好能包含里面的内容;<br><strong>margin</strong><br>android:layout_marginStart、android:layout_marginTop、android:layout_marginEnd、android:layout_marginBottom定义了元素的位置;</p><p>layout_marginTop 指定该属性所在控件距上部最近控件的最小值;<br>layout_marginBottom 指定该属性所在控件距下部最近控件的最小值;<br>layout_marginLeft 指定该属性所在控件距左边最近控件的最小值;<br>layout_marginRight 指定该属性所在控件距右边最近控件的最小值;<br>layout_marginStart：如果在LTR布局模式下，该属性等同于layout_marginLeft。如果在RTL布局模式下，该属性等同于layout_marginRight。<br>layout_marginEnd：如果在LTR布局模式下，该属性等同于layout_marginRight。如果在RTL布局模式下，该属性等同于layout_marginLeft。<br><strong>text</strong><br>android:text制定了元素显示的文字内容;<br><strong>constraint</strong><br>控件在ConstraintLayout里面要实现margin，必须先约束该控件在ConstraintLayout里的位置;<br>app:layout_constraintBottom_toBottomOf、app:layout_constraintEnd_toEndOf、app:layout_constraintStart_toStartOf、app:layout_constraintTop_toTopOf约束元素在parent里的位置，使得margin生效。</p><blockquote><p>约束布局ConstraintLayout是一个ViewGroup，可以在Api9以上的Android系统使用它，它的出现主要是为了解决布局嵌套过多的问题，以灵活的方式定位和调整小部件。<br>例如：首先是一个垂直的LinearLayout，里面放两个水平的LinearLayout，然后在水平的LinearLayout里面放TextView。这样的写法就嵌套了两层LinearLayout，可能会出现布局嵌套过多的问题，嵌套得越多，设备绘制视图所需的时间和计算功耗也就越多。<br>ConstraintLayout横空出世，ConstraintLayout可以按照比例约束控件位置和尺寸，能够更好地适配屏幕大小不同的机型。</p></blockquote><p>使用ConstraintLayout首先需要添加依赖，在build.gradle(app)中添加<br>implementation ‘com.android.support.constraint:constraint-layout:1.1.3’</p><p>使用ConstraintLayout可以实现控件位置的控制:</p><p>布局文件中添加:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/TextView1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;TextView1&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/TextView2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintLeft_toRightOf</span>=<span class="string">&quot;@+id/TextView1&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>可以实现元素TextView2的相对定位，使用属性app:layout_constraintLeft_toRightOf=“@+id/TextView1”，把TextView2的左边约束到TextView1的右边;</p><p>相对定位的常用属性：<br>layout_constraintLeft_toLeftOf<br>layout_constraintLeft_toRightOf<br>layout_constraintRight_toLeftOf<br>layout_constraintRight_toRightOf<br>layout_constraintTop_toTopOf<br>layout_constraintTop_toBottomOf<br>layout_constraintBottom_toTopOf<br>layout_constraintBottom_toBottomOf<br>layout_constraintBaseline_toBaselineOf<br>layout_constraintStart_toEndOf<br>layout_constraintStart_toStartOf<br>layout_constraintEnd_toStartOf<br>layout_constraintEnd_toEndOf</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:id</span>=<span class="string">&quot;@+id/TextView1&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:text</span>=<span class="string">&quot;TextView1&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:id</span>=<span class="string">&quot;@+id/TextView2&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">app:layout_constraintCircle</span>=<span class="string">&quot;@+id/TextView1&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">app:layout_constraintCircleAngle</span>=<span class="string">&quot;60&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">app:layout_constraintCircleRadius</span>=<span class="string">&quot;100dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>可以实现TextView2的角度定位，属性app:layout_constraintCircle=&quot;@+id/TextView1&quot;确定中心为TextView1，属性app:layout_constraintCircleAngle=&quot;160&quot;确定在TextView1的中心的60°，属性app:layout_constraintCircleRadius=&quot;100dp确定和TextView1距离为100dp;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/TextView1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintHorizontal_bias</span>=<span class="string">&quot;0.618&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">app:layout_constraintVertical_bias</span>=<span class="string">&quot;0.618&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>可以实现TextView1的偏移，layout_constraintHorizontal_bias 水平偏移，layout_constraintVertical_bias 垂直偏移;此外，constraint还可以实现更多更复杂的布局。</p><p>总之，这样一个简单的布局就编写完成了，接下来要在活动中加载这个布局。</p><h4 id="加载布局文件"><a class="header-anchor" href="#加载布局文件">¶</a>加载布局文件</h4><p>编辑FirstActivity，onCreate()方法调用setContentView()方法加载布局:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.first_layout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册活动"><a class="header-anchor" href="#注册活动">¶</a>注册活动</h3><p>所有的活动都要在AndroidManifest.xml中进行注册才能生效，打开app/src/main/AndroidMainfest.xml:</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">application</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    ···</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"> &lt;<span class="attr">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.FirstActivity&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在activity标签中使用android.name注册活动;并在其中加入<intent-filter>标签，设置FirstActivity为主活动，即当程序运行时，首先启动FirstActivity;</intent-filter></p><h3 id="Toast的使用"><a class="header-anchor" href="#Toast的使用">¶</a>Toast的使用</h3><p>Toast是Android系统提供的提醒方式，在程序中可以把一些短小的消息传给用户，这些消息在一定时间后会自动消失，且不占用任何屏幕空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.first_layout);</span><br><span class="line">    <span class="type">Button</span> <span class="variable">button1</span> <span class="operator">=</span> (Button) findViewById(R.id.button_1);</span><br><span class="line">    button1.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">            Toast.makeText(FirstActivity.<span class="built_in">this</span>,<span class="string">&quot;开始测试&quot;</span>,</span><br><span class="line">                    Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">                               &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在活动中，通过findViewById()方法获取到定义在布局文件中的元素，传入R.id.button_1(first_layout中android:id规定的唯一标识符)获取按钮的实例，且findViewById()返回的是一个view对象，需要转化成Button对象;<br>然后调用setOnClickListener()方法为按钮注册一个监听器，点击按钮时就会执行监听器中的onClick()方法;<br>编写onClick()方法，通过静态方法makeText()创建出一个Toast对象，然后显示;</p><p>makeText()方法的输入参数为Context(活动要求的上下文)、Toast现实的文本内容、Toast的显示时长。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本章学习Android中的活动，活动是一种可以包含用户界面的组件，主要用于和用户交互。&lt;/p&gt;
&lt;h2 id=&quot;活动的基本用法&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#活动的基本用法&quot;&gt;¶&lt;/a&gt;活动的基本用法&lt;/h2&gt;
&lt;h3 id=&quot;创建活动&quot;</summary>
      
    
    
    
    <category term="研发" scheme="https://115jiege.github.io/categories/%E7%A0%94%E5%8F%91/"/>
    
    
    <category term="android开发" scheme="https://115jiege.github.io/tags/android%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>android从0开发（二）.md</title>
    <link href="https://115jiege.github.io/2023/03/30/%E7%A0%94%E5%8F%91/android%E5%BC%80%E5%8F%91/android%E4%BB%8E0%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://115jiege.github.io/2023/03/30/%E7%A0%94%E5%8F%91/android%E5%BC%80%E5%8F%91/android%E4%BB%8E0%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2023-03-30T09:15:38.000Z</published>
    <updated>2023-04-18T08:36:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android开发第二弹来啦~~<br>在进行jni开发的时候，发现生成的Native函数声明的第一个参数影院是JNIEnv指针，第二个参数永远是jobject或者jclass;<br>JNIEnv是一个JNI接口指针，指向了本地方法的一个函数表，该函数表中的每一个成员指向了一个JNI函数，本地方法通过JNI函数来访问JVM中的数据结构;<br>jobject与jclass通常作为JNI函数的第二个参数，当所声明Native方法是静态方法时，对应参数jclass，因为静态方法不依赖对象实例，而依赖于类；<br>如果声明的Native方法时非静态方法时，那么对应参数是jobject。<br>jni中常使用数组和字符串，这里总结一下开发时用到的一些知识。</p><h2 id="jni数组使用"><a class="header-anchor" href="#jni数组使用">¶</a>jni数组使用</h2><h3 id="NewArray"><a class="header-anchor" href="#NewArray">¶</a>NewArray</h3><p>构造原始数组，构造失败则返回null;</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayType New&lt;PrimitiveType&gt;<span class="constructor">Array(JNIEnv <span class="operator">*</span><span class="params">env</span>, <span class="params">jsize</span> <span class="params">length</span>)</span>;</span><br></pre></td></tr></table></figure><p>基本数组类型:<br>|-- jni |-- java |<br>| := | := |<br>| jbooleanArray | boolean[] |<br>| jbyteArray | byte[] |<br>| jcharArray | char[] |<br>| jshortArray | short[] |<br>| jintArray | int[] |<br>| jlongArray | long[] |<br>| jdoubleArray | double[] |</p><h3 id="GetArrayLength"><a class="header-anchor" href="#GetArrayLength">¶</a>GetArrayLength</h3><p>返回数组长度;</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsize <span class="constructor">GetArrayLength(JNIEnv <span class="operator">*</span><span class="params">env</span>, <span class="params">jarray</span> <span class="params">array</span>)</span>;</span><br></pre></td></tr></table></figure><p>基本数组类型<br>| c++ | jni | 说明 |<br>| := | := | := |<br>| uint8_t/unsigned char | jboolean | unsigned 8 bits |<br>| int8_t/signed char | jbyte | signed 8 bits |<br>| uint16_t/unsigned short | jchar | unsined 16 bits |<br>| int16_t/short | jshort | signed 16 bits |<br>| int32_t/int | jint | signed 32 bits |<br>| int64_t | jlong | signed 64 bits |<br>| float | jfloat | 32-bit IEEE 754 |<br>| double | jdouble | 64-bit IEEE 754 |</p><h3 id="GetArrayElements"><a class="header-anchor" href="#GetArrayElements">¶</a>GetArrayElements</h3><p>返回数组指针，结果一直有效,直至调用的ReleaseArrayElements()函数;<br>调用失败则返回为空;<br>需要注意第三个参数isCopy指针，表示是否返回源数组的拷贝;<br>一般我们不关心是否拷贝原数组，所以设置为null;<br>当isCopy不为null时,如果进行了复制，则isCopy设置为JNI_TRUE; 如果没有复制，则设置为JNI_FALSE。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NativeType *Get&lt;PrimitiveType&gt;<span class="constructor">ArrayElements(JNIEnv <span class="operator">*</span><span class="params">env</span>, ArrayType <span class="params">array</span>, <span class="params">jboolean</span> <span class="operator">*</span><span class="params">isCopy</span>)</span>;</span><br></pre></td></tr></table></figure><p>对于每次调用GetArrayElements，都需要调用ReleaseArrayElements(就像new 和 delete一样成对使用);</p><h3 id="ReleaseArrayElements"><a class="header-anchor" href="#ReleaseArrayElements">¶</a>ReleaseArrayElements</h3><p>释放缓冲区：<br>参数mode为0表示复制回内容并释放缓冲区，JNI_COMMIT表示复制回内容但不释放缓冲区，JNI_ABORT表示释放缓冲区而不复制回可能的更改。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Release&lt;PrimitiveType&gt;<span class="constructor">ArrayElements(JNIEnv <span class="operator">*</span><span class="params">env</span>, ArrayType <span class="params">array</span>, NativeType <span class="operator">*</span><span class="params">elems</span>, <span class="params">jint</span> <span class="params">mode</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="GetArrayRegion"><a class="header-anchor" href="#GetArrayRegion">¶</a>GetArrayRegion</h3><p>将数组内容复制到缓冲区;<br>参数start表示数组需要复制的起始索引;<br>参数len表示需要复制的数组长度;<br>参数buf为目标缓冲区;</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Get&lt;PrimitiveType&gt;<span class="constructor">ArrayRegion(JNIEnv <span class="operator">*</span><span class="params">env</span>, ArrayType <span class="params">array</span>, <span class="params">jsize</span> <span class="params">start</span>, <span class="params">jsize</span> <span class="params">len</span>, NativeType <span class="operator">*</span><span class="params">buf</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="SetArrayRegion"><a class="header-anchor" href="#SetArrayRegion">¶</a>SetArrayRegion</h3><p>从缓冲区中复制回原始数组的某个区域;<br>参数buf为源缓冲区;</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Set&lt;PrimitiveType&gt;<span class="constructor">ArrayRegion(JNIEnv <span class="operator">*</span><span class="params">env</span>, ArrayType <span class="params">array</span>, <span class="params">jsize</span> <span class="params">start</span>, <span class="params">jsize</span> <span class="params">len</span>, <span class="params">const</span> NativeType <span class="operator">*</span><span class="params">buf</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="字符串使用"><a class="header-anchor" href="#字符串使用">¶</a>字符串使用</h2><p>jni通过jstring在java和c<ins>中传递字符串;<br>Java默认使用Unicode编码，C/C</ins> 默认使用UTF编码，而JNI支持字符串在Unicode和UTF-8两种编码之间转换；<br>使用GetStringUTFChars 可以把一个 jstring 指针(指向JVM内部的Unicode字符序列)转换成一个UTF-8格式的C字符串。<br>关于GetStringUTFChars第三个参数iscopy，同上文所述，一般不关心其返回值，所以一般填null;<br>当iscopy不为null时：如果iscopy=JNI_TRUE则表示返回 JVM 内部源字符串的一份拷贝，并为新产生的字符串分配内存空间;<br>如果iscopy=JNI_FALSE则返回 JVM 内部源字符串的指针(不推荐，遵循java字符串不可修改的规定);</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">char</span>* <span class="constructor">GetStringUTFChars(<span class="params">jstring</span> <span class="params">string</span>, <span class="params">jboolean</span><span class="operator">*</span> <span class="params">isCopy</span>)</span></span><br><span class="line">&#123; return functions-&gt;<span class="constructor">GetStringUTFChars(<span class="params">this</span>, <span class="params">string</span>, <span class="params">isCopy</span>)</span>; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与GetArrayElements相同，用完需要释放，使用ReleaseStringUTFChars释放字符串;</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void <span class="constructor">ReleaseStringUTFChars(<span class="params">jstring</span> <span class="params">string</span>, <span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">utf</span>)</span></span><br><span class="line">&#123; functions-&gt;<span class="constructor">ReleaseStringUTFChars(<span class="params">this</span>, <span class="params">string</span>, <span class="params">utf</span>)</span>; &#125;</span><br></pre></td></tr></table></figure><p>不用怕不好记，反正用了 GetXXX 就必须调用 ReleaseXXX ~<s>///(<sup>v</sup>)\~</s>。</p><h2 id="异常抛出"><a class="header-anchor" href="#异常抛出">¶</a>异常抛出</h2><p>程序如果在运行期间没有按正常的程序逻辑执行，出现了错误，就会导致程序崩溃。</p><p>在java中如果觉得某段逻辑可能引发异常,使用try…catch捕获异常即可;如果发生了异常，程序回直接崩溃退出，不会执行后续代码。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">        <span class="built_in">sayHello</span>();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e<span class="selector-class">.printStackTrace</span>();</span><br></pre></td></tr></table></figure><p>jni没有try…catch…final异常处理机制，并且如果jni中发生了异常，不会立即停止执行，而是会继续执行后续代码；<br>所以需要将异常抛出给java:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">char</span> *hello = (*env).<span class="constructor">GetStringUTFChars(<span class="params">hello_str</span>, <span class="params">nullptr</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (hello<span class="operator"> == </span>null) &#123; <span class="comment">/* 异常检查 */</span></span><br><span class="line">        env-&gt;<span class="constructor">ThrowNew(<span class="params">env</span>-&gt;FindClass(<span class="string">&quot;java/lang/Exception&quot;</span>)</span>, <span class="string">&quot;GetStringUTFChars fail.&quot;</span>);<span class="comment">// 发生异常后释放前面所分配的内存</span></span><br><span class="line">        return; </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>比较常见的就是由于内存不足导致的JNI调用异常:<br>通常调用GetXX，NewXXX函数时回分配内存，所以调用后需要进行异常检查;<br>如果发生了异常，则抛出异常并释放前面分配的内存。</p><p>关于内存，除了调用JNI函数可能需要分配内存，更明显的例如：<br>使用new,new[&amp;#93,malloc,calloc等C语言函数分配内存，要记得使用进行初始化，防止混入脏数据，并且用完后记得使用delete,delete[&amp;#93,free进行回收。</p><h2 id="日志打印"><a class="header-anchor" href="#日志打印">¶</a>日志打印</h2><p>通过使用android自带的log打印输出信息到LOGCAT中，方便调试。<br>对于java代码的log，只需要引入log包，然后使用log.e,log.w,log.v,log.i,log.d等函数</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.<span class="keyword">Log</span></span><br><span class="line"></span><br><span class="line">final <span class="keyword">public</span> <span class="built_in">Boolean</span> isEng =Build.<span class="keyword">TYPE</span>.<span class="keyword">equals</span>(<span class="string">&quot;eng&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isEng)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">Log</span>.v(“LOG_TAG”,“LOG_MESSAGE”);</span><br></pre></td></tr></table></figure><p>对于jni可以使用Android的日志库;</p><h3 id="编辑CmakelLists-txt"><a class="header-anchor" href="#编辑CmakelLists-txt">¶</a>编辑CmakelLists.txt</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_library</span>( <span class="comment"># Sets the name of the path variable.</span></span><br><span class="line">        log-lib</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Specifies the name of the NDK library that</span></span><br><span class="line">        <span class="comment"># you want CMake to locate.</span></span><br><span class="line">        log)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>( <span class="comment"># Specifies the target library.</span></span><br><span class="line">        xxx</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Links the target library to the log library</span></span><br><span class="line">        <span class="comment"># included in the NDK.</span></span><br><span class="line">        <span class="variable">$&#123;log-lib&#125;</span>)</span><br></pre></td></tr></table></figure><h3 id="添加log-h"><a class="header-anchor" href="#添加log-h">¶</a>添加log.h</h3><p>app/src/main/cpp-&gt;New c++ header;</p><p>这里主要使用了&lt;android/log.h&gt;中的__android_log_print函数，使用方法和printf差不多;<br>第一个参数时打印的级别:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef enum <span class="keyword">android_LogPriority </span>&#123;</span><br><span class="line">  <span class="comment">/** For internal use only.  */</span></span><br><span class="line">  <span class="keyword">ANDROID_LOG_UNKNOWN </span>= <span class="number">0</span>,</span><br><span class="line">  <span class="comment">/** The default priority, for internal use only.  */</span></span><br><span class="line">  <span class="keyword">ANDROID_LOG_DEFAULT, </span><span class="comment">/* only for SetMinPriority() */</span></span><br><span class="line">  <span class="comment">/** Verbose logging. Should typically be disabled for a release apk. */</span></span><br><span class="line">  <span class="keyword">ANDROID_LOG_VERBOSE,</span></span><br><span class="line"><span class="keyword"></span>  <span class="comment">/** Debug logging. Should typically be disabled for a release apk. */</span></span><br><span class="line">  <span class="keyword">ANDROID_LOG_DEBUG,</span></span><br><span class="line"><span class="keyword"></span>  <span class="comment">/** Informational logging. Should typically be disabled for a release apk. */</span></span><br><span class="line">  <span class="keyword">ANDROID_LOG_INFO,</span></span><br><span class="line"><span class="keyword"></span>  <span class="comment">/** Warning logging. For use with recoverable failures. */</span></span><br><span class="line">  <span class="keyword">ANDROID_LOG_WARN,</span></span><br><span class="line"><span class="keyword"></span>  <span class="comment">/** Error logging. For use with unrecoverable failures. */</span></span><br><span class="line">  <span class="keyword">ANDROID_LOG_ERROR,</span></span><br><span class="line"><span class="keyword"></span>  <span class="comment">/** Fatal logging. For use when aborting. */</span></span><br><span class="line">  <span class="keyword">ANDROID_LOG_FATAL,</span></span><br><span class="line"><span class="keyword"></span>  <span class="comment">/** For internal use only.  */</span></span><br><span class="line">  <span class="keyword">ANDROID_LOG_SILENT, </span><span class="comment">/* only for SetMinPriority(); must be last */</span></span><br><span class="line">&#125; <span class="keyword">android_LogPriority;</span></span><br></pre></td></tr></table></figure><p>第二个参数是LOGTAG，可以定义宏为工程名;<br>最后一个参数是用__VA_ARGS__(可变参数宏):<br>把参数传递给宏LOGD，宏定义展开后，实际的参数就传给_android_log_print了;</p><p>如果只是想简单的打印出错信息就可以这样定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGTAG <span class="string">&quot;test&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)</span></span><br></pre></td></tr></table></figure><p>如果要打印详细信息，则需要添加format:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="constructor">LOG_ERROR(<span class="params">format</span>,<span class="operator">...</span>)</span> <span class="constructor">__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, <span class="string">&quot;function: %s, line: %d &quot;</span> <span class="params">format</span>, <span class="params">__FUNCTION__</span>,<span class="params">__LINE__</span>, ##<span class="params">__VA_ARGS__</span>)</span></span><br></pre></td></tr></table></figure><p>上面就是打印了出错的函数名和行号，注意在C++中当可变参数个数为0时，需要使用##号将前面的逗号去掉，才能正确打印。</p><h2 id="AS项目编译"><a class="header-anchor" href="#AS项目编译">¶</a>AS项目编译</h2><h3 id="so文件编译"><a class="header-anchor" href="#so文件编译">¶</a>so文件编译</h3><p>差不多完成项目的开发后，就可以试着编译一下了;<br>通过Build-&gt;select build variants选择编译debug或release;<br>点击Build-&gt;make project进行编译，编译后的so文件存放在app/build/intermediates/cmake下</p><h3 id="so文件的使用（java层）"><a class="header-anchor" href="#so文件的使用（java层）">¶</a>so文件的使用（java层）</h3><p>对于编好的so文件，如何在Android工程中使用他们呢(・∀・(・∀・(・∀・*)</p><p>1.拷贝上面编好的项目中app/build/intermediates/cmake/debug(relaese)/obj/arm64-v8a(armebi,x86,x86_64)文件夹放入新工程的app/libs下</p><p>2.修改build.gradle(:app)</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">android</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">defaultConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">ndk</span> &#123;</span><br><span class="line">            abiFilters <span class="symbol">&#x27;arm64</span><span class="operator">-</span>v8a&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">sourceSets</span> &#123;</span><br><span class="line">        <span class="keyword">main</span> &#123;</span><br><span class="line">            jniLibs.srcDirs <span class="operator">=</span> [<span class="symbol">&#x27;libs</span>&#x27;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.新建java类test，确保包名(com.example.hello),函数名(sayHello)和so文件中的一致;</p><p>4.在活动中调用:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.hello.test</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        test jnitest = <span class="keyword">new</span> test();  </span><br><span class="line">test.sayHello() </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Android开发第二弹来啦~~&lt;br&gt;
在进行jni开发的时候，发现生成的Native函数声明的第一个参数影院是JNIEnv指针，第二个参数永远是jobject或者jclass;&lt;br&gt;
JNIEnv是一个JNI接口指针，指向了本地方法的一个函数表，该函数表中的每一个成员</summary>
      
    
    
    
    <category term="研发" scheme="https://115jiege.github.io/categories/%E7%A0%94%E5%8F%91/"/>
    
    
    <category term="android开发" scheme="https://115jiege.github.io/tags/android%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>针对一种新型Modbus Dos攻击的讨论</title>
    <link href="https://115jiege.github.io/2023/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Modbus%20DOS%E6%94%BB%E5%87%BB/"/>
    <id>https://115jiege.github.io/2023/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Modbus%20DOS%E6%94%BB%E5%87%BB/</id>
    <published>2023-03-30T08:53:20.390Z</published>
    <updated>2023-03-13T03:21:11.028Z</updated>
    
    <content type="html"><![CDATA[<p>工作一个周，摸鱼一个周，摩尔庄园也玩腻了，在much哥哥的诱惑下开始建立自己的博客。平时就记录一些学习的新知识和生活上的小乐趣，yey!</p><span id="more"></span><h2 id="WORK"><a class="header-anchor" href="#WORK">¶</a>WORK</h2><h3 id="Modbus-学习情况"><a class="header-anchor" href="#Modbus-学习情况">¶</a>Modbus 学习情况</h3><p>Modbus协议广泛用于工控系统（ICS/SCADA）上，主要分为Modbus TCP、Modbus RTU、Modbus ASCⅡ。目前学习的是Modbus TCP。</p><h4 id="Modbus-TCP包结构"><a class="header-anchor" href="#Modbus-TCP包结构">¶</a>Modbus TCP包结构</h4><p><img src="/../pic/Modbus%20TCP%20structure.png" alt="img"></p><p>Modbus TCP包最大为260字节：其中，MBAP报头占7字节，PDU最大可占252字节。<br>MBAP报头：事务处理ID 2字节，协议ID 2字节，长度2字节<br>PDU：单位ID 1字节，功能码 1字节，数据部分最大252字节</p><h4 id="poster2022-Wheels-on-the-Modbus-Attacking-ModbusTCP-Communications"><a class="header-anchor" href="#poster2022-Wheels-on-the-Modbus-Attacking-ModbusTCP-Communications">¶</a>poster2022-Wheels on the Modbus - Attacking ModbusTCP Communications</h4><p>师兄发的poster</p><p><strong>1.关注点</strong><br>Modbus TCP协议及漏洞<br>攻击：Mimt、Dos、未授权的访问攻击<br><strong>2.演示工具</strong><br>Mobdus服务器仿真工具：Modbuspal<br>wireshark<br>scapy<br><strong>3.创新点</strong><br>利用包寄存器构造flood<br><strong>4.试验台</strong><br>实验试验台由西门子标志PLC、温度和湿度传感器组成。<br>温度和湿度的值被不断地读取和实时显示在HMI上。<br>这些传感器都是硬连接到西门子LogoPLC的，而PLC使用ModbusTCP将这些值实时通信到HMI。<br>温度值存储在保持寄存器中，而湿度值存储在输入寄存器中。<br>HMI分别使用Modbus函数代码0x03（读取保持寄存器）和0x04（读取输入寄存器）定期轮询西门子LogoPLC的温度和湿度值。<br><strong>度量标准</strong>：通讯时间<br>一个查询-响应-攻击循环大约7 ms，在循环之间大约100 ms（100 ms是用于编写和注入我们的恶意数据包到网络的时间段）<br><strong>5.手段</strong><br>修改MBAP标头的长度字段（长度+2）<br>PDU层中加2个附加字段（4字节）<br>注入<br><strong>6.实验结果</strong><br>现场洪水攻击有效地迫使PLC进入只听模式约7分钟，最终达到DoS场景</p><p><strong>小结论</strong><br>这篇论文中通过轮询两个寄存器来模拟HMI和PLC之间的通讯（一般两者间的ModbusTCP通信是连续循环的）；实验中修改PDU报头中的长度字段（长度字段占2字节，数值范围0-2^16）使长度数值＋2，就有可能使Modbus ADU超出最大260字节，但长度字段未超出数值范围，最终导致通信中断，实现Dos攻击。<br>这类针对设备的Dos攻击一般都是发包，效果极其明显；目前需要研究的是能否实现对单个寄存器写操作的DOS攻击（使用smod框架）……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;工作一个周，摸鱼一个周，摩尔庄园也玩腻了，在much哥哥的诱惑下开始建立自己的博客。平时就记录一些学习的新知识和生活上的小乐趣，yey!&lt;/p&gt;</summary>
    
    
    
    <category term="网络安全" scheme="https://115jiege.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>android从0开发（一）</title>
    <link href="https://115jiege.github.io/2023/03/22/%E7%A0%94%E5%8F%91/android%E5%BC%80%E5%8F%91/android%E4%BB%8E0%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://115jiege.github.io/2023/03/22/%E7%A0%94%E5%8F%91/android%E5%BC%80%E5%8F%91/android%E4%BB%8E0%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2023-03-22T06:20:39.000Z</published>
    <updated>2023-04-21T09:12:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>开发安卓平台(ˉ▽ˉ;)…<br>痛苦至极，踩了好多坑/(ㄒoㄒ)/~~</p><h2 id="开发流程"><a class="header-anchor" href="#开发流程">¶</a>开发流程</h2><p>对于在安卓平台的开发，考虑进行以下过程<br>1)安装依赖库<br>2)gmssl在安卓平台的安装<br>3)工程调用c++源码并进行调试<br>4)安卓程序细节调整<br>5)导出工程文件</p><h2 id="环境配置"><a class="header-anchor" href="#环境配置">¶</a>环境配置</h2><p><strong>开发环境</strong><br>Vmware workstation<br>ubuntu 22.04</p><p><strong>开发平台</strong><br>Android studio</p><p><strong>依赖库</strong><br>sodium<br>gmssl</p><p><strong>调试</strong><br>真机调试</p><h2 id="android-studio安装"><a class="header-anchor" href="#android-studio安装">¶</a>android studio安装</h2><h3 id="安装jdk："><a class="header-anchor" href="#安装jdk：">¶</a>安装jdk：</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> update</span><br><span class="line">sudo apt-<span class="built_in">get</span><span class="built_in"> upgrade</span></span><br><span class="line"><span class="built_in"></span>sudo apt-<span class="built_in">get</span> install default-jre</span><br><span class="line">sudo apt-<span class="built_in">get</span> install default-jdk</span><br></pre></td></tr></table></figure><p>Android studio的安装有以下三种方法(亲测)<br>法一：apt在线安装<br>法二：官网下载直接安装<br>法三：源码安装</p><h3 id="apt在线安装"><a class="header-anchor" href="#apt在线安装">¶</a>apt在线安装</h3><p>终端输入以下命令;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:maarten-fonville/android-studio</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install android-studio</span><br></pre></td></tr></table></figure><p>如果报错缺少公钥，则&quot;apt-key adv --keyserver <a href="http://keyserver.ubuntu.com">keyserver.ubuntu.com</a> --recv-keys 问题提示的公钥&quot;;</p><p>添加快捷方式:<br>‘sudo ln -s /opt/android-studio/bin/studio.sh /usr/bin/AndroidStudio’<br>在终端输入AndroidStudio或者在应用中点击图标都可以运行Android studio;</p><h3 id="官网下载直接安装"><a class="header-anchor" href="#官网下载直接安装">¶</a>官网下载直接安装</h3><p>安装jdk;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get install default-jre</span><br><span class="line">sudo apt-get install default-jdk</span><br></pre></td></tr></table></figure><p><a href="https://developer.android.google.cn/studio/#downloads">下载</a> 压缩包;</p><p>解压，sudo  ./studio.sh运行;</p><h3 id="源码安装"><a class="header-anchor" href="#源码安装">¶</a>源码安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https://redirector.gvt1.com/edgedl/android/studio/ide-zips/2021.1.1.22/android-studio-2021.1.1.22-linux.tar.gz</span><br></pre></td></tr></table></figure><p><em>ps:如果是虚拟机安装，最好把运行内存和分配的磁盘空间大一点(eg:8G 60G),AndroidStudio太大了会卡。不建议使用双核，处理器数量增多可能导致VMware变卡。</em></p><h2 id="调试"><a class="header-anchor" href="#调试">¶</a>调试</h2><p>本意是使用Android Studio自带的模拟器，但是很卡，这里使用真机调试</p><h3 id="使用adb连接手机"><a class="header-anchor" href="#使用adb连接手机">¶</a>使用adb连接手机</h3><p>当然除了使用模拟器外，还可以通过usb或者wifi连接实体机;</p><p>1)lsusb 查看usb;<br>“Bus 001 Device 022: ID xxxx:XXXX Google Inc. MI 8”</p><p>2)修改文件<br>sudo gedit /etc/udev/rules.d/51-android.rules<br>“SUBSYSTEM==“usb”, ATTR{idVendor}==“xxxx”, ATTRS{idProduct}==“XXXX”, MODE=“0666”, GROUP=“plugdev””</p><p>3)授权<br>sudo chmod a+rx /etc/udev/rules.d/51-android.rules</p><p>4)连接<br>sudo service udev restart<br>sudo udevadm trigger<br>adb kill-server<br>adb start-server<br>adb devices</p><p>总之，这样安卓模拟器就安装好了，</p><h3 id="使用usb连接真机"><a class="header-anchor" href="#使用usb连接真机">¶</a>使用usb连接真机</h3><p>虚拟机-&gt;可移动设备-&gt;连接；</p><p>打开Android Studio，可以看到真机在devices manager的physical device板块;</p><h2 id="sodium-android编译"><a class="header-anchor" href="#sodium-android编译">¶</a>sodium-android编译</h2><p>由于多数真机的cpu架构是arm64-v8a，所以这里编译的是android-arm64-v8a的libsodium库~</p><h3 id="下载项目："><a class="header-anchor" href="#下载项目：">¶</a>下载项目：</h3><p><a href="https://github.com/jedisct1/libsodium.git">libsodium项目</a></p><p>经过一系列操作，得到了一个文件夹&quot;libsodium-XXX&quot;，<a href="http://xn--androidlibsodium-h310ay26adj8lpyra.so">内含android版的libsodium.so</a>;<br>接下来进行依赖库的调用。</p><h2 id="Android-Studio调用so（C-层面）"><a class="header-anchor" href="#Android-Studio调用so（C-层面）">¶</a>Android Studio调用so（C++层面）</h2><p>首先打开Android studio，新建native c++工程;<br>第一次打开需要下载很多包，时间可能长一点，耐心等待(<em><sup>_</sup></em>)</p><h3 id="libsodium-so调用"><a class="header-anchor" href="#libsodium-so调用">¶</a>libsodium.so调用</h3><p>打开native c++工程;填写NDK安装位置(File-&gt;Project Structures:Android NDK location);<br>如果输入框无法填写，则修改项目的local.properties文件&quot;ndk.dir=/home/Android/Sdk/ndk/23.1.7779620&quot;<br>在app/src/main下新建jniLibs，把第三方so库放入jniLibs;</p><p><strong>修改Cmakelist.txt</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(sodium</span><br><span class="line">        SHARED</span><br><span class="line">        IMPORTED)</span><br><span class="line"><span class="keyword">set_target_properties</span>( sodium</span><br><span class="line">        PROPERTIES IMPORTED_LOCATION</span><br><span class="line">        <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/../jniLibs/libsodium.so)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>( <span class="comment"># Specifies the target library.</span></span><br><span class="line">        XXX</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Links the target library to the log library</span></span><br><span class="line">        <span class="comment"># included in the NDK.</span></span><br><span class="line">        sodium</span><br><span class="line">        <span class="variable">$&#123;log-lib&#125;</span>)</span><br></pre></td></tr></table></figure><p><strong>修改app/build.gradle</strong><br>配置 ndk 指定 ABI</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">android</span> &#123;</span><br><span class="line">    <span class="keyword">defaultConfig</span> &#123;</span><br><span class="line">        <span class="keyword">ndk</span> &#123;</span><br><span class="line">            abiFilters <span class="symbol">&#x27;arm64</span><span class="operator">-</span>v8a&#x27;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，编译过后，将项目目录切换至Android试图，可以看到，app目录下多了一个jniLibs文件夹，里面包含了引入的so文件和jar包，表示集成成功。</p><p>奇奇怪怪，这种方式我在win10、ubuntu2004(VM虚拟机)、mint2001(VM虚拟机)的Android Studio上都试过，都是可行的;<br>但是ubuntu2204(virtualbox)上编译build.grade时出现了怪怪的警告,所以按照要求删除local.properties文件中的ndk.dir，在setting中添加ndk版本;</p><h2 id="Android-C-开发"><a class="header-anchor" href="#Android-C-开发">¶</a>Android C++开发</h2><p>配置好依赖的so库之后，就可以调用写好的C++文件了;</p><h3 id="android-studio调用C-文件"><a class="header-anchor" href="#android-studio调用C-文件">¶</a>android studio调用C++文件</h3><p>c++文件的导入很简单，将源文件和头文件放入文件夹app/src/main/cpp;</p><p><strong>修改Cmakelist</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>( <span class="comment"># Sets the name of the library.</span></span><br><span class="line">        XXX</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Sets the library as a shared library.</span></span><br><span class="line">        SHARED</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Provides a relative path to your source file(s).</span></span><br><span class="line">        native-lib.cpp<span class="comment">#源文件)</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span><span class="comment">#头文件位置)</span></span><br></pre></td></tr></table></figure><h3 id="java-与-c-数据类型对应"><a class="header-anchor" href="#java-与-c-数据类型对应">¶</a>java 与 c++ 数据类型对应</h3><p>Android下jni所用的数据结构和c++不同；需要进行转化;</p><p><strong>转化对应关系如下</strong></p><table><thead><tr><th style="text-align:left">c++</th><th style="text-align:left">java</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">char</td><td style="text-align:left">byte</td><td style="text-align:left">8位整数</td></tr><tr><td style="text-align:left">char*</td><td style="text-align:left">String</td><td style="text-align:left">\0结尾的字符数组</td></tr><tr><td style="text-align:left">char**</td><td style="text-align:left">String[ ]</td><td style="text-align:left">字符串数组</td></tr><tr><td style="text-align:left">short</td><td style="text-align:left">short</td><td style="text-align:left">16位整数</td></tr><tr><td style="text-align:left">int</td><td style="text-align:left">int</td><td style="text-align:left">32位整数</td></tr><tr><td style="text-align:left">long long,_int64</td><td style="text-align:left">long</td><td style="text-align:left">64位整数</td></tr><tr><td style="text-align:left">float</td><td style="text-align:left">float</td><td style="text-align:left">32位浮点数</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">double</td><td style="text-align:left">64位浮点数</td></tr><tr><td style="text-align:left">struct*/struct</td><td style="text-align:left">Structure</td><td style="text-align:left">结构体数据</td></tr><tr><td style="text-align:left">(&amp;#42fp)[ ]</td><td style="text-align:left">Callback</td><td style="text-align:left">函数指针</td></tr></tbody></table><p>此外，Android中使用char有大坑，Android下的char默认是unsigned char;<br>要想用char类型,得显式的定义为 singed char c = -1.</p><p>开发目标：实现页面添加一个按钮，点击后进行连接，可实现函数某些功能等，再次点击则断开连接;<br>这里需要编写java活动，下一章再搞！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开发安卓平台(ˉ▽ˉ;)…&lt;br&gt;
痛苦至极，踩了好多坑/(ㄒoㄒ)/~~&lt;/p&gt;
&lt;h2 id=&quot;开发流程&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#开发流程&quot;&gt;¶&lt;/a&gt;开发流程&lt;/h2&gt;
&lt;p&gt;对于在安卓平台的开发，考虑进行以下过程&lt;br&gt;
1</summary>
      
    
    
    
    <category term="研发" scheme="https://115jiege.github.io/categories/%E7%A0%94%E5%8F%91/"/>
    
    
    <category term="android开发" scheme="https://115jiege.github.io/tags/android%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
